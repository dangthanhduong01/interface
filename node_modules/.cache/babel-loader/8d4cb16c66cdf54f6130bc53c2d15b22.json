{"ast":null,"code":"import { BigNumber } from '@ethersproject/bignumber';\nimport { Percent, Price, TradeType } from '@uniswap/sdk-core';\nimport _ from 'lodash';\nimport { SwapType, WRAPPED_NATIVE_CURRENCY } from '../../../..';\nimport { ChainId } from '../../../../util';\nimport { CurrencyAmount } from '../../../../util/amounts';\nimport { getHighestLiquidityV3NativePool, getHighestLiquidityV3USDPool, getL2ToL1GasUsed } from '../../../../util/gas-factory-helpers';\nimport { log } from '../../../../util/log';\nimport { buildSwapMethodParameters, buildTrade } from '../../../../util/methodParameters';\nimport { IOnChainGasModelFactory } from '../gas-model';\nimport { BASE_SWAP_COST, COST_PER_HOP, COST_PER_INIT_TICK, COST_PER_UNINIT_TICK } from './gas-costs';\n/**\n * Computes a gas estimate for a V3 swap using heuristics.\n * Considers number of hops in the route, number of ticks crossed\n * and the typical base cost for a swap.\n *\n * We get the number of ticks crossed in a swap from the QuoterV2\n * contract.\n *\n * We compute gas estimates off-chain because\n *  1/ Calling eth_estimateGas for a swaps requires the caller to have\n *     the full balance token being swapped, and approvals.\n *  2/ Tracking gas used using a wrapper contract is not accurate with Multicall\n *     due to EIP-2929. We would have to make a request for every swap we wanted to estimate.\n *  3/ For V2 we simulate all our swaps off-chain so have no way to track gas used.\n *\n * @export\n * @class V3HeuristicGasModelFactory\n */\nexport class V3HeuristicGasModelFactory extends IOnChainGasModelFactory {\n  constructor() {\n    super();\n  }\n  async buildGasModel(_ref) {\n    let {\n      chainId,\n      gasPriceWei,\n      v3poolProvider: poolProvider,\n      amountToken,\n      quoteToken,\n      l2GasDataProvider\n    } = _ref;\n    const l2GasData = l2GasDataProvider ? await l2GasDataProvider.getGasData() : undefined;\n    const usdPool = await getHighestLiquidityV3USDPool(chainId, poolProvider);\n    const calculateL1GasFees = async route => {\n      const swapOptions = {\n        type: SwapType.UNIVERSAL_ROUTER,\n        recipient: '0x0000000000000000000000000000000000000001',\n        deadlineOrPreviousBlockhash: 100,\n        slippageTolerance: new Percent(5, 10000)\n      };\n      let l1Used = BigNumber.from(0);\n      let l1FeeInWei = BigNumber.from(0);\n      if (chainId == ChainId.OPTIMISM || chainId == ChainId.OPTIMISTIC_KOVAN || chainId == ChainId.OPTIMISM_GOERLI) {\n        [l1Used, l1FeeInWei] = this.calculateOptimismToL1SecurityFee(route, swapOptions, l2GasData);\n      } else if (chainId == ChainId.ARBITRUM_ONE || chainId == ChainId.ARBITRUM_RINKEBY || chainId == ChainId.ARBITRUM_GOERLI) {\n        [l1Used, l1FeeInWei] = this.calculateArbitrumToL1SecurityFee(route, swapOptions, l2GasData);\n      }\n      // wrap fee to native currency\n      const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n      const costNativeCurrency = CurrencyAmount.fromRawAmount(nativeCurrency, l1FeeInWei.toString());\n      // convert fee into usd\n      const nativeTokenPrice = usdPool.token0.address == nativeCurrency.address ? usdPool.token0Price : usdPool.token1Price;\n      const gasCostL1USD = nativeTokenPrice.quote(costNativeCurrency);\n      let gasCostL1QuoteToken = costNativeCurrency;\n      // if the inputted token is not in the native currency, quote a native/quote token pool to get the gas cost in terms of the quote token\n      if (!quoteToken.equals(nativeCurrency)) {\n        const nativePool = await getHighestLiquidityV3NativePool(quoteToken, poolProvider);\n        if (!nativePool) {\n          log.info('Could not find a pool to convert the cost into the quote token');\n          gasCostL1QuoteToken = CurrencyAmount.fromRawAmount(quoteToken, 0);\n        } else {\n          const nativeTokenPrice = nativePool.token0.address == nativeCurrency.address ? nativePool.token0Price : nativePool.token1Price;\n          gasCostL1QuoteToken = nativeTokenPrice.quote(costNativeCurrency);\n        }\n      }\n      // gasUsedL1 is the gas units used calculated from the bytes of the calldata\n      // gasCostL1USD and gasCostL1QuoteToken is the cost of gas in each of those tokens\n      return {\n        gasUsedL1: l1Used,\n        gasCostL1USD,\n        gasCostL1QuoteToken\n      };\n    };\n    // If our quote token is WETH, we don't need to convert our gas use to be in terms\n    // of the quote token in order to produce a gas adjusted amount.\n    // We do return a gas use in USD however, so we still convert to usd.\n    const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n    if (quoteToken.equals(nativeCurrency)) {\n      const estimateGasCost = routeWithValidQuote => {\n        const {\n          totalGasCostNativeCurrency,\n          baseGasUse\n        } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n        const token0 = usdPool.token0.address == nativeCurrency.address;\n        const nativeTokenPrice = token0 ? usdPool.token0Price : usdPool.token1Price;\n        const gasCostInTermsOfUSD = nativeTokenPrice.quote(totalGasCostNativeCurrency);\n        return {\n          gasEstimate: baseGasUse,\n          gasCostInToken: totalGasCostNativeCurrency,\n          gasCostInUSD: gasCostInTermsOfUSD\n        };\n      };\n      return {\n        estimateGasCost,\n        calculateL1GasFees\n      };\n    }\n    // If the quote token is not in the native currency, we convert the gas cost to be in terms of the quote token.\n    // We do this by getting the highest liquidity <quoteToken>/<nativeCurrency> pool. eg. <quoteToken>/ETH pool.\n    const nativePool = await getHighestLiquidityV3NativePool(quoteToken, poolProvider);\n    let nativeAmountPool = null;\n    if (!amountToken.equals(nativeCurrency)) {\n      nativeAmountPool = await getHighestLiquidityV3NativePool(amountToken, poolProvider);\n    }\n    const usdToken = usdPool.token0.address == nativeCurrency.address ? usdPool.token1 : usdPool.token0;\n    const estimateGasCost = routeWithValidQuote => {\n      const {\n        totalGasCostNativeCurrency,\n        baseGasUse\n      } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n      let gasCostInTermsOfQuoteToken = null;\n      if (nativePool) {\n        const token0 = nativePool.token0.address == nativeCurrency.address;\n        // returns mid price in terms of the native currency (the ratio of quoteToken/nativeToken)\n        const nativeTokenPrice = token0 ? nativePool.token0Price : nativePool.token1Price;\n        try {\n          // native token is base currency\n          gasCostInTermsOfQuoteToken = nativeTokenPrice.quote(totalGasCostNativeCurrency);\n        } catch (err) {\n          log.info({\n            nativeTokenPriceBase: nativeTokenPrice.baseCurrency,\n            nativeTokenPriceQuote: nativeTokenPrice.quoteCurrency,\n            gasCostInEth: totalGasCostNativeCurrency.currency\n          }, 'Debug eth price token issue');\n          throw err;\n        }\n      }\n      // we have a nativeAmountPool, but not a nativePool\n      else {\n        log.info(`Unable to find ${nativeCurrency.symbol} pool with the quote token, ${quoteToken.symbol} to produce gas adjusted costs. Using amountToken to calculate gas costs.`);\n      }\n      // Highest liquidity pool for the non quote token / ETH\n      // A pool with the non quote token / ETH should not be required and errors should be handled separately\n      if (nativeAmountPool) {\n        // get current execution price (amountToken / quoteToken)\n        const executionPrice = new Price(routeWithValidQuote.amount.currency, routeWithValidQuote.quote.currency, routeWithValidQuote.amount.quotient, routeWithValidQuote.quote.quotient);\n        const inputIsToken0 = nativeAmountPool.token0.address == nativeCurrency.address;\n        // ratio of input / native\n        const nativeAmountTokenPrice = inputIsToken0 ? nativeAmountPool.token0Price : nativeAmountPool.token1Price;\n        const gasCostInTermsOfAmountToken = nativeAmountTokenPrice.quote(totalGasCostNativeCurrency);\n        // Convert gasCostInTermsOfAmountToken to quote token using execution price\n        const syntheticGasCostInTermsOfQuoteToken = executionPrice.quote(gasCostInTermsOfAmountToken);\n        // Note that the syntheticGasCost being lessThan the original quoted value is not always strictly better\n        // e.g. the scenario where the amountToken/ETH pool is very illiquid as well and returns an extremely small number\n        // however, it is better to have the gasEstimation be almost 0 than almost infinity, as the user will still receive a quote\n        if (gasCostInTermsOfQuoteToken === null || syntheticGasCostInTermsOfQuoteToken.lessThan(gasCostInTermsOfQuoteToken.asFraction)) {\n          log.info({\n            nativeAmountTokenPrice: nativeAmountTokenPrice.toSignificant(6),\n            gasCostInTermsOfQuoteToken: gasCostInTermsOfQuoteToken ? gasCostInTermsOfQuoteToken.toExact() : 0,\n            gasCostInTermsOfAmountToken: gasCostInTermsOfAmountToken.toExact(),\n            executionPrice: executionPrice.toSignificant(6),\n            syntheticGasCostInTermsOfQuoteToken: syntheticGasCostInTermsOfQuoteToken.toSignificant(6)\n          }, 'New gasCostInTermsOfQuoteToken calculated with synthetic quote token price is less than original');\n          gasCostInTermsOfQuoteToken = syntheticGasCostInTermsOfQuoteToken;\n        }\n      }\n      // true if token0 is the native currency\n      const token0USDPool = usdPool.token0.address == nativeCurrency.address;\n      // gets the mid price of the pool in terms of the native token\n      const nativeTokenPriceUSDPool = token0USDPool ? usdPool.token0Price : usdPool.token1Price;\n      let gasCostInTermsOfUSD;\n      try {\n        gasCostInTermsOfUSD = nativeTokenPriceUSDPool.quote(totalGasCostNativeCurrency);\n      } catch (err) {\n        log.info({\n          usdT1: usdPool.token0.symbol,\n          usdT2: usdPool.token1.symbol,\n          gasCostInNativeToken: totalGasCostNativeCurrency.currency.symbol\n        }, 'Failed to compute USD gas price');\n        throw err;\n      }\n      // If gasCostInTermsOfQuoteToken is null, both attempts to calculate gasCostInTermsOfQuoteToken failed (nativePool and amountNativePool)\n      if (gasCostInTermsOfQuoteToken === null) {\n        log.info(`Unable to find ${nativeCurrency.symbol} pool with the quote token, ${quoteToken.symbol}, or amount Token, ${amountToken.symbol} to produce gas adjusted costs. Route will not account for gas.`);\n        return {\n          gasEstimate: baseGasUse,\n          gasCostInToken: CurrencyAmount.fromRawAmount(quoteToken, 0),\n          gasCostInUSD: CurrencyAmount.fromRawAmount(usdToken, 0)\n        };\n      }\n      return {\n        gasEstimate: baseGasUse,\n        gasCostInToken: gasCostInTermsOfQuoteToken,\n        gasCostInUSD: gasCostInTermsOfUSD\n      };\n    };\n    return {\n      estimateGasCost: estimateGasCost.bind(this),\n      calculateL1GasFees\n    };\n  }\n  estimateGas(routeWithValidQuote, gasPriceWei, chainId) {\n    const totalInitializedTicksCrossed = BigNumber.from(Math.max(1, _.sum(routeWithValidQuote.initializedTicksCrossedList)));\n    const totalHops = BigNumber.from(routeWithValidQuote.route.pools.length);\n    const hopsGasUse = COST_PER_HOP(chainId).mul(totalHops);\n    const tickGasUse = COST_PER_INIT_TICK(chainId).mul(totalInitializedTicksCrossed);\n    const uninitializedTickGasUse = COST_PER_UNINIT_TICK.mul(0);\n    // base estimate gas used based on chainId estimates for hops and ticks gas useage\n    const baseGasUse = BASE_SWAP_COST(chainId).add(hopsGasUse).add(tickGasUse).add(uninitializedTickGasUse);\n    const baseGasCostWei = gasPriceWei.mul(baseGasUse);\n    const wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n    const totalGasCostNativeCurrency = CurrencyAmount.fromRawAmount(wrappedCurrency, baseGasCostWei.toString());\n    return {\n      totalGasCostNativeCurrency,\n      totalInitializedTicksCrossed,\n      baseGasUse\n    };\n  }\n  /**\n   * To avoid having a call to optimism's L1 security fee contract for every route and amount combination,\n   * we replicate the gas cost accounting here.\n   */\n  calculateOptimismToL1SecurityFee(routes, swapConfig, gasData) {\n    const {\n      l1BaseFee,\n      scalar,\n      decimals,\n      overhead\n    } = gasData;\n    const route = routes[0];\n    const amountToken = route.tradeType == TradeType.EXACT_INPUT ? route.amount.currency : route.quote.currency;\n    const outputToken = route.tradeType == TradeType.EXACT_INPUT ? route.quote.currency : route.amount.currency;\n    // build trade for swap calldata\n    const trade = buildTrade(amountToken, outputToken, route.tradeType, routes);\n    const data = buildSwapMethodParameters(trade, swapConfig, ChainId.OPTIMISM).calldata;\n    const l1GasUsed = getL2ToL1GasUsed(data, overhead);\n    // l1BaseFee is L1 Gas Price on etherscan\n    const l1Fee = l1GasUsed.mul(l1BaseFee);\n    const unscaled = l1Fee.mul(scalar);\n    // scaled = unscaled / (10 ** decimals)\n    const scaledConversion = BigNumber.from(10).pow(decimals);\n    const scaled = unscaled.div(scaledConversion);\n    return [l1GasUsed, scaled];\n  }\n  calculateArbitrumToL1SecurityFee(routes, swapConfig, gasData) {\n    const {\n      perL2TxFee,\n      perL1CalldataFee\n    } = gasData;\n    const route = routes[0];\n    const amountToken = route.tradeType == TradeType.EXACT_INPUT ? route.amount.currency : route.quote.currency;\n    const outputToken = route.tradeType == TradeType.EXACT_INPUT ? route.quote.currency : route.amount.currency;\n    // build trade for swap calldata\n    const trade = buildTrade(amountToken, outputToken, route.tradeType, routes);\n    const data = buildSwapMethodParameters(trade, swapConfig, ChainId.ARBITRUM_ONE).calldata;\n    // calculates gas amounts based on bytes of calldata, use 0 as overhead.\n    const l1GasUsed = getL2ToL1GasUsed(data, BigNumber.from(0));\n    // multiply by the fee per calldata and add the flat l2 fee\n    let l1Fee = l1GasUsed.mul(perL1CalldataFee);\n    l1Fee = l1Fee.add(perL2TxFee);\n    return [l1GasUsed, l1Fee];\n  }\n}","map":{"version":3,"sources":["../../../../../../src/routers/alpha-router/gas-models/v3/v3-heuristic-gas-model.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport { Percent, Price, TradeType } from '@uniswap/sdk-core';\nimport _ from 'lodash';\nimport { SwapType, WRAPPED_NATIVE_CURRENCY, } from '../../../..';\nimport { ChainId } from '../../../../util';\nimport { CurrencyAmount } from '../../../../util/amounts';\nimport { getHighestLiquidityV3NativePool, getHighestLiquidityV3USDPool, getL2ToL1GasUsed, } from '../../../../util/gas-factory-helpers';\nimport { log } from '../../../../util/log';\nimport { buildSwapMethodParameters, buildTrade, } from '../../../../util/methodParameters';\nimport { IOnChainGasModelFactory, } from '../gas-model';\nimport { BASE_SWAP_COST, COST_PER_HOP, COST_PER_INIT_TICK, COST_PER_UNINIT_TICK, } from './gas-costs';\n/**\n * Computes a gas estimate for a V3 swap using heuristics.\n * Considers number of hops in the route, number of ticks crossed\n * and the typical base cost for a swap.\n *\n * We get the number of ticks crossed in a swap from the QuoterV2\n * contract.\n *\n * We compute gas estimates off-chain because\n *  1/ Calling eth_estimateGas for a swaps requires the caller to have\n *     the full balance token being swapped, and approvals.\n *  2/ Tracking gas used using a wrapper contract is not accurate with Multicall\n *     due to EIP-2929. We would have to make a request for every swap we wanted to estimate.\n *  3/ For V2 we simulate all our swaps off-chain so have no way to track gas used.\n *\n * @export\n * @class V3HeuristicGasModelFactory\n */\nexport class V3HeuristicGasModelFactory extends IOnChainGasModelFactory {\n    constructor() {\n        super();\n    }\n    async buildGasModel({ chainId, gasPriceWei, v3poolProvider: poolProvider, amountToken, quoteToken, l2GasDataProvider, }) {\n        const l2GasData = l2GasDataProvider\n            ? await l2GasDataProvider.getGasData()\n            : undefined;\n        const usdPool = await getHighestLiquidityV3USDPool(chainId, poolProvider);\n        const calculateL1GasFees = async (route) => {\n            const swapOptions = {\n                type: SwapType.UNIVERSAL_ROUTER,\n                recipient: '0x0000000000000000000000000000000000000001',\n                deadlineOrPreviousBlockhash: 100,\n                slippageTolerance: new Percent(5, 10000),\n            };\n            let l1Used = BigNumber.from(0);\n            let l1FeeInWei = BigNumber.from(0);\n            if (chainId == ChainId.OPTIMISM ||\n                chainId == ChainId.OPTIMISTIC_KOVAN ||\n                chainId == ChainId.OPTIMISM_GOERLI) {\n                [l1Used, l1FeeInWei] = this.calculateOptimismToL1SecurityFee(route, swapOptions, l2GasData);\n            }\n            else if (chainId == ChainId.ARBITRUM_ONE ||\n                chainId == ChainId.ARBITRUM_RINKEBY ||\n                chainId == ChainId.ARBITRUM_GOERLI) {\n                [l1Used, l1FeeInWei] = this.calculateArbitrumToL1SecurityFee(route, swapOptions, l2GasData);\n            }\n            // wrap fee to native currency\n            const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n            const costNativeCurrency = CurrencyAmount.fromRawAmount(nativeCurrency, l1FeeInWei.toString());\n            // convert fee into usd\n            const nativeTokenPrice = usdPool.token0.address == nativeCurrency.address\n                ? usdPool.token0Price\n                : usdPool.token1Price;\n            const gasCostL1USD = nativeTokenPrice.quote(costNativeCurrency);\n            let gasCostL1QuoteToken = costNativeCurrency;\n            // if the inputted token is not in the native currency, quote a native/quote token pool to get the gas cost in terms of the quote token\n            if (!quoteToken.equals(nativeCurrency)) {\n                const nativePool = await getHighestLiquidityV3NativePool(quoteToken, poolProvider);\n                if (!nativePool) {\n                    log.info('Could not find a pool to convert the cost into the quote token');\n                    gasCostL1QuoteToken = CurrencyAmount.fromRawAmount(quoteToken, 0);\n                }\n                else {\n                    const nativeTokenPrice = nativePool.token0.address == nativeCurrency.address\n                        ? nativePool.token0Price\n                        : nativePool.token1Price;\n                    gasCostL1QuoteToken = nativeTokenPrice.quote(costNativeCurrency);\n                }\n            }\n            // gasUsedL1 is the gas units used calculated from the bytes of the calldata\n            // gasCostL1USD and gasCostL1QuoteToken is the cost of gas in each of those tokens\n            return {\n                gasUsedL1: l1Used,\n                gasCostL1USD,\n                gasCostL1QuoteToken,\n            };\n        };\n        // If our quote token is WETH, we don't need to convert our gas use to be in terms\n        // of the quote token in order to produce a gas adjusted amount.\n        // We do return a gas use in USD however, so we still convert to usd.\n        const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n        if (quoteToken.equals(nativeCurrency)) {\n            const estimateGasCost = (routeWithValidQuote) => {\n                const { totalGasCostNativeCurrency, baseGasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n                const token0 = usdPool.token0.address == nativeCurrency.address;\n                const nativeTokenPrice = token0\n                    ? usdPool.token0Price\n                    : usdPool.token1Price;\n                const gasCostInTermsOfUSD = nativeTokenPrice.quote(totalGasCostNativeCurrency);\n                return {\n                    gasEstimate: baseGasUse,\n                    gasCostInToken: totalGasCostNativeCurrency,\n                    gasCostInUSD: gasCostInTermsOfUSD,\n                };\n            };\n            return {\n                estimateGasCost,\n                calculateL1GasFees,\n            };\n        }\n        // If the quote token is not in the native currency, we convert the gas cost to be in terms of the quote token.\n        // We do this by getting the highest liquidity <quoteToken>/<nativeCurrency> pool. eg. <quoteToken>/ETH pool.\n        const nativePool = await getHighestLiquidityV3NativePool(quoteToken, poolProvider);\n        let nativeAmountPool = null;\n        if (!amountToken.equals(nativeCurrency)) {\n            nativeAmountPool = await getHighestLiquidityV3NativePool(amountToken, poolProvider);\n        }\n        const usdToken = usdPool.token0.address == nativeCurrency.address\n            ? usdPool.token1\n            : usdPool.token0;\n        const estimateGasCost = (routeWithValidQuote) => {\n            const { totalGasCostNativeCurrency, baseGasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n            let gasCostInTermsOfQuoteToken = null;\n            if (nativePool) {\n                const token0 = nativePool.token0.address == nativeCurrency.address;\n                // returns mid price in terms of the native currency (the ratio of quoteToken/nativeToken)\n                const nativeTokenPrice = token0\n                    ? nativePool.token0Price\n                    : nativePool.token1Price;\n                try {\n                    // native token is base currency\n                    gasCostInTermsOfQuoteToken = nativeTokenPrice.quote(totalGasCostNativeCurrency);\n                }\n                catch (err) {\n                    log.info({\n                        nativeTokenPriceBase: nativeTokenPrice.baseCurrency,\n                        nativeTokenPriceQuote: nativeTokenPrice.quoteCurrency,\n                        gasCostInEth: totalGasCostNativeCurrency.currency,\n                    }, 'Debug eth price token issue');\n                    throw err;\n                }\n            }\n            // we have a nativeAmountPool, but not a nativePool\n            else {\n                log.info(`Unable to find ${nativeCurrency.symbol} pool with the quote token, ${quoteToken.symbol} to produce gas adjusted costs. Using amountToken to calculate gas costs.`);\n            }\n            // Highest liquidity pool for the non quote token / ETH\n            // A pool with the non quote token / ETH should not be required and errors should be handled separately\n            if (nativeAmountPool) {\n                // get current execution price (amountToken / quoteToken)\n                const executionPrice = new Price(routeWithValidQuote.amount.currency, routeWithValidQuote.quote.currency, routeWithValidQuote.amount.quotient, routeWithValidQuote.quote.quotient);\n                const inputIsToken0 = nativeAmountPool.token0.address == nativeCurrency.address;\n                // ratio of input / native\n                const nativeAmountTokenPrice = inputIsToken0\n                    ? nativeAmountPool.token0Price\n                    : nativeAmountPool.token1Price;\n                const gasCostInTermsOfAmountToken = nativeAmountTokenPrice.quote(totalGasCostNativeCurrency);\n                // Convert gasCostInTermsOfAmountToken to quote token using execution price\n                const syntheticGasCostInTermsOfQuoteToken = executionPrice.quote(gasCostInTermsOfAmountToken);\n                // Note that the syntheticGasCost being lessThan the original quoted value is not always strictly better\n                // e.g. the scenario where the amountToken/ETH pool is very illiquid as well and returns an extremely small number\n                // however, it is better to have the gasEstimation be almost 0 than almost infinity, as the user will still receive a quote\n                if (gasCostInTermsOfQuoteToken === null ||\n                    syntheticGasCostInTermsOfQuoteToken.lessThan(gasCostInTermsOfQuoteToken.asFraction)) {\n                    log.info({\n                        nativeAmountTokenPrice: nativeAmountTokenPrice.toSignificant(6),\n                        gasCostInTermsOfQuoteToken: gasCostInTermsOfQuoteToken\n                            ? gasCostInTermsOfQuoteToken.toExact()\n                            : 0,\n                        gasCostInTermsOfAmountToken: gasCostInTermsOfAmountToken.toExact(),\n                        executionPrice: executionPrice.toSignificant(6),\n                        syntheticGasCostInTermsOfQuoteToken: syntheticGasCostInTermsOfQuoteToken.toSignificant(6),\n                    }, 'New gasCostInTermsOfQuoteToken calculated with synthetic quote token price is less than original');\n                    gasCostInTermsOfQuoteToken = syntheticGasCostInTermsOfQuoteToken;\n                }\n            }\n            // true if token0 is the native currency\n            const token0USDPool = usdPool.token0.address == nativeCurrency.address;\n            // gets the mid price of the pool in terms of the native token\n            const nativeTokenPriceUSDPool = token0USDPool\n                ? usdPool.token0Price\n                : usdPool.token1Price;\n            let gasCostInTermsOfUSD;\n            try {\n                gasCostInTermsOfUSD = nativeTokenPriceUSDPool.quote(totalGasCostNativeCurrency);\n            }\n            catch (err) {\n                log.info({\n                    usdT1: usdPool.token0.symbol,\n                    usdT2: usdPool.token1.symbol,\n                    gasCostInNativeToken: totalGasCostNativeCurrency.currency.symbol,\n                }, 'Failed to compute USD gas price');\n                throw err;\n            }\n            // If gasCostInTermsOfQuoteToken is null, both attempts to calculate gasCostInTermsOfQuoteToken failed (nativePool and amountNativePool)\n            if (gasCostInTermsOfQuoteToken === null) {\n                log.info(`Unable to find ${nativeCurrency.symbol} pool with the quote token, ${quoteToken.symbol}, or amount Token, ${amountToken.symbol} to produce gas adjusted costs. Route will not account for gas.`);\n                return {\n                    gasEstimate: baseGasUse,\n                    gasCostInToken: CurrencyAmount.fromRawAmount(quoteToken, 0),\n                    gasCostInUSD: CurrencyAmount.fromRawAmount(usdToken, 0),\n                };\n            }\n            return {\n                gasEstimate: baseGasUse,\n                gasCostInToken: gasCostInTermsOfQuoteToken,\n                gasCostInUSD: gasCostInTermsOfUSD,\n            };\n        };\n        return {\n            estimateGasCost: estimateGasCost.bind(this),\n            calculateL1GasFees,\n        };\n    }\n    estimateGas(routeWithValidQuote, gasPriceWei, chainId) {\n        const totalInitializedTicksCrossed = BigNumber.from(Math.max(1, _.sum(routeWithValidQuote.initializedTicksCrossedList)));\n        const totalHops = BigNumber.from(routeWithValidQuote.route.pools.length);\n        const hopsGasUse = COST_PER_HOP(chainId).mul(totalHops);\n        const tickGasUse = COST_PER_INIT_TICK(chainId).mul(totalInitializedTicksCrossed);\n        const uninitializedTickGasUse = COST_PER_UNINIT_TICK.mul(0);\n        // base estimate gas used based on chainId estimates for hops and ticks gas useage\n        const baseGasUse = BASE_SWAP_COST(chainId)\n            .add(hopsGasUse)\n            .add(tickGasUse)\n            .add(uninitializedTickGasUse);\n        const baseGasCostWei = gasPriceWei.mul(baseGasUse);\n        const wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n        const totalGasCostNativeCurrency = CurrencyAmount.fromRawAmount(wrappedCurrency, baseGasCostWei.toString());\n        return {\n            totalGasCostNativeCurrency,\n            totalInitializedTicksCrossed,\n            baseGasUse,\n        };\n    }\n    /**\n     * To avoid having a call to optimism's L1 security fee contract for every route and amount combination,\n     * we replicate the gas cost accounting here.\n     */\n    calculateOptimismToL1SecurityFee(routes, swapConfig, gasData) {\n        const { l1BaseFee, scalar, decimals, overhead } = gasData;\n        const route = routes[0];\n        const amountToken = route.tradeType == TradeType.EXACT_INPUT\n            ? route.amount.currency\n            : route.quote.currency;\n        const outputToken = route.tradeType == TradeType.EXACT_INPUT\n            ? route.quote.currency\n            : route.amount.currency;\n        // build trade for swap calldata\n        const trade = buildTrade(amountToken, outputToken, route.tradeType, routes);\n        const data = buildSwapMethodParameters(trade, swapConfig, ChainId.OPTIMISM).calldata;\n        const l1GasUsed = getL2ToL1GasUsed(data, overhead);\n        // l1BaseFee is L1 Gas Price on etherscan\n        const l1Fee = l1GasUsed.mul(l1BaseFee);\n        const unscaled = l1Fee.mul(scalar);\n        // scaled = unscaled / (10 ** decimals)\n        const scaledConversion = BigNumber.from(10).pow(decimals);\n        const scaled = unscaled.div(scaledConversion);\n        return [l1GasUsed, scaled];\n    }\n    calculateArbitrumToL1SecurityFee(routes, swapConfig, gasData) {\n        const { perL2TxFee, perL1CalldataFee } = gasData;\n        const route = routes[0];\n        const amountToken = route.tradeType == TradeType.EXACT_INPUT\n            ? route.amount.currency\n            : route.quote.currency;\n        const outputToken = route.tradeType == TradeType.EXACT_INPUT\n            ? route.quote.currency\n            : route.amount.currency;\n        // build trade for swap calldata\n        const trade = buildTrade(amountToken, outputToken, route.tradeType, routes);\n        const data = buildSwapMethodParameters(trade, swapConfig, ChainId.ARBITRUM_ONE).calldata;\n        // calculates gas amounts based on bytes of calldata, use 0 as overhead.\n        const l1GasUsed = getL2ToL1GasUsed(data, BigNumber.from(0));\n        // multiply by the fee per calldata and add the flat l2 fee\n        let l1Fee = l1GasUsed.mul(perL1CalldataFee);\n        l1Fee = l1Fee.add(perL2TxFee);\n        return [l1GasUsed, l1Fee];\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidjMtaGV1cmlzdGljLWdhcy1tb2RlbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9yb3V0ZXJzL2FscGhhLXJvdXRlci9nYXMtbW9kZWxzL3YzL3YzLWhldXJpc3RpYy1nYXMtbW9kZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRTlELE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUV2QixPQUFPLEVBRUwsUUFBUSxFQUNSLHVCQUF1QixHQUN4QixNQUFNLGFBQWEsQ0FBQztBQUtyQixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDM0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzFELE9BQU8sRUFDTCwrQkFBK0IsRUFDL0IsNEJBQTRCLEVBQzVCLGdCQUFnQixHQUNqQixNQUFNLHNDQUFzQyxDQUFDO0FBQzlDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMzQyxPQUFPLEVBQ0wseUJBQXlCLEVBQ3pCLFVBQVUsR0FDWCxNQUFNLG1DQUFtQyxDQUFDO0FBRTNDLE9BQU8sRUFHTCx1QkFBdUIsR0FDeEIsTUFBTSxjQUFjLENBQUM7QUFFdEIsT0FBTyxFQUNMLGNBQWMsRUFDZCxZQUFZLEVBQ1osa0JBQWtCLEVBQ2xCLG9CQUFvQixHQUNyQixNQUFNLGFBQWEsQ0FBQztBQUVyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFDSCxNQUFNLE9BQU8sMEJBQTJCLFNBQVEsdUJBQXVCO0lBQ3JFO1FBQ0UsS0FBSyxFQUFFLENBQUM7SUFDVixDQUFDO0lBRU0sS0FBSyxDQUFDLGFBQWEsQ0FBQyxFQUN6QixPQUFPLEVBQ1AsV0FBVyxFQUNY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"]},"metadata":{},"sourceType":"module"}