{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar invariant = _interopDefault(require('tiny-invariant'));\nvar UniversalRouter_json = require('@uniswap/universal-router/artifacts/contracts/UniversalRouter.sol/UniversalRouter.json');\nvar abi$7 = require('@ethersproject/abi');\nvar ethers = require('ethers');\nvar JSBI = _interopDefault(require('jsbi'));\nvar utils = require('ethers/lib/utils');\nvar v2Sdk = require('@uniswap/v2-sdk');\nvar v3Sdk = require('@uniswap/v3-sdk');\nvar routerSdk = require('@uniswap/router-sdk');\nvar sdkCore = require('@uniswap/sdk-core');\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n(function (RouterTradeType) {\n  RouterTradeType[\"UniswapTrade\"] = \"UniswapTrade\";\n  RouterTradeType[\"NFTTrade\"] = \"NFTTrade\";\n  RouterTradeType[\"UnwrapWETH\"] = \"UnwrapWETH\";\n})(exports.RouterTradeType || (exports.RouterTradeType = {}));\nvar _ABI_DEFINITION;\n/**\n * CommandTypes\n * @description Flags that modify a command's execution\n * @enum {number}\n */\nvar CommandType;\n(function (CommandType) {\n  CommandType[CommandType[\"V3_SWAP_EXACT_IN\"] = 0] = \"V3_SWAP_EXACT_IN\";\n  CommandType[CommandType[\"V3_SWAP_EXACT_OUT\"] = 1] = \"V3_SWAP_EXACT_OUT\";\n  CommandType[CommandType[\"PERMIT2_TRANSFER_FROM\"] = 2] = \"PERMIT2_TRANSFER_FROM\";\n  CommandType[CommandType[\"PERMIT2_PERMIT_BATCH\"] = 3] = \"PERMIT2_PERMIT_BATCH\";\n  CommandType[CommandType[\"SWEEP\"] = 4] = \"SWEEP\";\n  CommandType[CommandType[\"TRANSFER\"] = 5] = \"TRANSFER\";\n  CommandType[CommandType[\"PAY_PORTION\"] = 6] = \"PAY_PORTION\";\n  CommandType[CommandType[\"V2_SWAP_EXACT_IN\"] = 8] = \"V2_SWAP_EXACT_IN\";\n  CommandType[CommandType[\"V2_SWAP_EXACT_OUT\"] = 9] = \"V2_SWAP_EXACT_OUT\";\n  CommandType[CommandType[\"PERMIT\"] = 10] = \"PERMIT\";\n  CommandType[CommandType[\"WRAP_ETH\"] = 11] = \"WRAP_ETH\";\n  CommandType[CommandType[\"UNWRAP_WETH\"] = 12] = \"UNWRAP_WETH\";\n  CommandType[CommandType[\"PERMIT2_TRANSFER_FROM_BATCH\"] = 13] = \"PERMIT2_TRANSFER_FROM_BATCH\";\n  // NFT-related command types\n  CommandType[CommandType[\"SEAPORT\"] = 16] = \"SEAPORT\";\n  CommandType[CommandType[\"LOOKS_RARE_721\"] = 17] = \"LOOKS_RARE_721\";\n  CommandType[CommandType[\"NFTX\"] = 18] = \"NFTX\";\n  CommandType[CommandType[\"CRYPTOPUNKS\"] = 19] = \"CRYPTOPUNKS\";\n  CommandType[CommandType[\"LOOKS_RARE_1155\"] = 20] = \"LOOKS_RARE_1155\";\n  CommandType[CommandType[\"OWNER_CHECK_721\"] = 21] = \"OWNER_CHECK_721\";\n  CommandType[CommandType[\"OWNER_CHECK_1155\"] = 22] = \"OWNER_CHECK_1155\";\n  CommandType[CommandType[\"X2Y2_721\"] = 24] = \"X2Y2_721\";\n  CommandType[CommandType[\"SUDOSWAP\"] = 25] = \"SUDOSWAP\";\n  CommandType[CommandType[\"NFT20\"] = 26] = \"NFT20\";\n  CommandType[CommandType[\"X2Y2_1155\"] = 27] = \"X2Y2_1155\";\n  CommandType[CommandType[\"FOUNDATION\"] = 28] = \"FOUNDATION\";\n})(CommandType || (CommandType = {}));\nvar PERMIT_STRUCT = '((address token,uint160 amount,uint48 expiration,uint48 nonce) details, address spender, uint256 sigDeadline)';\nvar PERMIT_BATCH_STRUCT = '((address token,uint160 amount,uint48 expiration,uint48 nonce)[] details, address spender, uint256 sigDeadline)';\nvar ALLOW_REVERT_FLAG = 0x80;\nvar REVERTABLE_COMMANDS = /*#__PURE__*/new Set([CommandType.SEAPORT, CommandType.NFTX, CommandType.LOOKS_RARE_721, CommandType.LOOKS_RARE_1155, CommandType.X2Y2_721, CommandType.X2Y2_1155, CommandType.FOUNDATION, CommandType.SUDOSWAP, CommandType.NFT20, CommandType.CRYPTOPUNKS]);\nvar ABI_DEFINITION = (_ABI_DEFINITION = {}, _ABI_DEFINITION[CommandType.PERMIT] = [PERMIT_STRUCT, 'bytes'], _ABI_DEFINITION[CommandType.PERMIT2_PERMIT_BATCH] = [PERMIT_BATCH_STRUCT, 'bytes'], _ABI_DEFINITION[CommandType.PERMIT2_TRANSFER_FROM] = ['address', 'address', 'uint160'], _ABI_DEFINITION[CommandType.PERMIT2_TRANSFER_FROM_BATCH] = ['bytes'], _ABI_DEFINITION[CommandType.TRANSFER] = ['address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.V3_SWAP_EXACT_IN] = ['address', 'uint256', 'uint256', 'bytes', 'bool'], _ABI_DEFINITION[CommandType.V3_SWAP_EXACT_OUT] = ['address', 'uint256', 'uint256', 'bytes', 'bool'], _ABI_DEFINITION[CommandType.V2_SWAP_EXACT_IN] = ['address', 'uint256', 'uint256', 'address[]', 'bool'], _ABI_DEFINITION[CommandType.V2_SWAP_EXACT_OUT] = ['address', 'uint256', 'uint256', 'address[]', 'bool'], _ABI_DEFINITION[CommandType.SEAPORT] = ['uint256', 'bytes'], _ABI_DEFINITION[CommandType.WRAP_ETH] = ['address', 'uint256'], _ABI_DEFINITION[CommandType.UNWRAP_WETH] = ['address', 'uint256'], _ABI_DEFINITION[CommandType.SWEEP] = ['address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.NFTX] = ['uint256', 'bytes'], _ABI_DEFINITION[CommandType.LOOKS_RARE_721] = ['uint256', 'bytes', 'address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.LOOKS_RARE_1155] = ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'], _ABI_DEFINITION[CommandType.X2Y2_721] = ['uint256', 'bytes', 'address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.X2Y2_1155] = ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'], _ABI_DEFINITION[CommandType.FOUNDATION] = ['uint256', 'bytes', 'address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.PAY_PORTION] = ['address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.SUDOSWAP] = ['uint256', 'bytes'], _ABI_DEFINITION[CommandType.OWNER_CHECK_721] = ['address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.OWNER_CHECK_1155] = ['address', 'address', 'uint256', 'uint256'], _ABI_DEFINITION[CommandType.NFT20] = ['uint256', 'bytes'], _ABI_DEFINITION[CommandType.CRYPTOPUNKS] = ['uint256', 'address', 'uint256'], _ABI_DEFINITION);\nvar RoutePlanner = /*#__PURE__*/function () {\n  function RoutePlanner() {\n    this.commands = '0x';\n    this.inputs = [];\n  }\n  var _proto = RoutePlanner.prototype;\n  _proto.addCommand = function addCommand(type, parameters, allowRevert) {\n    if (allowRevert === void 0) {\n      allowRevert = false;\n    }\n    var command = createCommand(type, parameters);\n    this.inputs.push(command.encodedInput);\n    if (allowRevert) {\n      if (!REVERTABLE_COMMANDS.has(command.type)) {\n        throw new Error(\"command type: \" + command.type + \" cannot be allowed to revert\");\n      }\n      command.type = command.type | ALLOW_REVERT_FLAG;\n    }\n    this.commands = this.commands.concat(command.type.toString(16).padStart(2, '0'));\n  };\n  return RoutePlanner;\n}();\nfunction createCommand(type, parameters) {\n  var encodedInput = utils.defaultAbiCoder.encode(ABI_DEFINITION[type], parameters);\n  return {\n    type: type,\n    encodedInput: encodedInput\n  };\n}\nvar UNIVERSAL_ROUTER_ADDRESS = function UNIVERSAL_ROUTER_ADDRESS(chainId) {\n  switch (chainId) {\n    case 1:\n      // mainnet\n      return '0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B';\n    case 5:\n      // goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 137:\n      // polygon\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5';\n    case 80001:\n      // polygon mumbai\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 10:\n      // optimism\n      return '0xb555edF5dcF85f42cEeF1f3630a52A108E55A654';\n    case 420:\n      // optimism goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 42161:\n      // arbitrum\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5';\n    case 421613:\n      // arbitrum goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 42220:\n      // celo\n      return '0xC73d61d192FB994157168Fb56730FdEc64C9Cb8F';\n    case 44787:\n      // celo alfajores\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 56:\n      // binance smart chain\n      return '0x5Dc88340E1c5c6366864Ee415d6034cadd1A9897';\n    case 11968:\n      // trustkey network chain\n      return '0x1c6e08001dF8cB749B428312E004F159791532CB';\n    default:\n      throw new Error(\"Universal Router not deployed on chain \" + chainId);\n  }\n};\nvar WETH_ADDRESS = function WETH_ADDRESS(chainId) {\n  switch (chainId) {\n    case 1:\n      //mainnet\n      return '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';\n    case 5:\n      // goerli\n      return '0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6';\n    case 137:\n      // polygon\n      return '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270';\n    case 80001:\n      // polygon mumbai\n      return '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889';\n    case 10:\n      // optimism\n      return '0x4200000000000000000000000000000000000006';\n    case 420:\n      // optimism goerli\n      return '0x4200000000000000000000000000000000000006';\n    case 42161:\n      // arbitrum\n      return '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1';\n    case 421613:\n      // arbitrum goerli\n      return '0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3';\n    case 56:\n      // binance smart chain\n      return '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c';\n    case 11968:\n      return '0x528f15986Dd88Cc90ad134F1c9d759729Ae925Af';\n    default:\n      throw new Error(\"WETH9 or UniversalRouter not deployed on chain \" + chainId);\n  }\n};\nvar PERMIT2_ADDRESS = '0x865CD1139da08824ecD3f5b1270287C89e3D1543';\nvar CONTRACT_BALANCE = /*#__PURE__*/ethers.BigNumber.from(2).pow(255);\nvar ETH_ADDRESS = '0x0000000000000000000000000000000000000000';\nvar SENDER_AS_RECIPIENT = '0x0000000000000000000000000000000000000001';\nvar ROUTER_AS_RECIPIENT = '0x0000000000000000000000000000000000000002';\nvar REFUND_ETH_PRICE_IMPACT_THRESHOLD = /*#__PURE__*/new sdkCore.Percent( /*#__PURE__*/JSBI.BigInt(50), /*#__PURE__*/JSBI.BigInt(100));\n// Wrapper for uniswap router-sdk trade entity to encode swaps for Universal Router\n// also translates trade objects from previous (v2, v3) SDKs\nvar UniswapTrade = /*#__PURE__*/function () {\n  function UniswapTrade(trade, options) {\n    this.trade = trade;\n    this.options = options;\n    this.tradeType = exports.RouterTradeType.UniswapTrade;\n  }\n  var _proto = UniswapTrade.prototype;\n  _proto.encode = function encode(planner, _config) {\n    var _this$options$recipie;\n    var payerIsUser = true;\n    if (this.trade.inputAmount.currency.isNative) {\n      // TODO: optimize if only one v2 pool we can directly send this to the pool\n      planner.addCommand(CommandType.WRAP_ETH, [ROUTER_AS_RECIPIENT, this.trade.maximumAmountIn(this.options.slippageTolerance).quotient.toString()]);\n      // since WETH is now owned by the router, the router pays for inputs\n      payerIsUser = false;\n    }\n    this.options.recipient = (_this$options$recipie = this.options.recipient) != null ? _this$options$recipie : SENDER_AS_RECIPIENT;\n    // flag for whether we want to perform slippage check on aggregate output of multiple routes\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    var performAggregatedSlippageCheck = this.trade.tradeType === sdkCore.TradeType.EXACT_INPUT && this.trade.routes.length > 2;\n    var outputIsNative = this.trade.outputAmount.currency.isNative;\n    var inputIsNative = this.trade.inputAmount.currency.isNative;\n    var routerMustCustody = performAggregatedSlippageCheck || outputIsNative;\n    for (var _iterator = _createForOfIteratorHelperLoose(this.trade.swaps), _step; !(_step = _iterator()).done;) {\n      var swap = _step.value;\n      switch (swap.route.protocol) {\n        case routerSdk.Protocol.V2:\n          addV2Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody);\n          break;\n        case routerSdk.Protocol.V3:\n          addV3Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody);\n          break;\n        case routerSdk.Protocol.MIXED:\n          addMixedSwap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody);\n          break;\n        default:\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL');\n      }\n    }\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString()]);\n      } else {\n        planner.addCommand(CommandType.SWEEP, [this.trade.outputAmount.currency.wrapped.address, this.options.recipient, this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString()]);\n      }\n    }\n    if (inputIsNative && (this.trade.tradeType === sdkCore.TradeType.EXACT_OUTPUT || riskOfPartialFill(this.trade))) {\n      // for exactOutput swaps that take native currency as input\n      // we need to send back the change to the user\n      planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, 0]);\n    }\n  };\n  return UniswapTrade;\n}();\n// encode a uniswap v2 swap\nfunction addV2Swap(planner, _ref, tradeType, options, payerIsUser, routerMustCustody) {\n  var route = _ref.route,\n    inputAmount = _ref.inputAmount,\n    outputAmount = _ref.outputAmount;\n  var trade = new v2Sdk.Trade(route, tradeType == sdkCore.TradeType.EXACT_INPUT ? inputAmount : outputAmount, tradeType);\n  if (tradeType == sdkCore.TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n    // if native, we have to unwrap so keep in the router for now\n    routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient, trade.maximumAmountIn(options.slippageTolerance).quotient.toString(), trade.minimumAmountOut(options.slippageTolerance).quotient.toString(), route.path.map(function (pool) {\n      return pool.address;\n    }), payerIsUser]);\n  } else if (tradeType == sdkCore.TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_OUT, [routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient, trade.minimumAmountOut(options.slippageTolerance).quotient.toString(), trade.maximumAmountIn(options.slippageTolerance).quotient.toString(), route.path.map(function (pool) {\n      return pool.address;\n    }), payerIsUser]);\n  }\n}\n// encode a uniswap v3 swap\nfunction addV3Swap(planner, _ref2, tradeType, options, payerIsUser, routerMustCustody) {\n  var route = _ref2.route,\n    inputAmount = _ref2.inputAmount,\n    outputAmount = _ref2.outputAmount;\n  var trade = v3Sdk.Trade.createUncheckedTrade({\n    route: route,\n    inputAmount: inputAmount,\n    outputAmount: outputAmount,\n    tradeType: tradeType\n  });\n  var path = v3Sdk.encodeRouteToPath(route, trade.tradeType === sdkCore.TradeType.EXACT_OUTPUT);\n  if (tradeType == sdkCore.TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient, trade.maximumAmountIn(options.slippageTolerance).quotient.toString(), trade.minimumAmountOut(options.slippageTolerance).quotient.toString(), path, payerIsUser]);\n  } else if (tradeType == sdkCore.TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_OUT, [routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient, trade.minimumAmountOut(options.slippageTolerance).quotient.toString(), trade.maximumAmountIn(options.slippageTolerance).quotient.toString(), path, payerIsUser]);\n  }\n}\n// encode a mixed route swap, i.e. including both v2 and v3 pools\nfunction addMixedSwap(planner, swap, tradeType, options, payerIsUser, routerMustCustody) {\n  var route = swap.route,\n    inputAmount = swap.inputAmount,\n    outputAmount = swap.outputAmount;\n  var tradeRecipient = routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient;\n  // single hop, so it can be reduced to plain v2 or v3 swap logic\n  if (route.pools.length === 1) {\n    if (route.pools[0] instanceof v3Sdk.Pool) {\n      return addV3Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody);\n    } else if (route.pools[0] instanceof v2Sdk.Pair) {\n      return addV2Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody);\n    } else {\n      throw new Error('Invalid route type');\n    }\n  }\n  var trade = routerSdk.MixedRouteTrade.createUncheckedTrade({\n    route: route,\n    inputAmount: inputAmount,\n    outputAmount: outputAmount,\n    tradeType: tradeType\n  });\n  var amountIn = trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient.toString();\n  var amountOut = trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient.toString();\n  // logic from\n  // https://github.com/Uniswap/router-sdk/blob/d8eed164e6c79519983844ca8b6a3fc24ebcb8f8/src/swapRouter.ts#L276\n  var sections = routerSdk.partitionMixedRouteByProtocol(route);\n  var isLastSectionInRoute = function isLastSectionInRoute(i) {\n    return i === sections.length - 1;\n  };\n  var outputToken;\n  var inputToken = route.input.wrapped;\n  for (var i = 0; i < sections.length; i++) {\n    var section = sections[i];\n    /// Now, we get output of this section\n    outputToken = routerSdk.getOutputOfPools(section, inputToken);\n    var newRouteOriginal = new routerSdk.MixedRouteSDK([].concat(section), section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1, outputToken);\n    var newRoute = new routerSdk.MixedRoute(newRouteOriginal);\n    /// Previous output is now input\n    inputToken = outputToken;\n    var mixedRouteIsAllV3 = function mixedRouteIsAllV3(route) {\n      return route.pools.every(function (pool) {\n        return pool instanceof v3Sdk.Pool;\n      });\n    };\n    if (mixedRouteIsAllV3(newRoute)) {\n      var path = routerSdk.encodeMixedRouteToPath(newRoute);\n      planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n      // if not last section: send tokens directly to the first v2 pair of the next section\n      // note: because of the partitioning function we can be sure that the next section is v2\n      isLastSectionInRoute(i) ? tradeRecipient : sections[i + 1][0].liquidityToken.address, i == 0 ? amountIn : CONTRACT_BALANCE, !isLastSectionInRoute(i) ? 0 : amountOut, path, payerIsUser && i === 0]);\n    } else {\n      planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [isLastSectionInRoute(i) ? tradeRecipient : ROUTER_AS_RECIPIENT, i === 0 ? amountIn : CONTRACT_BALANCE, !isLastSectionInRoute(i) ? 0 : amountOut, newRoute.path.map(function (pool) {\n        return pool.address;\n      }), payerIsUser && i === 0]);\n    }\n  }\n}\n// if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\nfunction riskOfPartialFill(trade) {\n  return trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD);\n}\nvar SIGNATURE_LENGTH = 65;\nvar EIP_2098_SIGNATURE_LENGTH = 64;\nfunction encodePermit(planner, permit) {\n  var signature = permit.signature;\n  var length = ethers.ethers.utils.arrayify(permit.signature).length;\n  // signature data provided for EIP-1271 may have length different from ECDSA signature\n  if (length === SIGNATURE_LENGTH || length === EIP_2098_SIGNATURE_LENGTH) {\n    // sanitizes signature to cover edge cases of malformed EIP-2098 sigs and v used as recovery id\n    signature = ethers.ethers.utils.joinSignature(ethers.ethers.utils.splitSignature(permit.signature));\n  }\n  planner.addCommand(CommandType.PERMIT, [permit, signature]);\n}\nvar SwapRouter = /*#__PURE__*/function () {\n  function SwapRouter() {}\n  SwapRouter.swapCallParameters = function swapCallParameters(trades, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    if (!Array.isArray(trades)) trades = [trades];\n    var nftTrades = trades.filter(function (trade, _, _ref) {\n      return trade.hasOwnProperty('market');\n    });\n    var allowRevert = nftTrades.length == 1 && nftTrades[0].orders.length == 1 ? false : true;\n    var planner = new RoutePlanner();\n    // track value flow to require the right amount of native value\n    var currentNativeValueInRouter = ethers.BigNumber.from(0);\n    var transactionValue = ethers.BigNumber.from(0);\n    for (var _iterator = _createForOfIteratorHelperLoose(trades), _step; !(_step = _iterator()).done;) {\n      var trade = _step.value;\n      /**\n       * is NFTTrade\n       */\n      if (trade.tradeType == exports.RouterTradeType.NFTTrade) {\n        var nftTrade = trade;\n        nftTrade.encode(planner, {\n          allowRevert: allowRevert\n        });\n        var tradePrice = nftTrade.getTotalPrice();\n        // send enough native value to contract for NFT purchase\n        if (currentNativeValueInRouter.lt(tradePrice)) {\n          transactionValue = transactionValue.add(tradePrice.sub(currentNativeValueInRouter));\n          currentNativeValueInRouter = ethers.BigNumber.from(0);\n        } else {\n          currentNativeValueInRouter = currentNativeValueInRouter.sub(tradePrice);\n        }\n        /**\n         * is Uniswap Trade\n         */\n      } else if (trade.tradeType == exports.RouterTradeType.UniswapTrade) {\n        var uniswapTrade = trade;\n        var inputIsNative = uniswapTrade.trade.inputAmount.currency.isNative;\n        var outputIsNative = uniswapTrade.trade.outputAmount.currency.isNative;\n        var swapOptions = uniswapTrade.options;\n        !!(inputIsNative && !!swapOptions.inputTokenPermit) ? invariant(false, 'NATIVE_INPUT_PERMIT') : void 0;\n        if (!!swapOptions.inputTokenPermit) {\n          encodePermit(planner, swapOptions.inputTokenPermit);\n        }\n        if (inputIsNative) {\n          transactionValue = transactionValue.add(ethers.BigNumber.from(uniswapTrade.trade.maximumAmountIn(swapOptions.slippageTolerance).quotient.toString()));\n        }\n        // track amount of native currency in the router\n        if (outputIsNative && swapOptions.recipient == ROUTER_AS_RECIPIENT) {\n          currentNativeValueInRouter = currentNativeValueInRouter.add(ethers.BigNumber.from(uniswapTrade.trade.minimumAmountOut(swapOptions.slippageTolerance).quotient.toString()));\n        }\n        uniswapTrade.encode(planner, {\n          allowRevert: false\n        });\n        /**\n         * is UnwrapWETH\n         */\n      } else if (trade.tradeType == exports.RouterTradeType.UnwrapWETH) {\n        var UnwrapWETH = trade;\n        trade.encode(planner, {\n          allowRevert: false\n        });\n        currentNativeValueInRouter = currentNativeValueInRouter.add(UnwrapWETH.amount);\n        /**\n         * else\n         */\n      } else {\n        throw 'trade must be of instance: UniswapTrade or NFTTrade';\n      }\n    }\n    // TODO: matches current logic for now, but should eventually only sweep for multiple NFT trades\n    // or NFT trades with potential slippage (i.e. sudo)\n    if (nftTrades.length > 0) planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0]);\n    return SwapRouter.encodePlan(planner, transactionValue, config);\n  }\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given swap.\n   * @param trades to produce call parameters for\n   */;\n  SwapRouter.swapNFTCallParameters = function swapNFTCallParameters(trades, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var planner = new RoutePlanner();\n    var totalPrice = ethers.BigNumber.from(0);\n    var allowRevert = trades.length == 1 && trades[0].orders.length == 1 ? false : true;\n    for (var _iterator2 = _createForOfIteratorHelperLoose(trades), _step2; !(_step2 = _iterator2()).done;) {\n      var trade = _step2.value;\n      trade.encode(planner, {\n        allowRevert: allowRevert\n      });\n      totalPrice = totalPrice.add(trade.getTotalPrice());\n    }\n    planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0]);\n    return SwapRouter.encodePlan(planner, totalPrice, config);\n  }\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */;\n  SwapRouter.swapERC20CallParameters = function swapERC20CallParameters(trades, options) {\n    // TODO: use permit if signature included in swapOptions\n    var planner = new RoutePlanner();\n    var trade = new UniswapTrade(trades, options);\n    var inputCurrency = trade.trade.inputAmount.currency;\n    !!(inputCurrency.isNative && !!options.inputTokenPermit) ? invariant(false, 'NATIVE_INPUT_PERMIT') : void 0;\n    if (options.inputTokenPermit) {\n      encodePermit(planner, options.inputTokenPermit);\n    }\n    var nativeCurrencyValue = inputCurrency.isNative ? ethers.BigNumber.from(trade.trade.maximumAmountIn(options.slippageTolerance).quotient.toString()) : ethers.BigNumber.from(0);\n    trade.encode(planner, {\n      allowRevert: false\n    });\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue, {\n      deadline: options.deadlineOrPreviousBlockhash ? ethers.BigNumber.from(options.deadlineOrPreviousBlockhash) : undefined\n    });\n  }\n  /**\n   * Encodes a planned route into a method name and parameters for the Router contract.\n   * @param planner the planned route\n   * @param nativeCurrencyValue the native currency value of the planned route\n   * @param config the router config\n   */;\n  SwapRouter.encodePlan = function encodePlan(planner, nativeCurrencyValue, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var commands = planner.commands,\n      inputs = planner.inputs;\n    var functionSignature = !!config.deadline ? 'execute(bytes,bytes[],uint256)' : 'execute(bytes,bytes[])';\n    var parameters = !!config.deadline ? [commands, inputs, config.deadline] : [commands, inputs];\n    var calldata = SwapRouter.INTERFACE.encodeFunctionData(functionSignature, parameters);\n    return {\n      calldata: calldata,\n      value: nativeCurrencyValue.toHexString()\n    };\n  };\n  return SwapRouter;\n}();\nSwapRouter.INTERFACE = /*#__PURE__*/new abi$7.Interface(UniversalRouter_json.abi);\nvar NFTTrade = function NFTTrade(market, orders) {\n  this.tradeType = exports.RouterTradeType.NFTTrade;\n  !(orders.length > 0) ? invariant(false, 'no buy Items') : void 0;\n  this.market = market;\n  this.orders = orders;\n};\n(function (Market) {\n  Market[\"Foundation\"] = \"foundation\";\n  Market[\"LooksRare\"] = \"looksrare\";\n  Market[\"NFT20\"] = \"nft20\";\n  Market[\"NFTX\"] = \"nftx\";\n  Market[\"Seaport\"] = \"seaport\";\n  Market[\"Sudoswap\"] = \"Sudoswap\";\n  Market[\"Cryptopunks\"] = \"cryptopunks\";\n  Market[\"X2Y2\"] = \"x2y2\";\n})(exports.Market || (exports.Market = {}));\n(function (TokenType) {\n  TokenType[\"ERC721\"] = \"ERC721\";\n  TokenType[\"ERC1155\"] = \"ERC1155\";\n  TokenType[\"Cryptopunk\"] = \"Cryptopunk\";\n})(exports.TokenType || (exports.TokenType = {}));\nvar CryptopunkTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(CryptopunkTrade, _NFTTrade);\n  function CryptopunkTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.Cryptopunks, orders) || this;\n  }\n  var _proto = CryptopunkTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      planner.addCommand(CommandType.CRYPTOPUNKS, [item.tokenId, item.recipient, item.value], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var item = _step2.value;\n      buyItems.push({\n        tokenAddress: CryptopunkTrade.CRYPTOPUNK_ADDRESS,\n        tokenId: item.tokenId,\n        tokenType: exports.TokenType.Cryptopunk\n      });\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var item = _step3.value;\n      total = total.add(item.value);\n    }\n    return total;\n  };\n  return CryptopunkTrade;\n}(NFTTrade);\nCryptopunkTrade.CRYPTOPUNK_ADDRESS = '0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb';\nvar abi = [{\n  inputs: [{\n    internalType: \"address payable\",\n    name: \"treasury\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"feth\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"royaltyRegistry\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"duration\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  inputs: [],\n  name: \"FoundationTreasuryNode_Address_Is_Not_A_Contract\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"FoundationTreasuryNode_Caller_Not_Admin\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"buyPrice\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketBuyPrice_Cannot_Buy_At_Lower_Price\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketBuyPrice_Cannot_Buy_Unset_Price\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketBuyPrice_Cannot_Cancel_Unset_Price\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketBuyPrice_Only_Owner_Can_Cancel_Price\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketBuyPrice_Only_Owner_Can_Set_Price\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketBuyPrice_Price_Already_Set\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketBuyPrice_Price_Too_High\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketBuyPrice_Seller_Mismatch\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketCore_FETH_Address_Is_Not_A_Contract\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketCore_Only_FETH_Can_Transfer_ETH\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketCore_Seller_Not_Found\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketOffer_Cannot_Be_Made_While_In_Auction\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"currentOfferAmount\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketOffer_Offer_Below_Min_Amount\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"expiry\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketOffer_Offer_Expired\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"currentOfferFrom\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketOffer_Offer_From_Does_Not_Match\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"minOfferAmount\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketOffer_Provided_Contract_And_TokenId_Count_Must_Match\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketOffer_Reason_Required\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Already_Listed\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"minAmount\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"endTime\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"endTime\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"maxDuration\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Exceeds_Max_Duration\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"extensionDuration\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Less_Than_Extension_Duration\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketReserveAuction_Not_Matching_Seller\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketReserveAuction_Only_Owner_Can_Update_Auction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Price_Already_Set\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Too_Much_Value_Provided\",\n  type: \"error\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"buyer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"protocolFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"creatorFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"sellerRev\",\n    type: \"uint256\"\n  }],\n  name: \"BuyPriceAccepted\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"BuyPriceCanceled\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"BuyPriceInvalidated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"BuyPriceSet\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"buyReferrer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"buyReferrerProtocolFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"buyReferrerSellerFee\",\n    type: \"uint256\"\n  }],\n  name: \"BuyReferralPaid\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint8\",\n    name: \"version\",\n    type: \"uint8\"\n  }],\n  name: \"Initialized\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"buyer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"protocolFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"creatorFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"sellerRev\",\n    type: \"uint256\"\n  }],\n  name: \"OfferAccepted\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"string\",\n    name: \"reason\",\n    type: \"string\"\n  }],\n  name: \"OfferCanceledByAdmin\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"OfferInvalidated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"buyer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"expiration\",\n    type: \"uint256\"\n  }],\n  name: \"OfferMade\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"bidder\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"endTime\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionBidPlaced\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionCanceled\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"string\",\n    name: \"reason\",\n    type: \"string\"\n  }],\n  name: \"ReserveAuctionCanceledByAdmin\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"duration\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"extensionDuration\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionCreated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"bidder\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"protocolFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"creatorFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"sellerRev\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionFinalized\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionInvalidated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionUpdated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"WithdrawalToFETH\",\n  type: \"event\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"offerFrom\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minAmount\",\n    type: \"uint256\"\n  }],\n  name: \"acceptOffer\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address[]\",\n    name: \"nftContracts\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"tokenIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"string\",\n    name: \"reason\",\n    type: \"string\"\n  }],\n  name: \"adminCancelOffers\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"string\",\n    name: \"reason\",\n    type: \"string\"\n  }],\n  name: \"adminCancelReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxPrice\",\n    type: \"uint256\"\n  }],\n  name: \"buy\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxPrice\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  name: \"buyV2\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"cancelBuyPrice\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"cancelReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }],\n  name: \"createReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"finalizeReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getBuyPrice\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"getFeesAndRecipients\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"protocolFee\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"creatorRev\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable[]\",\n    name: \"creatorRecipients\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"creatorShares\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"sellerRev\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"getFethAddress\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"fethAddress\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"getFoundationTreasury\",\n  outputs: [{\n    internalType: \"address payable\",\n    name: \"treasuryAddress\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getImmutableRoyalties\",\n  outputs: [{\n    internalType: \"address payable[]\",\n    name: \"recipients\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"splitPerRecipientInBasisPoints\",\n    type: \"uint256[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"getMinBidAmount\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"minimum\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getMinOfferAmount\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"minimum\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"creator\",\n    type: \"address\"\n  }],\n  name: \"getMutableRoyalties\",\n  outputs: [{\n    internalType: \"address payable[]\",\n    name: \"recipients\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"splitPerRecipientInBasisPoints\",\n    type: \"uint256[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getOffer\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"buyer\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"expiration\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getOfferReferrer\",\n  outputs: [{\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"getReserveAuction\",\n  outputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"nftContract\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"seller\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"duration\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"extensionDuration\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"bidder\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct NFTMarketReserveAuction.ReserveAuction\",\n    name: \"auction\",\n    type: \"tuple\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"getReserveAuctionBidReferrer\",\n  outputs: [{\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getReserveAuctionIdFor\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"getRoyaltyRegistry\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"registry\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getTokenCreator\",\n  outputs: [{\n    internalType: \"address payable\",\n    name: \"creator\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"initialize\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"makeOffer\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"expiration\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  name: \"makeOfferV2\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"expiration\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"placeBid\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  name: \"placeBidV2\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"setBuyPrice\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }],\n  name: \"updateReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar FoundationTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(FoundationTrade, _NFTTrade);\n  function FoundationTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.Foundation, orders) || this;\n  }\n  var _proto = FoundationTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      var calldata = FoundationTrade.INTERFACE.encodeFunctionData('buyV2', [item.tokenAddress, item.tokenId, item.price, item.referrer]);\n      planner.addCommand(CommandType.FOUNDATION, [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var item = _step2.value;\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: exports.TokenType.ERC721\n      });\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var item = _step3.value;\n      total = total.add(item.price);\n    }\n    return total;\n  };\n  return FoundationTrade;\n}(NFTTrade);\nFoundationTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi);\nvar abi$1 = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"_currencyManager\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_executionManager\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_royaltyFeeManager\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_WETH\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_protocolFeeRecipient\",\n    type: \"address\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"newMinNonce\",\n    type: \"uint256\"\n  }],\n  name: \"CancelAllOrders\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256[]\",\n    name: \"orderNonces\",\n    type: \"uint256[]\"\n  }],\n  name: \"CancelMultipleOrders\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"currencyManager\",\n    type: \"address\"\n  }],\n  name: \"NewCurrencyManager\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"executionManager\",\n    type: \"address\"\n  }],\n  name: \"NewExecutionManager\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"protocolFeeRecipient\",\n    type: \"address\"\n  }],\n  name: \"NewProtocolFeeRecipient\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"royaltyFeeManager\",\n    type: \"address\"\n  }],\n  name: \"NewRoyaltyFeeManager\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"transferSelectorNFT\",\n    type: \"address\"\n  }],\n  name: \"NewTransferSelectorNFT\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"collection\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"royaltyRecipient\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"RoyaltyPayment\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"orderNonce\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"taker\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"maker\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"strategy\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"collection\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"TakerAsk\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"orderNonce\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"taker\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"maker\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"strategy\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"collection\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"TakerBid\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"DOMAIN_SEPARATOR\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"WETH\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"minNonce\",\n    type: \"uint256\"\n  }],\n  name: \"cancelAllOrdersForSender\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256[]\",\n    name: \"orderNonces\",\n    type: \"uint256[]\"\n  }],\n  name: \"cancelMultipleMakerOrders\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"currencyManager\",\n  outputs: [{\n    internalType: \"contract ICurrencyManager\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"executionManager\",\n  outputs: [{\n    internalType: \"contract IExecutionManager\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"orderNonce\",\n    type: \"uint256\"\n  }],\n  name: \"isUserOrderNonceExecutedOrCancelled\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"taker\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct OrderTypes.TakerOrder\",\n    name: \"takerBid\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"signer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"collection\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"strategy\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"currency\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct OrderTypes.MakerOrder\",\n    name: \"makerAsk\",\n    type: \"tuple\"\n  }],\n  name: \"matchAskWithTakerBid\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"taker\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct OrderTypes.TakerOrder\",\n    name: \"takerBid\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"signer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"collection\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"strategy\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"currency\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct OrderTypes.MakerOrder\",\n    name: \"makerAsk\",\n    type: \"tuple\"\n  }],\n  name: \"matchAskWithTakerBidUsingETHAndWETH\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"taker\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct OrderTypes.TakerOrder\",\n    name: \"takerAsk\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"signer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"collection\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"strategy\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"currency\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct OrderTypes.MakerOrder\",\n    name: \"makerBid\",\n    type: \"tuple\"\n  }],\n  name: \"matchBidWithTakerAsk\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"protocolFeeRecipient\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"royaltyFeeManager\",\n  outputs: [{\n    internalType: \"contract IRoyaltyFeeManager\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"transferSelectorNFT\",\n  outputs: [{\n    internalType: \"contract ITransferSelectorNFT\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_currencyManager\",\n    type: \"address\"\n  }],\n  name: \"updateCurrencyManager\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_executionManager\",\n    type: \"address\"\n  }],\n  name: \"updateExecutionManager\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_protocolFeeRecipient\",\n    type: \"address\"\n  }],\n  name: \"updateProtocolFeeRecipient\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_royaltyFeeManager\",\n    type: \"address\"\n  }],\n  name: \"updateRoyaltyFeeManager\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_transferSelectorNFT\",\n    type: \"address\"\n  }],\n  name: \"updateTransferSelectorNFT\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"userMinOrderNonce\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nvar LooksRareTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(LooksRareTrade, _NFTTrade);\n  function LooksRareTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.LooksRare, orders) || this;\n  }\n  var _proto = LooksRareTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      var calldata = LooksRareTrade.INTERFACE.encodeFunctionData('matchAskWithTakerBidUsingETHAndWETH', [item.takerOrder, item.makerOrder]);\n      if (item.tokenType == exports.TokenType.ERC721) {\n        !(item.makerOrder.amount == 1) ? invariant(false, 'ERC721 token amount must be 1') : void 0;\n        planner.addCommand(CommandType.LOOKS_RARE_721, [item.makerOrder.price, calldata, item.recipient, item.makerOrder.collection, item.makerOrder.tokenId], config.allowRevert);\n      } else if (item.tokenType == exports.TokenType.ERC1155) {\n        planner.addCommand(CommandType.LOOKS_RARE_1155, [item.makerOrder.price, calldata, item.recipient, item.makerOrder.collection, item.makerOrder.tokenId, item.makerOrder.amount], config.allowRevert);\n      }\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var item = _step2.value;\n      buyItems.push({\n        tokenAddress: item.makerOrder.collection,\n        tokenId: item.makerOrder.tokenId,\n        tokenType: item.tokenType\n      });\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var item = _step3.value;\n      total = total.add(item.makerOrder.price);\n    }\n    return total;\n  };\n  return LooksRareTrade;\n}(NFTTrade);\nLooksRareTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$1);\nvar abi$2 = [{\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"ETH\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"NFT20\",\n  outputs: [{\n    internalType: \"contract INFT20Factory\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"UNIV2\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"UNIV3\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"WETH\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_nft\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_toIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_toAmounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"address\",\n    name: \"_receipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint24\",\n    name: \"_fee\",\n    type: \"uint24\"\n  }, {\n    internalType: \"bool\",\n    name: \"isV3\",\n    type: \"bool\"\n  }],\n  name: \"ethForNft\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_nft\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"bool\",\n    name: \"isErc721\",\n    type: \"bool\"\n  }, {\n    internalType: \"uint24\",\n    name: \"_fee\",\n    type: \"uint24\"\n  }, {\n    internalType: \"bool\",\n    name: \"isV3\",\n    type: \"bool\"\n  }],\n  name: \"nftForEth\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"tokenAddress\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"sendTo\",\n    type: \"address\"\n  }],\n  name: \"recoverERC20\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_registry\",\n    type: \"address\"\n  }],\n  name: \"setNFT20\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"withdrawEth\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar NFT20Trade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(NFT20Trade, _NFTTrade);\n  function NFT20Trade(orders) {\n    return _NFTTrade.call(this, exports.Market.NFT20, orders) || this;\n  }\n  var _proto = NFT20Trade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var order = _step.value;\n      var calldata = NFT20Trade.INTERFACE.encodeFunctionData('ethForNft', [order.tokenAddress, order.tokenIds, order.tokenAmounts, order.recipient, order.fee, order.isV3]);\n      planner.addCommand(CommandType.NFT20, [order.value, calldata], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var pool = _step2.value;\n      for (var _iterator3 = _createForOfIteratorHelperLoose(pool.tokenIds), _step3; !(_step3 = _iterator3()).done;) {\n        var tokenId = _step3.value;\n        buyItems.push({\n          tokenAddress: pool.tokenAddress,\n          tokenId: tokenId,\n          tokenType: exports.TokenType.ERC721\n        });\n      }\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator4 = _createForOfIteratorHelperLoose(this.orders), _step4; !(_step4 = _iterator4()).done;) {\n      var item = _step4.value;\n      total = total.add(item.value);\n    }\n    return total;\n  };\n  return NFT20Trade;\n}(NFTTrade);\nNFT20Trade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$2);\nvar abi$3 = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"_nftxFactory\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_sushiRouter\",\n    type: \"address\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"count\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"ethSpent\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"Buy\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"count\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"ethReceived\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"Sell\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"count\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"ethSpent\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"Swap\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"WETH\",\n  outputs: [{\n    internalType: \"contract IWETH\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndRedeem\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxWethIn\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndRedeemWETH\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"idsIn\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndSwap1155\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"idsIn\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxWethIn\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndSwap1155WETH\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"idsIn\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndSwap721\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"idsIn\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxWethIn\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndSwap721WETH\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"lpStaking\",\n  outputs: [{\n    internalType: \"contract INFTXLPStaking\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minWethOut\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mintAndSell1155\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minWethOut\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mintAndSell1155WETH\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minEthOut\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mintAndSell721\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minWethOut\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mintAndSell721WETH\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"nftxFactory\",\n  outputs: [{\n    internalType: \"contract INFTXVaultFactory\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"bytes\",\n    name: \"\",\n    type: \"bytes\"\n  }],\n  name: \"onERC1155BatchReceived\",\n  outputs: [{\n    internalType: \"bytes4\",\n    name: \"\",\n    type: \"bytes4\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }, {\n    internalType: \"bytes\",\n    name: \"\",\n    type: \"bytes\"\n  }],\n  name: \"onERC1155Received\",\n  outputs: [{\n    internalType: \"bytes4\",\n    name: \"\",\n    type: \"bytes4\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }, {\n    internalType: \"bytes\",\n    name: \"\",\n    type: \"bytes\"\n  }],\n  name: \"onERC721Received\",\n  outputs: [{\n    internalType: \"bytes4\",\n    name: \"\",\n    type: \"bytes4\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }],\n  name: \"rescue\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes4\",\n    name: \"interfaceId\",\n    type: \"bytes4\"\n  }],\n  name: \"supportsInterface\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"sushiRouter\",\n  outputs: [{\n    internalType: \"contract IUniswapV2Router01\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar NFTXTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(NFTXTrade, _NFTTrade);\n  function NFTXTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.NFTX, orders) || this;\n  }\n  var _proto = NFTXTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var order = _step.value;\n      var calldata = NFTXTrade.INTERFACE.encodeFunctionData('buyAndRedeem', [order.vaultId, order.tokenIds.length, order.tokenIds, [sdkCore.Ether.onChain(1).wrapped.address, order.vaultAddress], order.recipient]);\n      planner.addCommand(CommandType.NFTX, [order.value, calldata], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var order = _step2.value;\n      for (var _iterator3 = _createForOfIteratorHelperLoose(order.tokenIds), _step3; !(_step3 = _iterator3()).done;) {\n        var tokenId = _step3.value;\n        buyItems.push({\n          tokenAddress: order.tokenAddress,\n          tokenId: tokenId,\n          tokenType: exports.TokenType.ERC721\n        });\n      }\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator4 = _createForOfIteratorHelperLoose(this.orders), _step4; !(_step4 = _iterator4()).done;) {\n      var item = _step4.value;\n      total = total.add(item.value);\n    }\n    return total;\n  };\n  return NFTXTrade;\n}(NFTTrade);\nNFTXTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$3);\nvar abi$4 = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"conduitController\",\n    type: \"address\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  inputs: [],\n  name: \"BadContractSignature\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"BadFraction\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"BadReturnValueFromERC20OnTransfer\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint8\",\n    name: \"v\",\n    type: \"uint8\"\n  }],\n  name: \"BadSignatureV\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"ConsiderationCriteriaResolverOutOfRange\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"orderIndex\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"considerationIndex\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"shortfallAmount\",\n    type: \"uint256\"\n  }],\n  name: \"ConsiderationNotMet\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"CriteriaNotEnabledForItem\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"identifiers\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }],\n  name: \"ERC1155BatchTransferGenericFailure\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"account\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"EtherTransferGenericFailure\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InexactFraction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InsufficientEtherSupplied\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"Invalid1155BatchTransferEncoding\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidBasicOrderParameterEncoding\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"conduit\",\n    type: \"address\"\n  }],\n  name: \"InvalidCallToConduit\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidCanceller\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"conduitKey\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"address\",\n    name: \"conduit\",\n    type: \"address\"\n  }],\n  name: \"InvalidConduit\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidERC721TransferAmount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidFulfillmentComponentData\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"InvalidMsgValue\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidNativeOfferItem\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidProof\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"InvalidRestrictedOrder\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidSignature\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidSigner\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidTime\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"MismatchedFulfillmentOfferAndConsiderationComponents\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"enum Side\",\n    name: \"side\",\n    type: \"uint8\"\n  }],\n  name: \"MissingFulfillmentComponentOnAggregation\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"MissingItemAmount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"MissingOriginalConsiderationItems\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"account\",\n    type: \"address\"\n  }],\n  name: \"NoContract\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NoReentrantCalls\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NoSpecifiedOrdersAvailable\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"OfferAndConsiderationRequiredOnFulfillment\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"OfferCriteriaResolverOutOfRange\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"OrderAlreadyFilled\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"OrderCriteriaResolverOutOfRange\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"OrderIsCancelled\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"OrderPartiallyFilled\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"PartialFillsNotEnabledForOrder\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"identifier\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"TokenTransferGenericFailure\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"UnresolvedConsiderationCriteria\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"UnresolvedOfferCriteria\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"UnusedItemParameters\",\n  type: \"error\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"newCounter\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }],\n  name: \"CounterIncremented\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"zone\",\n    type: \"address\"\n  }],\n  name: \"OrderCancelled\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"zone\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    components: [{\n      internalType: \"enum ItemType\",\n      name: \"itemType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"address\",\n      name: \"token\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }],\n    indexed: false,\n    internalType: \"struct SpentItem[]\",\n    name: \"offer\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"enum ItemType\",\n      name: \"itemType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"address\",\n      name: \"token\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"recipient\",\n      type: \"address\"\n    }],\n    indexed: false,\n    internalType: \"struct ReceivedItem[]\",\n    name: \"consideration\",\n    type: \"tuple[]\"\n  }],\n  name: \"OrderFulfilled\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"zone\",\n    type: \"address\"\n  }],\n  name: \"OrderValidated\",\n  type: \"event\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"zone\",\n      type: \"address\"\n    }, {\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifierOrCriteria\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endAmount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OfferItem[]\",\n      name: \"offer\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifierOrCriteria\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ConsiderationItem[]\",\n      name: \"consideration\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"enum OrderType\",\n      name: \"orderType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"zoneHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"counter\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct OrderComponents[]\",\n    name: \"orders\",\n    type: \"tuple[]\"\n  }],\n  name: \"cancel\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"cancelled\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint120\",\n      name: \"numerator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"uint120\",\n      name: \"denominator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }, {\n      internalType: \"bytes\",\n      name: \"extraData\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct AdvancedOrder\",\n    name: \"advancedOrder\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"enum Side\",\n      name: \"side\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"index\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32[]\",\n      name: \"criteriaProof\",\n      type: \"bytes32[]\"\n    }],\n    internalType: \"struct CriteriaResolver[]\",\n    name: \"criteriaResolvers\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"fulfillerConduitKey\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"address\",\n    name: \"recipient\",\n    type: \"address\"\n  }],\n  name: \"fulfillAdvancedOrder\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"fulfilled\",\n    type: \"bool\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint120\",\n      name: \"numerator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"uint120\",\n      name: \"denominator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }, {\n      internalType: \"bytes\",\n      name: \"extraData\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct AdvancedOrder[]\",\n    name: \"advancedOrders\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"enum Side\",\n      name: \"side\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"index\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32[]\",\n      name: \"criteriaProof\",\n      type: \"bytes32[]\"\n    }],\n    internalType: \"struct CriteriaResolver[]\",\n    name: \"criteriaResolvers\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIndex\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct FulfillmentComponent[][]\",\n    name: \"offerFulfillments\",\n    type: \"tuple[][]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIndex\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct FulfillmentComponent[][]\",\n    name: \"considerationFulfillments\",\n    type: \"tuple[][]\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"fulfillerConduitKey\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"address\",\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maximumFulfilled\",\n    type: \"uint256\"\n  }],\n  name: \"fulfillAvailableAdvancedOrders\",\n  outputs: [{\n    internalType: \"bool[]\",\n    name: \"availableOrders\",\n    type: \"bool[]\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifier\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ReceivedItem\",\n      name: \"item\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct Execution[]\",\n    name: \"executions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct Order[]\",\n    name: \"orders\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIndex\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct FulfillmentComponent[][]\",\n    name: \"offerFulfillments\",\n    type: \"tuple[][]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIndex\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct FulfillmentComponent[][]\",\n    name: \"considerationFulfillments\",\n    type: \"tuple[][]\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"fulfillerConduitKey\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maximumFulfilled\",\n    type: \"uint256\"\n  }],\n  name: \"fulfillAvailableOrders\",\n  outputs: [{\n    internalType: \"bool[]\",\n    name: \"availableOrders\",\n    type: \"bool[]\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifier\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ReceivedItem\",\n      name: \"item\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct Execution[]\",\n    name: \"executions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"considerationToken\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"considerationIdentifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"considerationAmount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"zone\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"offerToken\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"offerIdentifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"offerAmount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"enum BasicOrderType\",\n      name: \"basicOrderType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"zoneHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"offererConduitKey\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"fulfillerConduitKey\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"totalOriginalAdditionalRecipients\",\n      type: \"uint256\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct AdditionalRecipient[]\",\n      name: \"additionalRecipients\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct BasicOrderParameters\",\n    name: \"parameters\",\n    type: \"tuple\"\n  }],\n  name: \"fulfillBasicOrder\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"fulfilled\",\n    type: \"bool\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct Order\",\n    name: \"order\",\n    type: \"tuple\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"fulfillerConduitKey\",\n    type: \"bytes32\"\n  }],\n  name: \"fulfillOrder\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"fulfilled\",\n    type: \"bool\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }],\n  name: \"getCounter\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"counter\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"zone\",\n      type: \"address\"\n    }, {\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifierOrCriteria\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endAmount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OfferItem[]\",\n      name: \"offer\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifierOrCriteria\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ConsiderationItem[]\",\n      name: \"consideration\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"enum OrderType\",\n      name: \"orderType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"zoneHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"counter\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct OrderComponents\",\n    name: \"order\",\n    type: \"tuple\"\n  }],\n  name: \"getOrderHash\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"getOrderStatus\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"isValidated\",\n    type: \"bool\"\n  }, {\n    internalType: \"bool\",\n    name: \"isCancelled\",\n    type: \"bool\"\n  }, {\n    internalType: \"uint256\",\n    name: \"totalFilled\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"totalSize\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"incrementCounter\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"newCounter\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"information\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"version\",\n    type: \"string\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"domainSeparator\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"address\",\n    name: \"conduitController\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint120\",\n      name: \"numerator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"uint120\",\n      name: \"denominator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }, {\n      internalType: \"bytes\",\n      name: \"extraData\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct AdvancedOrder[]\",\n    name: \"advancedOrders\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"enum Side\",\n      name: \"side\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"index\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32[]\",\n      name: \"criteriaProof\",\n      type: \"bytes32[]\"\n    }],\n    internalType: \"struct CriteriaResolver[]\",\n    name: \"criteriaResolvers\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"uint256\",\n        name: \"orderIndex\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIndex\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct FulfillmentComponent[]\",\n      name: \"offerComponents\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"orderIndex\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIndex\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct FulfillmentComponent[]\",\n      name: \"considerationComponents\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct Fulfillment[]\",\n    name: \"fulfillments\",\n    type: \"tuple[]\"\n  }],\n  name: \"matchAdvancedOrders\",\n  outputs: [{\n    components: [{\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifier\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ReceivedItem\",\n      name: \"item\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct Execution[]\",\n    name: \"executions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct Order[]\",\n    name: \"orders\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"uint256\",\n        name: \"orderIndex\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIndex\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct FulfillmentComponent[]\",\n      name: \"offerComponents\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"orderIndex\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIndex\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct FulfillmentComponent[]\",\n      name: \"considerationComponents\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct Fulfillment[]\",\n    name: \"fulfillments\",\n    type: \"tuple[]\"\n  }],\n  name: \"matchOrders\",\n  outputs: [{\n    components: [{\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifier\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ReceivedItem\",\n      name: \"item\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct Execution[]\",\n    name: \"executions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"name\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"contractName\",\n    type: \"string\"\n  }],\n  stateMutability: \"pure\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct Order[]\",\n    name: \"orders\",\n    type: \"tuple[]\"\n  }],\n  name: \"validate\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"validated\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}];\nvar SeaportTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(SeaportTrade, _NFTTrade);\n  function SeaportTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.Seaport, orders) || this;\n  }\n  var _proto = SeaportTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var order = _step.value;\n      var advancedOrders = [];\n      var orderFulfillments = order.items.map(function (_, index) {\n        return [{\n          orderIndex: index,\n          itemIndex: 0\n        }];\n      });\n      var considerationFulFillments = this.getConsiderationFulfillments(order.items);\n      for (var _iterator2 = _createForOfIteratorHelperLoose(order.items), _step2; !(_step2 = _iterator2()).done;) {\n        var item = _step2.value;\n        var _this$getAdvancedOrde = this.getAdvancedOrderParams(item),\n          advancedOrder = _this$getAdvancedOrde.advancedOrder;\n        advancedOrders.push(advancedOrder);\n      }\n      var calldata = void 0;\n      if (advancedOrders.length == 1) {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAdvancedOrder', [advancedOrders[0], [], SeaportTrade.OPENSEA_CONDUIT_KEY, order.recipient]);\n      } else {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAvailableAdvancedOrders', [advancedOrders, [], orderFulfillments, considerationFulFillments, SeaportTrade.OPENSEA_CONDUIT_KEY, order.recipient, 100]);\n      }\n      planner.addCommand(CommandType.SEAPORT, [this.getTotalPrice().toString(), calldata], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var order = _step3.value;\n      for (var _iterator4 = _createForOfIteratorHelperLoose(order.items), _step4; !(_step4 = _iterator4()).done;) {\n        var item = _step4.value;\n        for (var _iterator5 = _createForOfIteratorHelperLoose(item.parameters.offer), _step5; !(_step5 = _iterator5()).done;) {\n          var offer = _step5.value;\n          buyItems.push({\n            tokenAddress: offer.token,\n            tokenId: offer.identifierOrCriteria,\n            tokenType: exports.TokenType.ERC721\n          });\n        }\n      }\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var totalPrice = ethers.BigNumber.from(0);\n    for (var _iterator6 = _createForOfIteratorHelperLoose(this.orders), _step6; !(_step6 = _iterator6()).done;) {\n      var order = _step6.value;\n      for (var _iterator7 = _createForOfIteratorHelperLoose(order.items), _step7; !(_step7 = _iterator7()).done;) {\n        var item = _step7.value;\n        totalPrice = totalPrice.add(this.calculateValue(item.parameters.consideration));\n      }\n    }\n    return totalPrice;\n  };\n  _proto.getConsiderationFulfillments = function getConsiderationFulfillments(protocolDatas) {\n    var considerationFulfillments = [];\n    var considerationRecipients = [];\n    for (var i in protocolDatas) {\n      var protocolData = protocolDatas[i];\n      var _loop = function _loop(j) {\n        var item = protocolData.parameters.consideration[j];\n        if (considerationRecipients.findIndex(function (x) {\n          return x === item.recipient;\n        }) === -1) {\n          considerationRecipients.push(item.recipient);\n        }\n        var recipientIndex = considerationRecipients.findIndex(function (x) {\n          return x === item.recipient;\n        });\n        if (!considerationFulfillments[recipientIndex]) {\n          considerationFulfillments.push([{\n            orderIndex: i,\n            itemIndex: j\n          }]);\n        } else {\n          considerationFulfillments[recipientIndex].push({\n            orderIndex: i,\n            itemIndex: j\n          });\n        }\n      };\n      for (var j in protocolData.parameters.consideration) {\n        _loop(j);\n      }\n    }\n    return considerationFulfillments;\n  };\n  _proto.getAdvancedOrderParams = function getAdvancedOrderParams(data) {\n    var advancedOrder = {\n      parameters: data.parameters,\n      numerator: ethers.BigNumber.from('1'),\n      denominator: ethers.BigNumber.from('1'),\n      signature: data.signature,\n      extraData: '0x00'\n    };\n    var value = this.calculateValue(data.parameters.consideration);\n    return {\n      advancedOrder: advancedOrder,\n      value: value\n    };\n  };\n  _proto.calculateValue = function calculateValue(considerations) {\n    return considerations.reduce(function (amt, consideration) {\n      return amt.add(consideration.startAmount);\n    }, ethers.BigNumber.from(0));\n  };\n  return SeaportTrade;\n}(NFTTrade);\nSeaportTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$4);\nSeaportTrade.OPENSEA_CONDUIT_KEY = '0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000';\nvar abi$5 = [{\n  inputs: [{\n    internalType: \"contract ILSSVMPairFactoryLike\",\n    name: \"_factory\",\n    type: \"address\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  inputs: [],\n  name: \"factory\",\n  outputs: [{\n    internalType: \"contract ILSSVMPairFactoryLike\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"contract ERC20\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"enum ILSSVMPairFactoryLike.PairVariant\",\n    name: \"variant\",\n    type: \"uint8\"\n  }],\n  name: \"pairTransferERC20From\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"contract IERC721\",\n    name: \"nft\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"id\",\n    type: \"uint256\"\n  }, {\n    internalType: \"enum ILSSVMPairFactoryLike.PairVariant\",\n    name: \"variant\",\n    type: \"uint8\"\n  }],\n  name: \"pairTransferNFTFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"numItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapAny\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"maxCost\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapAny[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapERC20ForAnyNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"maxCost\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapERC20ForSpecificNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        components: [{\n          internalType: \"contract LSSVMPair\",\n          name: \"pair\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256[]\",\n          name: \"nftIds\",\n          type: \"uint256[]\"\n        }],\n        internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n        name: \"swapInfo\",\n        type: \"tuple\"\n      }, {\n        internalType: \"uint256\",\n        name: \"maxCost\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.RobustPairSwapSpecific[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        components: [{\n          internalType: \"contract LSSVMPair\",\n          name: \"pair\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256[]\",\n          name: \"nftIds\",\n          type: \"uint256[]\"\n        }],\n        internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n        name: \"swapInfo\",\n        type: \"tuple\"\n      }, {\n        internalType: \"uint256\",\n        name: \"minOutput\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.RobustPairSwapSpecificForToken[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"uint256\",\n      name: \"inputAmount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"tokenRecipient\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"nftRecipient\",\n      type: \"address\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairNFTsFoTokenAndTokenforNFTsTrade\",\n    name: \"params\",\n    type: \"tuple\"\n  }],\n  name: \"robustSwapERC20ForSpecificNFTsAndNFTsToToken\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"numItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapAny\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"maxCost\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapAny[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapETHForAnyNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"maxCost\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapETHForSpecificNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        components: [{\n          internalType: \"contract LSSVMPair\",\n          name: \"pair\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256[]\",\n          name: \"nftIds\",\n          type: \"uint256[]\"\n        }],\n        internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n        name: \"swapInfo\",\n        type: \"tuple\"\n      }, {\n        internalType: \"uint256\",\n        name: \"maxCost\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.RobustPairSwapSpecific[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        components: [{\n          internalType: \"contract LSSVMPair\",\n          name: \"pair\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256[]\",\n          name: \"nftIds\",\n          type: \"uint256[]\"\n        }],\n        internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n        name: \"swapInfo\",\n        type: \"tuple\"\n      }, {\n        internalType: \"uint256\",\n        name: \"minOutput\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.RobustPairSwapSpecificForToken[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"uint256\",\n      name: \"inputAmount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"tokenRecipient\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"nftRecipient\",\n      type: \"address\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairNFTsFoTokenAndTokenforNFTsTrade\",\n    name: \"params\",\n    type: \"tuple\"\n  }],\n  name: \"robustSwapETHForSpecificNFTsAndNFTsToToken\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minOutput\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapSpecificForToken[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"tokenRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapNFTsForToken\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"numItems\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapAny[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapERC20ForAnyNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256[]\",\n      name: \"nftIds\",\n      type: \"uint256[]\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapERC20ForSpecificNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"numItems\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapAny[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapETHForAnyNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256[]\",\n      name: \"nftIds\",\n      type: \"uint256[]\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapETHForSpecificNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"numItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapAny[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct LSSVMRouter.NFTsForAnyNFTsTrade\",\n    name: \"trade\",\n    type: \"tuple\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForAnyNFTsThroughERC20\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"numItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapAny[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct LSSVMRouter.NFTsForAnyNFTsTrade\",\n    name: \"trade\",\n    type: \"tuple\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForAnyNFTsThroughETH\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct LSSVMRouter.NFTsForSpecificNFTsTrade\",\n    name: \"trade\",\n    type: \"tuple\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForSpecificNFTsThroughERC20\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct LSSVMRouter.NFTsForSpecificNFTsTrade\",\n    name: \"trade\",\n    type: \"tuple\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForSpecificNFTsThroughETH\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256[]\",\n      name: \"nftIds\",\n      type: \"uint256[]\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"tokenRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForToken\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar SudoswapTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(SudoswapTrade, _NFTTrade);\n  function SudoswapTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.Sudoswap, orders) || this;\n  }\n  var _proto = SudoswapTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var order = _step.value;\n      var calldata = SudoswapTrade.INTERFACE.encodeFunctionData('robustSwapETHForSpecificNFTs', [order.swaps.map(function (swap) {\n        return {\n          swapInfo: swap.swapInfo,\n          maxCost: swap.maxCost\n        };\n      }), order.ethRecipient, order.nftRecipient, order.deadline]);\n      var value = order.swaps.reduce(function (prevVal, swap) {\n        return prevVal.add(swap.maxCost);\n      }, ethers.BigNumber.from(0));\n      planner.addCommand(CommandType.SUDOSWAP, [value, calldata], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var order = _step2.value;\n      for (var _iterator3 = _createForOfIteratorHelperLoose(order.swaps), _step3; !(_step3 = _iterator3()).done;) {\n        var swap = _step3.value;\n        for (var _iterator4 = _createForOfIteratorHelperLoose(swap.swapInfo.nftIds), _step4; !(_step4 = _iterator4()).done;) {\n          var tokenId = _step4.value;\n          buyItems.push({\n            tokenAddress: swap.tokenAddress,\n            tokenId: tokenId,\n            tokenType: exports.TokenType.ERC721\n          });\n        }\n      }\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator5 = _createForOfIteratorHelperLoose(this.orders), _step5; !(_step5 = _iterator5()).done;) {\n      var order = _step5.value;\n      for (var _iterator6 = _createForOfIteratorHelperLoose(order.swaps), _step6; !(_step6 = _iterator6()).done;) {\n        var swap = _step6.value;\n        total = total.add(swap.maxCost);\n      }\n    }\n    return total;\n  };\n  return SudoswapTrade;\n}(NFTTrade);\nSudoswapTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$5);\nvar abi$6 = [{\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"bytes32\",\n    name: \"itemHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"incentive\",\n    type: \"uint256\"\n  }],\n  name: \"EvAuctionRefund\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"bytes32\",\n    name: \"itemHash\",\n    type: \"bytes32\"\n  }],\n  name: \"EvCancel\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"delegate\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"bool\",\n    name: \"isRemoval\",\n    type: \"bool\"\n  }],\n  name: \"EvDelegate\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"index\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"bytes\",\n    name: \"error\",\n    type: \"bytes\"\n  }],\n  name: \"EvFailure\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"newValue\",\n    type: \"uint256\"\n  }],\n  name: \"EvFeeCapUpdate\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"bytes32\",\n    name: \"itemHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"maker\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"taker\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"orderSalt\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"settleSalt\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"intent\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"delegateType\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"contract IERC20Upgradeable\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"bytes\",\n    name: \"dataMask\",\n    type: \"bytes\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"data\",\n      type: \"bytes\"\n    }],\n    indexed: false,\n    internalType: \"struct Market.OrderItem\",\n    name: \"item\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"enum Market.Op\",\n      name: \"op\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"orderIdx\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIdx\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"itemHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"contract IDelegate\",\n      name: \"executionDelegate\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes\",\n      name: \"dataReplacement\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint256\",\n      name: \"bidIncentivePct\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"aucMinIncrementPct\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"aucIncDurationSecs\",\n      type: \"uint256\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"percentage\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      }],\n      internalType: \"struct Market.Fee[]\",\n      name: \"fees\",\n      type: \"tuple[]\"\n    }],\n    indexed: false,\n    internalType: \"struct Market.SettleDetail\",\n    name: \"detail\",\n    type: \"tuple\"\n  }],\n  name: \"EvInventory\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"itemHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"EvProfit\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"signer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"bool\",\n    name: \"isRemoval\",\n    type: \"bool\"\n  }],\n  name: \"EvSigner\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"account\",\n    type: \"address\"\n  }],\n  name: \"Paused\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"account\",\n    type: \"address\"\n  }],\n  name: \"Unpaused\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"RATE_BASE\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes32[]\",\n    name: \"itemHashes\",\n    type: \"bytes32[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint8\",\n    name: \"v\",\n    type: \"uint8\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"r\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"s\",\n    type: \"bytes32\"\n  }],\n  name: \"cancel\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"delegates\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"feeCapPct\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"feeCapPct_\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"weth_\",\n    type: \"address\"\n  }],\n  name: \"initialize\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  name: \"inventoryStatus\",\n  outputs: [{\n    internalType: \"enum Market.InvStatus\",\n    name: \"\",\n    type: \"uint8\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  name: \"ongoingAuctions\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"netPrice\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"endAt\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"bidder\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"pause\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"paused\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address\",\n        name: \"user\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"network\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"intent\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"delegateType\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"deadline\",\n        type: \"uint256\"\n      }, {\n        internalType: \"contract IERC20Upgradeable\",\n        name: \"currency\",\n        type: \"address\"\n      }, {\n        internalType: \"bytes\",\n        name: \"dataMask\",\n        type: \"bytes\"\n      }, {\n        components: [{\n          internalType: \"uint256\",\n          name: \"price\",\n          type: \"uint256\"\n        }, {\n          internalType: \"bytes\",\n          name: \"data\",\n          type: \"bytes\"\n        }],\n        internalType: \"struct Market.OrderItem[]\",\n        name: \"items\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"r\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"s\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint8\",\n        name: \"v\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint8\",\n        name: \"signVersion\",\n        type: \"uint8\"\n      }],\n      internalType: \"struct Market.Order[]\",\n      name: \"orders\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"enum Market.Op\",\n        name: \"op\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"orderIdx\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIdx\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"price\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"itemHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"contract IDelegate\",\n        name: \"executionDelegate\",\n        type: \"address\"\n      }, {\n        internalType: \"bytes\",\n        name: \"dataReplacement\",\n        type: \"bytes\"\n      }, {\n        internalType: \"uint256\",\n        name: \"bidIncentivePct\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"aucMinIncrementPct\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"aucIncDurationSecs\",\n        type: \"uint256\"\n      }, {\n        components: [{\n          internalType: \"uint256\",\n          name: \"percentage\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address\",\n          name: \"to\",\n          type: \"address\"\n        }],\n        internalType: \"struct Market.Fee[]\",\n        name: \"fees\",\n        type: \"tuple[]\"\n      }],\n      internalType: \"struct Market.SettleDetail[]\",\n      name: \"details\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"deadline\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amountToEth\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amountToWeth\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address\",\n        name: \"user\",\n        type: \"address\"\n      }, {\n        internalType: \"bool\",\n        name: \"canFail\",\n        type: \"bool\"\n      }],\n      internalType: \"struct Market.SettleShared\",\n      name: \"shared\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }],\n    internalType: \"struct Market.RunInput\",\n    name: \"input\",\n    type: \"tuple\"\n  }],\n  name: \"run\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"user\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"network\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"intent\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"delegateType\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }, {\n      internalType: \"contract IERC20Upgradeable\",\n      name: \"currency\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes\",\n      name: \"dataMask\",\n      type: \"bytes\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"price\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\"\n      }],\n      internalType: \"struct Market.OrderItem[]\",\n      name: \"items\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint8\",\n      name: \"signVersion\",\n      type: \"uint8\"\n    }],\n    internalType: \"struct Market.Order\",\n    name: \"order\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amountToEth\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amountToWeth\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"user\",\n      type: \"address\"\n    }, {\n      internalType: \"bool\",\n      name: \"canFail\",\n      type: \"bool\"\n    }],\n    internalType: \"struct Market.SettleShared\",\n    name: \"shared\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"enum Market.Op\",\n      name: \"op\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"orderIdx\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIdx\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"itemHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"contract IDelegate\",\n      name: \"executionDelegate\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes\",\n      name: \"dataReplacement\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint256\",\n      name: \"bidIncentivePct\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"aucMinIncrementPct\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"aucIncDurationSecs\",\n      type: \"uint256\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"percentage\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      }],\n      internalType: \"struct Market.Fee[]\",\n      name: \"fees\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct Market.SettleDetail\",\n    name: \"detail\",\n    type: \"tuple\"\n  }],\n  name: \"run1\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"signers\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"unpause\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address[]\",\n    name: \"toAdd\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"toRemove\",\n    type: \"address[]\"\n  }],\n  name: \"updateDelegates\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"val\",\n    type: \"uint256\"\n  }],\n  name: \"updateFeeCap\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address[]\",\n    name: \"toAdd\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"toRemove\",\n    type: \"address[]\"\n  }],\n  name: \"updateSigners\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"weth\",\n  outputs: [{\n    internalType: \"contract IWETHUpgradable\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar X2Y2Trade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(X2Y2Trade, _NFTTrade);\n  function X2Y2Trade(orders) {\n    return _NFTTrade.call(this, exports.Market.X2Y2, orders) || this;\n  }\n  var _proto = X2Y2Trade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      var functionSelector = X2Y2Trade.INTERFACE.getSighash(X2Y2Trade.INTERFACE.getFunction('run'));\n      var calldata = functionSelector + item.signedInput.slice(2);\n      if (item.tokenType == exports.TokenType.ERC721) {\n        planner.addCommand(CommandType.X2Y2_721, [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId], config.allowRevert);\n      } else if (item.tokenType == exports.TokenType.ERC1155) {\n        planner.addCommand(CommandType.X2Y2_1155, [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId, item.tokenAmount], config.allowRevert);\n      }\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var item = _step2.value;\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: item.tokenType\n      });\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var item = _step3.value;\n      total = total.add(item.price);\n    }\n    return total;\n  };\n  return X2Y2Trade;\n}(NFTTrade);\nX2Y2Trade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$6);\nvar UnwrapWETH = /*#__PURE__*/function () {\n  function UnwrapWETH(amount, chainId, permit2) {\n    this.tradeType = exports.RouterTradeType.UnwrapWETH;\n    this.wethAddress = WETH_ADDRESS(chainId);\n    this.routerAddress = UNIVERSAL_ROUTER_ADDRESS(chainId);\n    this.amount = amount;\n    if (!!permit2) {\n      !(permit2.details.token === this.wethAddress) ? invariant(false, \"must be permitting WETH address: \" + this.wethAddress) : void 0;\n      !(permit2.details.amount >= amount) ? invariant(false, \"Did not permit enough WETH for unwrapWETH transaction\") : void 0;\n      this.permit2Data = permit2;\n    }\n  }\n  var _proto = UnwrapWETH.prototype;\n  _proto.encode = function encode(planner, _) {\n    if (!!this.permit2Data) encodePermit(planner, this.permit2Data);\n    planner.addCommand(CommandType.PERMIT2_TRANSFER_FROM, [this.wethAddress, this.routerAddress, this.amount]);\n    planner.addCommand(CommandType.UNWRAP_WETH, [ROUTER_AS_RECIPIENT, this.amount]);\n  };\n  return UnwrapWETH;\n}();\nexports.CryptopunkTrade = CryptopunkTrade;\nexports.FoundationTrade = FoundationTrade;\nexports.LooksRareTrade = LooksRareTrade;\nexports.NFT20Trade = NFT20Trade;\nexports.NFTTrade = NFTTrade;\nexports.NFTXTrade = NFTXTrade;\nexports.PERMIT2_ADDRESS = PERMIT2_ADDRESS;\nexports.ROUTER_AS_RECIPIENT = ROUTER_AS_RECIPIENT;\nexports.SeaportTrade = SeaportTrade;\nexports.SudoswapTrade = SudoswapTrade;\nexports.SwapRouter = SwapRouter;\nexports.UNIVERSAL_ROUTER_ADDRESS = UNIVERSAL_ROUTER_ADDRESS;\nexports.UniswapTrade = UniswapTrade;\nexports.UnwrapWETH = UnwrapWETH;\nexports.WETH_ADDRESS = WETH_ADDRESS;\nexports.X2Y2Trade = X2Y2Trade;","map":{"version":3,"sources":["../src/entities/Command.ts","../src/utils/routerCommands.ts","../src/utils/constants.ts","../src/entities/protocols/uniswap.ts","../src/utils/permit2.ts","../src/swapRouter.ts","../src/entities/NFTTrade.ts","../src/entities/protocols/cryptopunk.ts","../src/entities/protocols/foundation.ts","../src/entities/protocols/looksRare.ts","../src/entities/protocols/nft20.ts","../src/entities/protocols/nftx.ts","../src/entities/protocols/seaport.ts","../src/entities/protocols/sudoswap.ts","../src/entities/protocols/x2y2.ts","../src/entities/protocols/unwrapWETH.ts"],"names":["RouterTradeType","CommandType","PERMIT_STRUCT","PERMIT_BATCH_STRUCT","ALLOW_REVERT_FLAG","REVERTABLE_COMMANDS","Set","SEAPORT","NFTX","LOOKS_RARE_721","LOOKS_RARE_1155","X2Y2_721","X2Y2_1155","FOUNDATION","SUDOSWAP","NFT20","CRYPTOPUNKS","ABI_DEFINITION","PERMIT","PERMIT2_PERMIT_BATCH","PERMIT2_TRANSFER_FROM","PERMIT2_TRANSFER_FROM_BATCH","TRANSFER","V3_SWAP_EXACT_IN","V3_SWAP_EXACT_OUT","V2_SWAP_EXACT_IN","V2_SWAP_EXACT_OUT","WRAP_ETH","UNWRAP_WETH","SWEEP","PAY_PORTION","OWNER_CHECK_721","OWNER_CHECK_1155","RoutePlanner","commands","inputs","addCommand","type","parameters","allowRevert","command","createCommand","push","encodedInput","has","Error","concat","toString","padStart","defaultAbiCoder","encode","UNIVERSAL_ROUTER_ADDRESS","chainId","WETH_ADDRESS","PERMIT2_ADDRESS","CONTRACT_BALANCE","ETH_ADDRESS","REFUND_ETH_PRICE_IMPACT_THRESHOLD","Percent","UniswapTrade","payerIsUser","planner","ROUTER_AS_RECIPIENT","performAggregatedSlippageCheck","tradeType","TradeType","EXACT_INPUT","routes","swap","route","protocol","Protocol","addV2Swap","options","addV3Swap","MIXED","addMixedSwap","routerMustCustody","inputIsNative","EXACT_OUTPUT","riskOfPartialFill","trade","inputAmount","outputAmount","pool","address","path","encodeRouteToPath","pools","length","Pool","Pair","MixedRouteTrade","createUncheckedTrade","amountIn","minimumAmountOut","isLastSectionInRoute","sections","inputToken","input","section","outputToken","newRouteOriginal","MixedRouteSDK","newRoute","MixedRoute","mixedRouteIsAllV3","every","encodeMixedRouteToPath","tradeRecipient","EIP_2098_SIGNATURE_LENGTH","encodePermit","SIGNATURE_LENGTH","signature","ethers","utils","SwapRouter","Interface","swapCallParameters","config","Array","isArray","trades","nftTrades","filter","hasOwnProperty","currentNativeValueInRouter","BigNumber","NFTTrade","nftTrade","tradePrice","getTotalPrice","transactionValue","swapOptions","inputTokenPermit","uniswapTrade","maximumAmountIn","UnwrapWETH","totalPrice","inputCurrency","nativeCurrencyValue","isNative","deadline","deadlineOrPreviousBlockhash","from","undefined","functionSignature","calldata","value","toHexString","market","Market","TokenType","CryptopunkTrade","orders","Cryptopunks","item","getBuyItems","buyItems","tokenAddress","CRYPTOPUNK_ADDRESS","tokenId","tokenType","Cryptopunk","total","FoundationTrade","ERC721","LooksRareTrade","makerOrder","amount","price","recipient","collection","NFT20Trade","order","NFTXTrade","SeaportTrade","orderFulfillments","items","orderIndex","index","itemIndex","considerationFulFillments","advancedOrder","advancedOrders","encodeFunctionData","offer","identifierOrCriteria","calculateValue","getConsiderationFulfillments","protocolDatas","j","protocolData","considerationRecipients","findIndex","recipientIndex","x","considerationFulfillments","i","getAdvancedOrderParams","numerator","denominator","extraData","data","considerations","amt","SudoswapTrade","swapInfo","maxCost","ethRecipient","nftRecipient","prevVal","add","X2Y2Trade","functionSelector","wethAddress","permit2","details","token","permit2Data"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,CAAA,UAAYA,eAAe,EAAA;EACzBA,eAAAA,CAAAA,cAAAA,CAAAA,GAAAA,cAA6B;EAC7BA,eAAAA,CAAAA,UAAAA,CAAAA,GAAAA,UAAqB;EACrBA,eAAAA,CAAAA,YAAAA,CAAAA,GAAAA,YAAyB;AAC3B,CAAC,EAJWA,OAAAA,CAAAA,eAAe,KAAfA,OAAAA,CAAAA,eAAe,GAAA,CAAA,CAAA,CAAA,CAAA;;ACJ3B;;;;;AAKA,IAAYC,WA8BX;AA9BD,CAAA,UAAYA,WAAW,EAAA;EACrBA,WAAAA,CAAAA,WAAAA,CAAAA,kBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,kBAAuB;EACvBA,WAAAA,CAAAA,WAAAA,CAAAA,mBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,mBAAwB;EACxBA,WAAAA,CAAAA,WAAAA,CAAAA,uBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,uBAA4B;EAC5BA,WAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,sBAA2B;EAC3BA,WAAAA,CAAAA,WAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,OAAY;EACZA,WAAAA,CAAAA,WAAAA,CAAAA,UAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,UAAe;EACfA,WAAAA,CAAAA,WAAAA,CAAAA,aAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,aAAkB;EAElBA,WAAAA,CAAAA,WAAAA,CAAAA,kBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,kBAAuB;EACvBA,WAAAA,CAAAA,WAAAA,CAAAA,mBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,mBAAwB;EACxBA,WAAAA,CAAAA,WAAAA,CAAAA,QAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,QAAa;EACbA,WAAAA,CAAAA,WAAAA,CAAAA,UAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,UAAe;EACfA,WAAAA,CAAAA,WAAAA,CAAAA,aAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,aAAkB;EAClBA,WAAAA,CAAAA,WAAAA,CAAAA,6BAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,6BAAkC;;EAGlCA,WAAAA,CAAAA,WAAAA,CAAAA,SAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,SAAc;EACdA,WAAAA,CAAAA,WAAAA,CAAAA,gBAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,gBAAqB;EACrBA,WAAAA,CAAAA,WAAAA,CAAAA,MAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,MAAW;EACXA,WAAAA,CAAAA,WAAAA,CAAAA,aAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,aAAkB;EAClBA,WAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,iBAAsB;EACtBA,WAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,iBAAsB;EACtBA,WAAAA,CAAAA,WAAAA,CAAAA,kBAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,kBAAuB;EAEvBA,WAAAA,CAAAA,WAAAA,CAAAA,UAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,UAAe;EACfA,WAAAA,CAAAA,WAAAA,CAAAA,UAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,UAAe;EACfA,WAAAA,CAAAA,WAAAA,CAAAA,OAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,OAAY;EACZA,WAAAA,CAAAA,WAAAA,CAAAA,WAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,WAAgB;EAChBA,WAAAA,CAAAA,WAAAA,CAAAA,YAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,YAAiB;AACnB,CAAC,EA9BWA,WAAW,KAAXA,WAAW,GAAA,CAAA,CAAA,CAAA,CAAA;AAgCvB,IAAMC,aAAa,GACjB,+GAA+G;AAEjH,IAAMC,mBAAmB,GACvB,iHAAiH;AAEnH,IAAMC,iBAAiB,GAAG,IAAI;AAE9B,IAAMC,mBAAmB,GAAA,aAAG,IAAIC,GAAG,CAAc,CAC/CL,WAAW,CAACM,OAAO,EACnBN,WAAW,CAACO,IAAI,EAChBP,WAAW,CAACQ,cAAc,EAC1BR,WAAW,CAACS,eAAe,EAC3BT,WAAW,CAACU,QAAQ,EACpBV,WAAW,CAACW,SAAS,EACrBX,WAAW,CAACY,UAAU,EACtBZ,WAAW,CAACa,QAAQ,EACpBb,WAAW,CAACc,KAAK,EACjBd,WAAW,CAACe,WAAW,CACxB,CAAC;AAEF,IAAMC,cAAc,IAAA,eAAA,GAAA,CAAA,CAAA,EAAA,eAAA,CACjBhB,WAAW,CAACiB,MAAM,CAAA,GAAG,CAAChB,aAAa,EAAE,OAAO,CAAC,EAAA,eAAA,CAC7CD,WAAW,CAACkB,oBAAoB,CAAA,GAAG,CAAChB,mBAAmB,EAAE,OAAO,CAAC,EAAA,eAAA,CACjEF,WAAW,CAACmB,qBAAqB,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CACrEnB,WAAW,CAACoB,2BAA2B,CAAA,GAAG,CAAC,OAAO,CAAC,EAAA,eAAA,CACnDpB,WAAW,CAACqB,QAAQ,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CACxDrB,WAAW,CAACsB,gBAAgB,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,MAAM,CAAC,EAAA,eAAA,CACjFtB,WAAW,CAACuB,iBAAiB,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,MAAM,CAAC,EAAA,eAAA,CAClFvB,WAAW,CAACwB,gBAAgB,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,WAAW,EAAE,MAAM,CAAC,EAAA,eAAA,CACrFxB,WAAW,CAACyB,iBAAiB,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,WAAW,EAAE,MAAM,CAAC,EAAA,eAAA,CACtFzB,WAAW,CAACM,OAAO,CAAA,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,EAAA,eAAA,CAC1CN,WAAW,CAAC0B,QAAQ,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CAC7C1B,WAAW,CAAC2B,WAAW,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CAChD3B,WAAW,CAAC4B,KAAK,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CACrD5B,WAAW,CAACO,IAAI,CAAA,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,EAAA,eAAA,CACvCP,WAAW,CAACQ,cAAc,CAAA,GAAG,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CAClFR,WAAW,CAACS,eAAe,CAAA,GAAG,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CAC9FT,WAAW,CAACU,QAAQ,CAAA,GAAG,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CAC5EV,WAAW,CAACW,SAAS,CAAA,GAAG,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CACxFX,WAAW,CAACY,UAAU,CAAA,GAAG,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CAC9EZ,WAAW,CAAC6B,WAAW,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CAC3D7B,WAAW,CAACa,QAAQ,CAAA,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,EAAA,eAAA,CAC3Cb,WAAW,CAAC8B,eAAe,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CAC/D9B,WAAW,CAAC+B,gBAAgB,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CAC3E/B,WAAW,CAACc,KAAK,CAAA,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,EAAA,eAAA,CACxCd,WAAW,CAACe,WAAW,CAAA,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,EAAA,eAAA,CAC7D;AAED,IAAaiB,YAAY,GAAA,aAAA,YAAA;EAIvB,SAAA,YAAA,GAAA;IACE,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,MAAM,GAAG,EAAE;;EACjB,IAAA,MAAA,GAAA,YAAA,CAAA,SAAA;EAAA,MAAA,CAEDC,UAAU,GAAVA,SAAAA,UAAAA,CAAWC,IAAiB,EAAEC,UAAiB,EAAEC,WAAW,EAAA;QAAXA,WAAW,KAAA,KAAA,CAAA,EAAA;MAAXA,WAAW,GAAG,KAAK;;IAClE,IAAIC,OAAO,GAAGC,aAAa,CAACJ,IAAI,EAAEC,UAAU,CAAC;IAC7C,IAAI,CAACH,MAAM,CAACO,IAAI,CAACF,OAAO,CAACG,YAAY,CAAC;IACtC,IAAIJ,WAAW,EAAE;MACf,IAAI,CAAClC,mBAAmB,CAACuC,GAAG,CAACJ,OAAO,CAACH,IAAI,CAAC,EAAE;QAC1C,MAAM,IAAIQ,KAAK,CAAA,gBAAA,GAAkBL,OAAO,CAACH,IAAI,GAAA,8BAAA,CAA+B;;MAE9EG,OAAO,CAACH,IAAI,GAAGG,OAAO,CAACH,IAAI,GAAGjC,iBAAiB;;IAGjD,IAAI,CAAC8B,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACY,MAAM,CAACN,OAAO,CAACH,IAAI,CAACU,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;GACjF;EAAA,OAAA,YAAA;AAAA,CAAA,EAAA;AAQH,SAAgBP,aAAa,CAACJ,IAAiB,EAAEC,UAAiB,EAAA;EAChE,IAAMK,YAAY,GAAGM,KAAAA,CAAAA,eAAe,CAACC,MAAM,CAACjC,cAAc,CAACoB,IAAI,CAAC,EAAEC,UAAU,CAAC;EAC7E,OAAO;IAAED,IAAI,EAAJA,IAAI;IAAEM,YAAY,EAAZA;GAAc;AAC/B;ICrHaQ,wBAAwB,GAAG,SAA3BA,wBAAwB,CAAIC,OAAe,EAAA;EACtD,QAAQA,OAAO;IACb,KAAK,CAAC;;MACJ,OAAO,4CAA4C;IACrD,KAAK,CAAC;;MACJ,OAAO,4CAA4C;IACrD,KAAK,GAAG;;MACN,OAAO,4CAA4C;IACrD,KAAK,KAAK;;MACR,OAAO,4CAA4C;IACrD,KAAK,EAAE;;MACL,OAAO,4CAA4C;IACrD,KAAK,GAAG;;MACN,OAAO,4CAA4C;IACrD,KAAK,KAAK;;MACR,OAAO,4CAA4C;IACrD,KAAK,MAAM;;MACT,OAAO,4CAA4C;IACrD,KAAK,KAAK;;MACR,OAAO,4CAA4C;IACrD,KAAK,KAAK;;MACR,OAAO,4CAA4C;IACrD,KAAK,EAAE;;MACL,OAAO,4CAA4C;IACrD,KAAA,KAAA;MACE;;IAEL;MAEYC,MAAAA,IAAY,KAAG,CAAfA,yCAA+B,GAAA,OAAA,CAAA;EAAA;CAExC;;EACE,QAAA,OAAO;IACT,KAAK,CAAC;;MACJ,OAAO,4CAA4C;IACrD,KAAK,CAAA;;MACH,OAAO,4CAA4C;IACrD,KAAK,GAAA;;MACH,OAAO,4CAA4C;IACrD,KAAK,KAAE;;MACL,OAAO,4CAA4C;IACrD,KAAK,EAAA;;MACH,OAAO,4CAA4C;IACrD,KAAK,GAAA;;MACH,OAAO,4CAA4C;IACrD,KAAK,KAAA;;MACH,OAAO,4CAA4C;IACrD,KAAK,MAAE;;MACL,OAAO,4CAA4C;IACrD,KAAA,EAAA;MACE;;IAEL,KAAA,KAAA;MAED,OAAaC,4CAAkB;IAElBC;MACAC,MAAAA,IAAW,KAAG,CAAA,iDAA4C,GAAA,OAAA,CAAA;EAAA;AAGvE,CAAA;;ACjCA,IAAMC,gBAAAA,GAAAA,aAAAA,MAAiC,CAAA,SAAA,CAAG,IAAIC,CAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,GAAAA,CAAAA;AAQ9C,IAAA,WAAA,GAAA,4CAAA;AACA,IAAA,mBAAA,GAAA,4CAAA;AACA,IAAaC,mBAAY,GAAA,4CAAA;IAEJ,iCAAK,GAAA,aAAA,IAAA,OAAA,CAAA,OAAA,EAAA,aAAA,IAAA,CAAA,MAAA,CAAA,EAAA,CAAA,EAAA,aAAA,IAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA;AAAqD;AADpE;;EAC4F,SAAA,YAAA,CAAA,KAAA,EAAA,OAAA,EAAA;IAAA,IAAA,CAErGT,KAAAA,GAAAA,KAAAA;;IACE,IAAIU,CAAAA,SAAAA,GAAW,OAAO,CAAA,eAAA,CAAA,YAAA;EACtB;;EAEEC,MAAAA,CAAAA,MAAQzB,GAAAA,SAAWnC,MAAAA,CAAAA,OAAY0B,EAAAA,OAC7BmC,EAAAA;;IAIFF,IAAAA,WAAW,GAAG,IAAK;;MAErB;;;;;IAMA,IAAMG,CAAAA,OAAAA,CAAAA,SAAAA,GAAAA,CAAAA,qBACM,GAACC,IAAAA,CAAAA,OAAcC,CAAAA,SAAAA,KAAAA,IAAUC,GAAAA,qBAAyB,GAACC,mBAAiB;IAChF;IACA;IACA;IAEA;IAAqC,IAA1BC,8BAAI,GAAA,IAAA,CAAA,KAAA,CAAA,SAAA,KAAA,OAAA,CAAA,SAAA,CAAA,WAAA,IAAA,IAAA,CAAA,KAAA,CAAA,MAAA,CAAA,MAAA,GAAA,CAAA;IACb,IAAA,cAAaC,GAAMC,IAAAA,CAAAA,KAAQ,CAAA,YAAA,CAAA,QAAA,CAAA,QAAA;QACzB,aAAKC,GAAAA,IAAAA,CAAAA,KAAW,CAAA,WAAA,CAAA,QAAA,CAAA,QAAA;QACdC,iBAAUX,GAAO,8BAA8B,IAAKY,cAASb;SAC7D,IAAA,SAAA,GAAA,+BAAA,CAAA,IAAA,CAAA,KAAA,CAAA,KAAA,CAAA,EAAA,KAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,EAAA,EAAA,IAAA,GAAA;MACF,IAAA,IAAKW,GAAAA,KAAAA,CAAAA,KAAAA;MACHG,QAAAA,IAAAA,CAAS,KAACb,CAAAA,QAAa;QACvB,KAAA,SAAA,CAAA,QAAA,CAAA,EAAA;UACF,SAAKU,CAAAA,OAAAA,EAAAA,IAASI,EAAAA,IAAK,CAAA,KAAA,CAAA,SAAA,EAAA,IAAA,CAAA,OAAA,EAAA,WAAA,EAAA,iBAAA,CAAA;UACjBC;QACA,KAAA,SAAA,CAAA,QAAA,CAAA,EAAA;UACF,SAAA,CAAA,OAAA,EAAA,IAAA,EAAA,IAAA,CAAA,KAAA,CAAA,SAAA,EAAA,IAAA,CAAA,OAAA,EAAA,WAAA,EAAA,iBAAA,CAAA;UACE;;;UAIFC;QACF;UACEhB,MAAQzB,IAAAA,KAAAA,CAAU,4BAChB,CAAA;MAAA;IAIFyB;;;QAQAiB,OAAAA,CAAAA,UAAkB,CAAA,WAAWd,CAAAA,WAAS,EAAKC,CAAAA,IAAAA,CAAAA,OAAAA,CAAAA,SAAUc,EAAAA,IAAY,CAAA,KAAIC,CAAAA,gBAAkB,CAAA,IAAKC,CAAAA,OAAS,CAAA,iBAAA,CAAA,CAAA,QAAA,CAAA,QAAA,EAAA,CAAA,CAAA;;;MAGvGpB;;IAEH,IAAA,aAAA,KAAA,IAAA,CAAA,KAAA,CAAA,SAAA,KAAA,OAAA,CAAA,SAAA,CAAA,YAAA,IAAA,iBAAA,CAAA,IAAA,CAAA,KAAA,CAAA,CAAA,EAAA;MAAA;MAAA;MAGH,OAAA,CAAA,UAAA,CAAA,WAAA,CAAA,WAAA,EAAA,CAAA,IAAA,CAAA,OAAA,CAAA,SAAA,EAAA,CAAA,CAAA,CAAA;IACA;GAEIQ;EAAOa,OAAAA,YAAAA;GAAaC;AAMtB;AAMA,SAAInB,SAAS,CAAIC,OAAAA,EAAAA,IAAAA,EAAAA,SAAUC,EAAAA,OAAa,EAAA,WAAA,EAAA,iBAAA,EAAA;EACtCL,IAAAA,KAAO,GAACzB,IAAAA,CAAAA,KAAWnC;;IAEjB4E,YAAAA,GAAAA,IAAiB,CAAGf,YAAAA;MAGA,KAAA,GAAKsB,IAAKC,KAAAA,CAAAA,KAAO,CAAA,KAAA,EAAA,SAAA,IAAA,OAAA,CAAA,SAAA,CAAA,WAAA,GAAA,WAAA,GAAA,YAAA,EAAA,SAAA,CAAA;MAAC,SACtCzB,IAAW,OACX,CAAA,SAAA,CAAA,WAAA,EAAA;IACH,OAAM,CAAA,UAAa,CAAA,WAAIK,CAAAA,gBAAUc,EAAAA;IAChClB;IAIsB,iBAAUwB,GAAAA,mBAAO,GAAA,OAAA,CAAA,SAAA,EAAA,KAAA,CAAA,eAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA,QAAA,CAAA,QAAA,EAAA,EAAA,KAAA,CAAA,gBAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA,QAAA,CAAA,QAAA,EAAA,EAAA,KAAA,CAAA,IAAA,CAAA,GAAA,CAAA,UAAA,IAAA,EAAA;MAAC,OACtCzB,IAAAA,CAAAA,OACA;;EAEN,CAAA,MAAA,IAAA,SAAA,IAAA,OAAA,CAAA,SAAA,CAAA,YAAA,EAAA;IAEA,OAAA,CAAA,UAAA,CAAA,WAAA,CAAA,iBAAA,EAAA,CAAA,iBAAA,GAAA,mBAAA,GAAA,OAAA,CAAA,SAAA,EAAA,KAAA,CAAA,gBAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA,QAAA,CAAA,QAAA,EAAA,EAAA,KAAA,CAAA,eAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA,QAAA,CAAA,QAAA,EAAA,EAAA,KAAA,CAAA,IAAA,CAAA,GAAA,CAAA,UAAA,IAAA,EAAA;MACA,OAASc,IAAAA,CAAS,OAChBb;MACEQ,EAAAA,WAAK,CAALA,CAAAA;EAAOa;AAAaC;AAMtB;AACEd,SAAK,SAAmC,CAAA,OAAA,EAAA,KAAA,EAAA,SAAA,EAAA,OAAA,EAAA,WAAA,EAAA,iBAAA,EAAA;EACxCa,IAAAA,KAAAA,GAAAA,KAAAA,CAAAA,KAAAA;IACAC,WAAAA,GAAAA,KAAAA,CAAAA,WAAY;IACZnB,YAAAA,GAAAA,KAAAA,CAAAA,YAAAA;EACD,IAAC,KAAA,GAAA,KAAA,CAAA,KAAA,CAAA,oBAAA,CAAA;IAEF,KAAMsB,EAAI,KAAGC;IACb,WAAa,EAAA,WAAItB;IACfJ,YAAQzB,EAAAA,YAAWnC;IAOpB,SAAU+D,EAAAA;IACTH;;EAQJ,IAAA,SAAA,IAAA,OAAA,CAAA,SAAA,CAAA,WAAA,EAAA;IAEA,OAAA,CAAA,UAAA,CAAA,WAAA,CAAA,gBAAA,EAAA,CAAA,iBAAA,GAAA,mBAAA,GAAA,OAAA,CAAA,SAAA,EAAA,KAAA,CAAA,eAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA,QAAA,CAAA,QAAA,EAAA,EAAA,KAAA,CAAA,gBAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA,QAAA,CAAA,QAAA,EAAA,EAAA,IAAA,EAAA,WAAA,CAAA,CAAA;EACA,CAAA,MAASe,IAAAA,SACPf,IAAAA,OACAO,CAAAA,SACAJ,CAAAA,YACoB,EACpBJ;IAGA,OAAa,CAALS,UAAAA,CAAAA,WAAK,CAAA,iBAAA,EAAA,CAAA,iBAAA,GAAA,mBAAA,GAAA,OAAA,CAAA,SAAA,EAAA,KAAA,CAAA,gBAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA,QAAA,CAAA,QAAA,EAAA,EAAA,KAAA,CAAA,eAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA,QAAA,CAAA,QAAA,EAAA,EAAA,IAAA,EAAA,WAAA,CAAA,CAAA;EAAEa;AAAaC;AAC5B;;EAGA,IAAId,KAAK,GAACmB,IAAMC,CAAAA,KAAM;IACpB,WAAUD,GAAAA,IAAQ,CAAA,WAAYE;IAC5B,YAAOhB,GAAAA,IAAUb,CAAAA,YAAa;EAC/B,IAAA,cAAe,GAAC2B,iBAAQ,GAAYG,mBAAM,GAAA,OAAA,CAAA,SAAA;EACzC;EACD,IAAA,KAAM,CAAA,KAAA,CAAA,MAAA,KAAA,CAAA,EAAA;IACL,IAAA,KAAM,CAAA,KAAI9C,CAAAA,CAAK,CAAC,YAAA,KAAA,CAAA,IAAqB,EAAA;;;MAInCoC,OAAK,SAAGW,CAAAA,OAAAA,EAAAA,IAAAA,EAAAA,SAAgBC,EAAAA,OAAAA,EAAAA,WAAqB,EAAA,iBAAA,CAAA;IACjDxB,CAAAA,MAAOA;MACPa,MAAAA,IAAAA,KAAAA,CAAAA,oBAAW,CAAA;IACXC;EACAnB;EACD,IAAC,KAAA,GAAA,SAAA,CAAA,eAAA,CAAA,oBAAA,CAAA;IAEF,KAAM8B,EAAAA,KAAQ;IACd,WAAe,EAAA,WAASC;;;EAIxB,CAAA,CAAA;EACA,IAAMC,QAAAA,GAAAA,KAAAA,CAAAA,eAAAA,CAAAA,OAAAA,CAAAA,iBAAiC,EAAA,WAAA,CAAA,CAAA,QAAA,CAAA,QAAA,EAAA;EACrC,IAAA,SAAQ,GAAKC,KAAAA,CAAAA,gBAAmB,CAAA,OAAA,CAAA,iBAAA,EAAA,YAAA,CAAA,CAAA,QAAA,CAAA,QAAA,EAAA;EACjC;EAED;EACA,IAAIC,QAAAA,GAAU,SAASC,CAAAA,6BAAa,CAAA,KAAA,CAAA;EAEpC,IAAA,oBAAoBF,GAAAA,SAAe,oBAAO,CAAA,CAAA,EAAA;IACxC,OAAMG,CAAAA,KAAO,QAAGH,CAAQ,MAAG,GAAA,CAAA;;EAE3BI,IAAAA,WAAW;EAEX,IAAA,UAAMC,GAAAA,KAAgB,CAAA,KAAG,CAAIC,OAAAA;EAK7B,KAAA,IAAMC,CAAAA,GAAAA,CAAQ,EAAA,CAAG,GAAA,QAAIC,CAAAA,MAAAA,EAAAA,CAAAA,EAAAA,EAAWH;;IAGhCJ;IAEA,WAAMQ,GAAAA,SAAiB,CAAjBA,gBAAAA,CAAAA,OAAAA,EAAiB,UAA4C,CAAA;IACjE,IAAA,gBAAkB,GAACC,IAAM,SAAA,CAACvB,aAAI,CAAA,EAAA,CAAA,MAAA,CAAA,OAAA,CAAA,EAAA,OAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,MAAA,CAAA,UAAA,CAAA,GAAA,OAAA,CAAA,CAAA,CAAA,CAAA,MAAA,GAAA,OAAA,CAAA,CAAA,CAAA,CAAA,MAAA,EAAA,WAAA,CAAA;QAAA,QAAKA,GAAI,IAAA,SAAYM,CAAAA,UAAI,CAAA,gBAAA,CAAA;IAAC;IACzD,UAAA,GAAA,WAAA;IAED,IAAIgB,iBAAiB,GAACF,SAAW,iBAAA,CAAA,KAAA,EAAA;MAC/B,OAAMlB,KAAesB,CAAAA,KAAAA,CAAAA,KAAAA,CAAAA,UAAAA,IAAAA,EAAAA;QAErB/C,OAAQzB,IAAAA,YAAWnC,KAAW,CAACsB,IAAAA;;;IAG7ByE,IAAAA,iBAAAA,CAAoB,QAAMa,CAAAA,EAAAA;MAM7B,IAAA,IAAM,GAAA,SAAA,CAAA,sBAAA,CAAA,QAAA,CAAA;MACLhD,OAAO,CAACzB,UAAU,CAACnC,WAAW,CAACwB,gBAAgB,EAAE;MAIxB;MAAkB;;;MAKjD,OAAA,CAAA,UAAA,CAAA,WAAA,CAAA,gBAAA,EAAA,CAAA,oBAAA,CAAA,CAAA,CAAA,GAAA,cAAA,GAAA,mBAAA,EAAA,CAAA,KAAA,CAAA,GAAA,QAAA,GAAA,gBAAA,EAAA,CAAA,oBAAA,CAAA,CAAA,CAAA,GAAA,CAAA,GAAA,SAAA,EAAA,QAAA,CAAA,IAAA,CAAA,GAAA,CAAA,UAAA,IAAA,EAAA;QAEA,OAAA,IAAA,CAAA,OAAA;MACA,CAAA,CAAA,EAASuD,WAAAA,IAAAA,CAAiB,KAACC,CAAiD,CAAA,CAAA;IAC1E;EACF;;ACjQA;AACA,SAAM6B,iBAAAA,CAAAA,KAA4B,EAAE;EAEpC,OAAgBC,KAAAA,CAAAA,WAAalD,CAAAA,WAA4C,CAAA,iCAAA,CAAA;AACvE;;AAIA,IAAA,yBAAemD,GAAAA,EAAgB;;EAE7BC,IAAAA,SAAS,GAAGC,MAAAA,CAAAA,SAAOC;;EAGrBtD;EACF,IAAA,MAAA,KAAA,gBAAA,IAAA,MAAA,KAAA,yBAAA,EAAA;;ICAsBuD,SAAAA,GAAU,MAAA,CAAA,MAAA,CAAA,KAAA,CAAA,aAAA,CAAA,MAAA,CAAA,MAAA,CAAA,KAAA,CAAA,cAAA,CAAA,MAAA,CAAA,SAAA,CAAA,CAAA;EAAA;EAAA,OAAA,CAAA,UAGhBE,CAAAA,WAAkB,CAAzB,MAAA,EAAA,CAAA,MAAA,EAAA,SAAA,CAAA,CAAA;AAAuDC;;EAC5D,SAAKC,UAAMC,GAAQC,CAAAA;EAEnB,UAAMC,CAAAA,kBAAmBC,GAAO,SAAA,kBAAS,CAAA,MAAA,EAAA,MAAA,EAAA;IAAA,IAAA,MAAS3C,KAAM4C,KAAAA,CAAAA,EAAAA;MAAgD,MAAA,GAAA,CAAA,CAAA;IACxG;IACA,IAAMhE,CAAAA,KAAAA,CAAO,OAAO5B,CAAAA,MAAAA,CAAAA,EAAAA,MAAc,GAAA,CAAA,MAAA,CAAA;;MAGlC,OAAI6F,KAAAA,CAAAA,cAAAA,CAA0B,QAAGC,CAAAA;IACjC,CAAA,CAAA;IAEA,IAAA,WAAA,GAAA,SAAA,CAAA,MAAA,IAAA,CAAA,IAAA,SAAA,CAAoBL,CAAAA,CAAAA,CAAAA,MAAM,CAAA,MAAA,IAAA,CAAA,GAAA,KAAA,GAAA,IAAA;IAAE,IAAjBzC,OAAK,GAAA,IAAA,YAAA,EAAA;;;;IAId,KAAA,IAAIA,SAAMjB,GAAS,+BAAoBgE,CAAAA,MAAU,CAAA,EAAA,KAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,EAAA,EAAA,IAAA,GAAA;MAC/C,IAAA,KAAMC,GAAAA,KAAWhD,CAAAA,KAA0B;MAC3CgD;AAA2B1F;AAAa;MACxC,IAAA,KAAM2F,CAAAA,SAAaD,IAAAA,OAASE,CAAAA,eAAe,CAAA,QAAA,EAAA;;QAG3C,QAAIL,CAAAA,MAAAA,CAAAA,OAAAA,EAAAA;UACFM,WAAAA,EAAAA;UACAN;QACD,IAAA,UAAM,GAAA,QAAA,CAAA,aAAA,EAAA;QACLA;;;;;UAKH,0BAA6B9H,GAAAA,0BAAgB2D,CAAAA,GAAAA,CAAAA,UAAc,CAAA;QAC1D;QACA;AACA;AACA;OAEA,MAAYmB,IAAAA,KAAAA,CAAAA,SAAmBuD,IAAAA,OAAYC,CAAAA,eAAiB,CAA5D,YAAS,EAAA;QAET,IAAI,YAAED,GAAYC,KAAAA;QAChBvB,IAAAA,aAAalD,GAAAA,YAASwE,CAAAA,KAAYC,CAAAA,WAAAA,CAAAA,QAAiB,CAAA,QAAA;;QAGrD,IAAIxD,WAAAA,GAAa,YAAE,CAAA,OAAA;SACjBsD,EAAAA,aAAAA,IAAgB,CAAGA,CAAAA,WAAAA,CAAAA,gBACjBL,CAAAA,GAAAA,SAAeQ,CAAAA,KAAAA,EAAAA,qBAAmBC,CAAAA,GAAe,KAACH,CAAAA;;;QAItD;QACEP,IAAAA,aAAAA,EAAAA;;QAIFS;QAA+BhG;QAAoB,IAAC,cAAA,IAAA,WAAA,CAAA,SAAA,IAAA,mBAAA,EAAA;;;;UAIrD,WAAU0C,EAAMjB;QACf,CAAA,CAAA;QACAiB;AAAwB1C;AAAoB;OAC5CuF,MAAAA,IAAAA,KAAAA,CAAAA,SAAAA,IAA0B,OAAGA,CAAAA,eAAAA,CAAAA,UAA+BW,EAAAA;;;;QAI7D,CAAA,CAAA;QACC,0BAAM,GAAA,0BAAA,CAAA,GAAqD,CAAA,UAAA,CAAA,MAAA,CAAA;;;;;QAM3Dd,MAAAA,qDAA0D;MAC9D;;;;;;;EAGF;AAKiEJ;AAAAA;;AAC/D,KANF;EAOE,UAAImB,CAAAA,qBAAaX,GAAS,SAAQ,qBAAA,CAAA,MAAA,EAAA,MAAA,EAAA;IAElC,IAAMxF,MAAAA,KAAW,KAAGmF,CAAAA,EAAAA;MAEpB,MAAA,GAAA,CAAA,CAAA;IAAWzC;IACTA,IAAAA,OAAM/B,GAAM,IAACW,YAAS,EAAA;QAAEtB,UAAAA,GAAAA,MAAAA,CAAAA,SAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA;IAAa,IAAC,WAAA,GAAA,MAAA,CAAA,MAAA,IAAA,CAAA,IAAA,MAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,MAAA,IAAA,CAAA,GAAA,KAAA,GAAA,IAAA;IACtCmG,KAAAA,IAAAA,UAAaA,GAAAA,+BAAqC,CAAA,MAAA,CAAA,EAAA,MAAA,EAAA,CAAA,CAAA,MAAA,GAAA,UAAA,EAAA,EAAA,IAAA,GAAA;;MAGpD7E,KAAO,CAACzB,MAAAA,CAAAA,OAAWnC,EAAAA;QACnB,WAAOmH,EAAU;;;;;;;;AAGnB;;AAWE;AAEA;AAEA,K;EACA,UAAYuB,CAAAA,uBAA4BlE,GAAAA,SAAxC,uBAAA,CAAA,MAAS,EAAA,OAA0D,EAAA;IAEnE;IACEsC,IAAAA,OAAAA,GAAY,IAAClD,YAASY,EAAQ6D;;IAGhC,IAAMM,aAAAA,GAAAA,KAAmB,CAAGD,KAAAA,CAAAA,WAAcE,CAAAA,QACtCd;IAGJ9C,CAAAA,EAAAA,aAAapB,CAAAA,QAAS,IAAA,CAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,GAAA,SAAA,CAAA,KAAA,EAAA,qBAAA,CAAA,GAAA,KAAA,CAAA;IAAEtB,IAAAA,OAAAA,CAAAA,gBAAa,EAAA;MAAQ,YAAA,CAAA,OAAA,EAAA,OAAA,CAAA,gBAAA,CAAA;IAC7C;IACEuG,IAAAA,mBAAkBC,GAAAA,aAAAA,CAAAA,QAA2B,GAAGhB,MAAAA,CAAAA,SAAUiB,CAAAA,IAAKvE,CAAAA,KAAAA,CAAO,KAACsE,CAAAA,eAAAA,CAAAA,OAA4B,CAAA,iBAAGE,CAAAA,CAAAA,QAAAA,CAAAA,QAAAA,EAAAA,CAAAA,GAAAA,MAAAA,CAAAA,SAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA;IACvG,KAAC,CAAA,MAAA,CAAA,OAAA,EAAA;;;;;;;;AAIJ;AASE1B;AAAAA;;AAEA,K;EAAkBpF,UAAM,CAAA,UAANA,GAAAA,SAAM,UAAA,CAAA,OAAA,EAAA,mBAAA,EAAA,MAAA,EAAA;IACxB,IAAM+G,MAAAA,KAAAA,KAAAA,CAAiB,EAAA;MACvB,MAAM5G,GAAAA,CAAAA,CAAAA;IACN;IACA,IAAA,QAAO,GAAA,OAAA,CAAA,QAAA;MAAE6G,MAAAA,GAAAA,OAAAA,CAAAA,MAAQ;IAAEC,IAAAA,iBAAOR,GAAAA,CAAAA,CAAAA,MAAoBS,CAAAA,QAAW,GAAA,gCAAA,GAAA,wBAAA;IAAI,IAAA,UAAA,GAAA,CAAA,CAAA,MAAA,CAAA,QAAA,GAAA,CAAA,QAAA,EAAA,MAAA,EAAA,MAAA,CAAA,QAAA,CAAA,GAAA,CAAA,QAAA,EAAA,MAAA,CAAA;IAC9D,IAAA,QAAA,GAAA,UAAA,CAAA,SAAA,CAAA,kBAAA,CAAA,iBAAA,EAAA,UAAA,CAAA;IAAA,OAAA;MAAA,QAAA,EAAA,QAAA;MAlJajC,KAAAA,EAAAA,mBAAS,CAAA,WAAkBC;;GCArBW;EACX,OAAA,UAA6BhI;CAKpC,EAAA;AACA,UAAKsJ,CAAAA,SAASA,GAAM,aAAA,IAAA,KAAA,CAAA,SAAA,CAAA,oBAAA,CAAA,GAAA,CAAA;AAEtB,IAAC,QAAA,GAAA,SAAA,QAAA,CAAA,MAAA,EAAA,MAAA,EAAA;EAgBH,IAAA,CAAA,SAAYC,GAAM,OAAA,CAAA,eAAA,CAAA,QAAA;EAChBA,EAAAA,MAAAA,CAAAA,MAAAA,GAAAA,CAAAA,CAAAA,GAAAA,SAAAA,CAAAA,KAAyB,EAAA,cAAA,CAAA,GAAA,KAAA,CAAA;EACzBA,IAAAA,CAAAA,MAAAA,GAAAA,MAAAA;EACAA,IAAAA,CAAAA,MAAAA,GAAAA,MAAAA;CACAA;CACAA,UAAAA,MAAAA,EAAAA;EACAA,MAAAA,CAAAA,YAAAA,CAAAA,GAAAA,YAAqB;EACrBA,MAAAA,CAAAA,WAAAA,CAAAA,GAAAA,WAAAA;EACAA,MAAAA,CAAAA,OAAAA,CAAAA,GAAAA,OAAa;EARHA,MAAAA,CAAAA,MAAAA,CAAAA,GAAAA,MAAAA;EAWZ,MAAA,CAAA,SAAYC,CAAAA,GAAS,SAAA;EACnBA,MAAAA,CAAAA,UAAAA,CAAAA,GAAAA,UAAiB;EACjBA,MAAAA,CAAAA,aAAAA,CAAAA,GAAAA,aAAmB;EACnBA,MAAAA,CAAAA,MAAAA,CAAAA,GAAAA,MAAAA;AACF,CAAC,EAJWA,OAAAA,CAAAA,MAAAA,KAAAA,OAAAA,CAAAA,MAAAA,GAAAA,CAAAA,CAAAA,CAAS,CAAA;;EChDRC,SAAAA,CAAAA,QAAgB,CAAA,GAAA,QAAA;EAAA,SAAA,CAAA,SAAA,CAAA,GAAA,SAAA;EAG3B,SAAA,CAAA,YAAA,CAAA,GAAYC,YAAwB;WAClC,SAAA,KAAA,OAAMH,CAAAA,SAAAA,GAAAA,CAAM,CAACI,CAAAA,CAAAA;AACd,IAAA,eAAA,GAAA,aAAA,UAAA,SAAA,EAAA;EAAA,cAEK,CAANzG,eAAAA,EAAOW,SAAuB0D,CAAAA;EAC5B,SAAA,eAAA,CAAA,MAAA,EAAA;IAAWqC,OAAAA,SAAI,CAAA,IAAA,CAAA,IAAA,EAAA,OAAA,CAAA,MAAA,CAAA,WAAA,EAAA,MAAA,CAAA,IAAA,IAAA;EACb/F;;EAEH,MAAA,CAAA,MAAA,GAAA,SAAA,MAAA,CAAA,OAAA,EAAA,MAAA,EAAA;IAAA,KAEDgG,IAAAA,SAAAA,GAAAA,+BAAAA,CAAAA,IAAAA,CAAAA,MAAAA,CAAAA,EAAAA,KAAAA,EAAAA,CAAAA,CAAAA,KAAAA,GAAAA,SAAAA,EAAAA,EAAAA,IAAAA,GAAAA;MACE,IAAIC,IAAAA,GAAQ,KAAgB,CAAA,KAAA;MAC5B,OAAA,CAAA,UAAA,CAAA,WAAA,CAAA,WAAA,EAAA,CAAA,IAAA,CAAA,OAAwBJ,EAAAA,IAAM,CAAA,SAAA,EAAA,IAAA,CAAA,KAAA,CAAA,EAAA,MAAA,CAAA,WAAE,CAAA;IAArBE;GACTE;QACEC,CAAAA,WAAY,GAAEN,SAAAA,WAAgBO,GAAAA;QAC9BC,QAAO,GAAEL,EAAI;IACbM,KAAAA,IAAAA,UAAWV,GAAAA,+BAAUW,CAAAA,IAAAA,CAAAA,MAAAA,CAAAA,EAAAA,MAAAA,EAAAA,CAAAA,CAAAA,MAAAA,GAAAA,UAAAA,EAAAA,EAAAA,IAAAA,GAAAA;MACtB,IAAC,IAAA,GAAA,MAAA,CAAA,KAAA;;QAEJ,YAAe,EAAA,eAAA,CAAA,kBAAA;QAChB,OAAA,EAAA,IAAA,CAAA,OAAA;QAAA,SAEDhC,EAAAA,OAAAA,CAAAA,SAAAA,CAAAA;MACE,CAAA,CAAIiC;IACJ;IAAWR,OAAAA,QAAI;GACbQ;;IAEF,IAAA,KAAOA,GAAK,MAAA,CAAA,SAAA,CAAA,IAAA,CAAA,CAAA,CAAA;IACb,KAAA,IAAA,UAAA,GAAA,+BAAA,CAAA,IAAA,CAAA,MAAA,CAAA,EAAA,MAAA,EAAA,CAAA,CAAA,MAAA,GAAA,UAAA,EAAA,EAAA,IAAA,GAAA;MAAA,IAAA,IAAA,GAAA,MAAA,CAAA,KAAA;MA/BkCpC,KAAwB,GAAA,KAAA,CAAA,GAAA,CAAA,IAAA,CAAA,KAAA,CAAA;IAC7CyB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECGHY,eAAAA,EAAgB,SAAA;EAAA,IAAA,EAAA;CAG3B,CACE;AACD,IAAA,eAAA,GAAA,aAAA,UAAA,SAAA,EAAA;EAAA,cAEK,CAANnH,eAAAA,EAAOW,SAAuB0D,CAAAA;EAC5B,SAAA,eAAA,CAAA,MAAA,EAAA;IAAWqC,OAAAA,SAAI,CAAA,IAAA,CAAA,IAAA,EAAA,OAAA,CAAA,MAAA,CAAA,UAAA,EAAA,MAAA,CAAA,IAAA,IAAA;EACb;MAMA/F,MAAAA,GAAQzB,eACNnC,CAAAA,SAAYY;;IAKjB,KAAA,IAAA,SAAA,GAAA,+BAAA,CAAA,IAAA,CAAA,MAAA,CAAA,EAAA,KAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,EAAA,EAAA,IAAA,GAAA;MAAA,IAEDgJ,IAAAA,GAAAA,KAAW,CAAXA,KAAAA;MACE,IAAIC,QAAQ,GAAgB,eAAA,CAAA,SAAA,CAAA,kBAAA,CAAA,OAAA,EAAA,CAAA,IAAA,CAAA,YAAA,EAAA,IAAA,CAAA,OAAA,EAAA,IAAA,CAAA,KAAA,EAAA,IAAA,CAAA,QAAA,CAAA,CAAA;MAC5B,OAAA,CAAA,UAAA,CAAA,WAAA,CAAA,UAAA,EAAA,CAAA,IAAA,CAAA,KAAmB,EAAI,QAAO,EAAA,IAAA,CAAA,SAAA,EAAA,IAAA,CAAA,YAAA,EAAA,IAAA,CAAE,OAAA,CAAA,EAAA,MAAA,CAAA,WAAA,CAAA;IAArBF;GACTE;QACEC,CAAAA,WAAY,GAAEH,SAAKG,WAAY,GAAA;QAC/BE,QAAO,GAAEL,EAAI;IACbM,KAAAA,IAAAA,UAAWV,GAAAA,+BAAUc,CAAAA,IAAAA,CAAAA,MAAAA,CAAAA,EAAAA,MAAAA,EAAAA,CAAAA,CAAAA,MAAAA,GAAAA,UAAAA,EAAAA,EAAAA,IAAAA,GAAAA;MACtB,IAAC,IAAA,GAAA,MAAA,CAAA,KAAA;;QAEJ,YAAe,EAAA,IAAA,CAAA,YAAA;QAChB,OAAA,EAAA,IAAA,CAAA,OAAA;QAAA,SAEDnC,EAAAA,OAAAA,CAAAA,SAAAA,CAAAA;MACE,CAAA,CAAIiC;IACJ;IAAWR,OAAAA,QAAI;GACbQ;;IAEF,IAAA,KAAOA,GAAK,MAAA,CAAA,SAAA,CAAA,IAAA,CAAA,CAAA,CAAA;IACb,KAAA,IAAA,UAAA,GAAA,+BAAA,CAAA,IAAA,CAAA,MAAA,CAAA,EAAA,MAAA,EAAA,CAAA,CAAA,MAAA,GAAA,UAAA,EAAA,EAAA,IAAA,GAAA;MAAA,IAAA,IAAA,GAAA,MAAA,CAAA,KAAA;MAzCkCpC,KAAwB,GAAA,KAAA,CAAA,GAAA,CAAA,IAAA,CAAA,KAAA,CAAA;IAC7CqC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EC2BHE,eAAAA,EAAe,MAAA;EAAA,IAAA,EAAA;CAG1B,CACE;AACD,IAAA,cAAA,GAAA,aAAA,UAAA,SAAA,EAAA;EAAA,cAEK,CAANrH,cAAAA,EAAAA,SAA4B,CAAEqE;EAC5B,SAAA,cAAA,CAAA,MAAA,EAAA;IAAWqC,OAAAA,SAAI,CAAA,IAAA,CAAA,IAAA,EAAA,OAAA,CAAA,MAAA,CAAA,SAAA,EAAA,MAAA,CAAA,IAAA,IAAA;EACb;MAKA,MAAIA,GAAKM,cAAaV,CAAAA,SAAAA;QACpB,CAAA,MAAegB,GAAAA,SAAWC,MAAM,CAAA,OAAhC,EAAA,MAAA,EAAS;IACT5G,KAAAA,IAAAA,SAAQzB,GAAAA,+BAELwH,CAAAA,IAAKY,CAAAA,MAAAA,CAAAA,EAAU,KAACE,EAAK,CAAEvB,CAAAA,KAAAA,GAAQ,SAAOwB,EAAAA,EAAAA,IAAWf,GAAAA;MAGrD,IAAA,IAAM,GAAIA,KAAKM,CAAAA,KAAAA;MACdrG,IAAAA,QAAQzB,GAAAA,cACNnC,CAAAA,SAAYS,CAAAA,kBAEL8J,CAAAA,qCAEAG,EAAS,CAAA,IACdf,CAAI,UAACY,EAAWI,IAAAA,CAAAA,UAChBhB,CAAI,CAACY;;;QAOd,OAAA,CAAA,UAAA,CAAA,WAAA,CAAA,cAAA,EAAA,CAAA,IAAA,CAAA,UAAA,CAAA,KAAA,EAAA,QAAA,EAAA,IAAA,CAAA,SAAA,EAAA,IAAA,CAAA,UAAA,CAAA,UAAA,EAAA,IAAA,CAAA,UAAA,CAAA,OAAA,CAAA,EAAA,MAAA,CAAA,WAAA,CAAA;MAAA,CAAA,MAEDX,IAAAA,IAAW,CAAXA,SAAAA,IAAAA,OAAAA,CAAAA,SAAAA,CAAAA,OAAAA,EAAAA;QACMC,OAAAA,CAAQ,UAAgB,CAAA,WAAA,CAAA,eAAA,EAAA,CAAA,IAAA,CAAA,UAAA,CAAA,KAAA,EAAA,QAAA,EAAA,IAAA,CAAA,SAAA,EAAA,IAAA,CAAA,UAAA,CAAA,UAAA,EAAA,IAAA,CAAA,UAAA,CAAA,OAAA,EAAA,IAAA,CAAA,UAAA,CAAA,MAAA,CAAA,EAAA,MAAA,CAAA,WAAA,CAAA;MAC5B;IAAWF;GACTE;QACEC,CAAAA,WAAY,GAAEH,SAAKY,WAAWI,GAAAA;QAC9BX,QAAO,GAAEL,EAAI;IACbM,KAAAA,IAAAA,UAAe,GAACA,+BAAAA,CAAAA,IAAAA,CAAAA,MAAAA,CAAAA,EAAAA,MAAAA,EAAAA,CAAAA,CAAAA,MAAAA,GAAAA,UAAAA,EAAAA,EAAAA,IAAAA,GAAAA;MACjB,IAAC,IAAA,GAAA,MAAA,CAAA,KAAA;;QAEJ,YAAe,EAAA,IAAA,CAAA,UAAA,CAAA,UAAA;QAChB,OAAA,EAAA,IAAA,CAAA,UAAA,CAAA,OAAA;QAAA,SAED/B,EAAAA,IAAa,CAAbA;MACE,CAAA,CAAIiC;IACJ;IAAWR,OAAAA,QAAI;GACbQ;;IAEF,IAAA,KAAOA,GAAK,MAAA,CAAA,SAAA,CAAA,IAAA,CAAA,CAAA,CAAA;IACb,KAAA,IAAA,UAAA,GAAA,+BAAA,CAAA,IAAA,CAAA,MAAA,CAAA,EAAA,MAAA,EAAA,CAAA,CAAA,MAAA,GAAA,UAAA,EAAA,EAAA,IAAA,GAAA;MAAA,IAAA,IAAA,GAAA,MAAA,CAAA,KAAA;MAxDiCpC,KAAuB,GAAA,KAAA,CAAA,GAAA,CAAA,IAAA,CAAA,UAAA,CAAA,KAAA,CAAA;IAC3CuC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EC3BHM,eAAW,EAAA,SAAA;EAAA,IAAA,EAAA;CAGtB,CACE;AACD,IAAA,UAAA,GAAA,aAAA,UAAA,SAAA,EAAA;EAAA,cAEK,CAAN3H,UAAAA,EAAAA,SAAOW,CAAAA;EACL,SAAA,UAAA,CAAA,MAAA,EAAA;IAAWiH,OAAAA,SAAK,CAAA,IAAA,CAAA,IAAA,EAAA,OAAA,CAAA,MAAA,CAAA,KAAA,EAAA,MAAA,CAAA,IAAA,IAAA;EACd;MAQAjH,MAAAA,GAAQzB,UAAWnC,CAAAA,SAAAA;;IAEtB,KAAA,IAAA,SAAA,GAAA,+BAAA,CAAA,IAAA,CAAA,MAAA,CAAA,EAAA,KAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,EAAA,EAAA,IAAA,GAAA;MAAA,IAED4J,KAAAA,GAAAA,KAAAA,CAAAA,KAAAA;MACE,IAAIC,QAAQ,GAAgB,UAAA,CAAA,SAAA,CAAA,kBAAA,CAAA,WAAA,EAAA,CAAA,KAAA,CAAA,YAAA,EAAA,KAAA,CAAA,QAAA,EAAA,KAAA,CAAA,YAAA,EAAA,KAAA,CAAA,SAAA,EAAA,KAAA,CAAA,GAAA,EAAA,KAAA,CAAA,IAAA,CAAA,CAAA;MAC5B,OAAA,CAAA,UAAA,CAAA,WAAA,CAAA,KAAA,EAAA,CAAA,KAAA,CAAA,KAAA,EAAmB,QAAKJ,CAAAA,EAAM,MAAA,CAAA,WAAA,CAAA;IAAnBtE;GACT;QAAqC,CAA1B6E,WAAO,GAAA,SAAA,WAAA,GAAA;QAChBH,QAAQ,GAACpH,EAAI;SACXqH,IAAAA,UAAY,GAAE3E,+BAAiB,CAAA,IAAA,CAAA,MAAA,CAAA,EAAA,MAAA,EAAA,CAAA,CAAA,MAAA,GAAA,UAAA,EAAA,EAAA,IAAA,GAAA;UAC/B6E,IAAAA,GAAO,MAAEA,CAAAA,KAAO;MAChBC,KAAAA,IAAAA,UAAWV,GAAAA,+BAAUc,CAAAA,IAAAA,CAAAA,QAAAA,CAAAA,EAAAA,MAAAA,EAAAA,CAAAA,CAAAA,MAAAA,GAAAA,UAAAA,EAAAA,EAAAA,IAAAA,GAAAA;QACtB,IAAC,OAAA,GAAA,MAAA,CAAA,KAAA;;;UAIN,OAAOR,EAAQ,OAAA;UAChB,SAAA,EAAA,OAAA,CAAA,SAAA,CAAA;QAAA,CAED3B,CAAAA;MACE;IACA;IAAWyB,OAAAA,QAAI;GACbQ;;IAEF,IAAA,KAAOA,GAAK,MAAA,CAAA,SAAA,CAAA,IAAA,CAAA,CAAA,CAAA;IACb,KAAA,IAAA,UAAA,GAAA,+BAAA,CAAA,IAAA,CAAA,MAAA,CAAA,EAAA,MAAA,EAAA,CAAA,CAAA,MAAA,GAAA,UAAA,EAAA,EAAA,IAAA,GAAA;MAAA,IAAA,IAAA,GAAA,MAAA,CAAA,KAAA;MA1C6BpC,KAAmB,GAAA,KAAA,CAAA,GAAA,CAAA,IAAA,CAAA,KAAA,CAAA;IACnC6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECDHE,eAAU,EAAA,SAAA;EAAA,IAAA,EAAA;CAGrB,CACE;AACD,IAAA,SAAA,GAAA,aAAA,UAAA,SAAA,EAAA;EAAA,cAEK,CAAN7H,SAAAA,EAAAA,SAAOW,CAAAA;EACL,SAAA,SAAA,CAAA,MAAA,EAAA;IAAWiH,OAAAA,SAAK,CAAA,IAAA,CAAA,IAAA,EAAA,OAAA,CAAA,MAAA,CAAA,IAAA,EAAA,MAAA,CAAA,IAAA,IAAA;EACd;MAOAjH,MAAAA,GAAQzB,SAAU,CAACnC,SAAAA;;IAEtB,KAAA,IAAA,SAAA,GAAA,+BAAA,CAAA,IAAA,CAAA,MAAA,CAAA,EAAA,KAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,EAAA,EAAA,IAAA,GAAA;MAAA,IAED4J,KAAAA,GAAAA,KAAAA,CAAAA,KAAAA;MACE,IAAIC,QAAQ,GAAgB,SAAA,CAAA,SAAA,CAAA,kBAAA,CAAA,cAAA,EAAA,CAAA,KAAA,CAAA,OAAA,EAAA,KAAA,CAAA,QAAA,CAAA,MAAA,EAAA,KAAA,CAAA,QAAA,EAAA,CAAA,OAAA,CAAA,KAAA,CAAA,OAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,OAAA,EAAA,KAAA,CAAA,YAAA,CAAA,EAAA,KAAA,CAAA,SAAA,CAAA,CAAA;MAC5B,OAAA,CAAA,UAAA,CAAA,WAAA,CAAA,IAAA,EAAA,CAAA,KAAA,CAAA,KAAA,EAAA,QAAyBJ,CAAAA,EAAAA,MAAM,CAAA,WAAA,CAAA;IAApBoB;GACT;QAAsC,CAA3Bb,WAAO,GAAA,SAAA,WAAA,GAAA;QAChBH,QAAQ,GAACpH,EAAI;SACXqH,IAAAA,UAAY,GAAEe,+BAAkB,CAAA,IAAA,CAAA,MAAA,CAAA,EAAA,MAAA,EAAA,CAAA,CAAA,MAAA,GAAA,UAAA,EAAA,EAAA,IAAA,GAAA;UAChCb,KAAAA,GAAO,MAAEA,CAAAA,KAAO;MAChBC,KAAAA,IAAAA,UAAWV,GAAAA,+BAAUc,CAAAA,KAAAA,CAAAA,QAAAA,CAAAA,EAAAA,MAAAA,EAAAA,CAAAA,CAAAA,MAAAA,GAAAA,UAAAA,EAAAA,EAAAA,IAAAA,GAAAA;QACtB,IAAC,OAAA,GAAA,MAAA,CAAA,KAAA;;;UAGN,OAAOR,EAAQ,OAAA;UAChB,SAAA,EAAA,OAAA,CAAA,SAAA,CAAA;QAAA,CAED3B,CAAAA;MACE;IACA;IAAWyB,OAAAA,QAAI;GACbQ;;IAEF,IAAA,KAAOA,GAAK,MAAA,CAAA,SAAA,CAAA,IAAA,CAAA,CAAA,CAAA;IACb,KAAA,IAAA,UAAA,GAAA,+BAAA,CAAA,IAAA,CAAA,MAAA,CAAA,EAAA,MAAA,EAAA,CAAA,CAAA,MAAA,GAAA,UAAA,EAAA,EAAA,IAAA,GAAA;MAAA,IAAA,IAAA,GAAA,MAAA,CAAA,KAAA;MAxC4BpC,KAAkB,GAAA,KAAA,CAAA,GAAA,CAAA,IAAA,CAAA,KAAA,CAAA;IACjC+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","sourcesContent":["import { RoutePlanner } from '../utils/routerCommands'\n\nexport type TradeConfig = {\n  allowRevert: boolean\n}\n\nexport enum RouterTradeType {\n  UniswapTrade = 'UniswapTrade',\n  NFTTrade = 'NFTTrade',\n  UnwrapWETH = 'UnwrapWETH',\n}\n\n// interface for entities that can be encoded as a Universal Router command\nexport interface Command {\n  tradeType: RouterTradeType\n  encode(planner: RoutePlanner, config: TradeConfig): void\n}\n","import { defaultAbiCoder } from 'ethers/lib/utils'\n\n/**\n * CommandTypes\n * @description Flags that modify a command's execution\n * @enum {number}\n */\nexport enum CommandType {\n  V3_SWAP_EXACT_IN = 0x00,\n  V3_SWAP_EXACT_OUT = 0x01,\n  PERMIT2_TRANSFER_FROM = 0x02,\n  PERMIT2_PERMIT_BATCH = 0x03,\n  SWEEP = 0x04,\n  TRANSFER = 0x05,\n  PAY_PORTION = 0x06,\n\n  V2_SWAP_EXACT_IN = 0x08,\n  V2_SWAP_EXACT_OUT = 0x09,\n  PERMIT = 0x0a,\n  WRAP_ETH = 0x0b,\n  UNWRAP_WETH = 0x0c,\n  PERMIT2_TRANSFER_FROM_BATCH = 0x0d,\n\n  // NFT-related command types\n  SEAPORT = 0x10,\n  LOOKS_RARE_721 = 0x11,\n  NFTX = 0x12,\n  CRYPTOPUNKS = 0x13,\n  LOOKS_RARE_1155 = 0x14,\n  OWNER_CHECK_721 = 0x15,\n  OWNER_CHECK_1155 = 0x16,\n\n  X2Y2_721 = 0x18,\n  SUDOSWAP = 0x19,\n  NFT20 = 0x1a,\n  X2Y2_1155 = 0x1b,\n  FOUNDATION = 0x1c,\n}\n\nconst PERMIT_STRUCT =\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce) details, address spender, uint256 sigDeadline)'\n\nconst PERMIT_BATCH_STRUCT =\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce)[] details, address spender, uint256 sigDeadline)'\n\nconst ALLOW_REVERT_FLAG = 0x80\n\nconst REVERTABLE_COMMANDS = new Set<CommandType>([\n  CommandType.SEAPORT,\n  CommandType.NFTX,\n  CommandType.LOOKS_RARE_721,\n  CommandType.LOOKS_RARE_1155,\n  CommandType.X2Y2_721,\n  CommandType.X2Y2_1155,\n  CommandType.FOUNDATION,\n  CommandType.SUDOSWAP,\n  CommandType.NFT20,\n  CommandType.CRYPTOPUNKS,\n])\n\nconst ABI_DEFINITION: { [key in CommandType]: string[] } = {\n  [CommandType.PERMIT]: [PERMIT_STRUCT, 'bytes'],\n  [CommandType.PERMIT2_PERMIT_BATCH]: [PERMIT_BATCH_STRUCT, 'bytes'],\n  [CommandType.PERMIT2_TRANSFER_FROM]: ['address', 'address', 'uint160'],\n  [CommandType.PERMIT2_TRANSFER_FROM_BATCH]: ['bytes'],\n  [CommandType.TRANSFER]: ['address', 'address', 'uint256'],\n  [CommandType.V3_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\n  [CommandType.V3_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\n  [CommandType.V2_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\n  [CommandType.V2_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\n  [CommandType.SEAPORT]: ['uint256', 'bytes'],\n  [CommandType.WRAP_ETH]: ['address', 'uint256'],\n  [CommandType.UNWRAP_WETH]: ['address', 'uint256'],\n  [CommandType.SWEEP]: ['address', 'address', 'uint256'],\n  [CommandType.NFTX]: ['uint256', 'bytes'],\n  [CommandType.LOOKS_RARE_721]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.LOOKS_RARE_1155]: ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'],\n  [CommandType.X2Y2_721]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.X2Y2_1155]: ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'],\n  [CommandType.FOUNDATION]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.PAY_PORTION]: ['address', 'address', 'uint256'],\n  [CommandType.SUDOSWAP]: ['uint256', 'bytes'],\n  [CommandType.OWNER_CHECK_721]: ['address', 'address', 'uint256'],\n  [CommandType.OWNER_CHECK_1155]: ['address', 'address', 'uint256', 'uint256'],\n  [CommandType.NFT20]: ['uint256', 'bytes'],\n  [CommandType.CRYPTOPUNKS]: ['uint256', 'address', 'uint256'],\n}\n\nexport class RoutePlanner {\n  commands: string\n  inputs: string[]\n\n  constructor() {\n    this.commands = '0x'\n    this.inputs = []\n  }\n\n  addCommand(type: CommandType, parameters: any[], allowRevert = false): void {\n    let command = createCommand(type, parameters)\n    this.inputs.push(command.encodedInput)\n    if (allowRevert) {\n      if (!REVERTABLE_COMMANDS.has(command.type)) {\n        throw new Error(`command type: ${command.type} cannot be allowed to revert`)\n      }\n      command.type = command.type | ALLOW_REVERT_FLAG\n    }\n\n    this.commands = this.commands.concat(command.type.toString(16).padStart(2, '0'))\n  }\n}\n\nexport type RouterCommand = {\n  type: CommandType\n  encodedInput: string\n}\n\nexport function createCommand(type: CommandType, parameters: any[]): RouterCommand {\n  const encodedInput = defaultAbiCoder.encode(ABI_DEFINITION[type], parameters)\n  return { type, encodedInput }\n}\n","import { BigNumber } from 'ethers'\n\nexport const UNIVERSAL_ROUTER_ADDRESS = (chainId: number): string => {\n  switch (chainId) {\n    case 1: // mainnet\n      return '0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B'\n    case 5: // goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 137: // polygon\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5'\n    case 80001: // polygon mumbai\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 10: // optimism\n      return '0xb555edF5dcF85f42cEeF1f3630a52A108E55A654'\n    case 420: // optimism goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 42161: // arbitrum\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5'\n    case 421613: // arbitrum goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 42220: // celo\n      return '0xC73d61d192FB994157168Fb56730FdEc64C9Cb8F'\n    case 44787: // celo alfajores\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 56: // binance smart chain\n      return '0x5Dc88340E1c5c6366864Ee415d6034cadd1A9897'\n    default:\n      throw new Error(`Universal Router not deployed on chain ${chainId}`)\n  }\n}\n\nexport const WETH_ADDRESS = (chainId: number): string => {\n  switch (chainId) {\n    case 1: //mainnet\n      return '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'\n    case 5: // goerli\n      return '0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6'\n    case 137: // polygon\n      return '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270'\n    case 80001: // polygon mumbai\n      return '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889'\n    case 10: // optimism\n      return '0x4200000000000000000000000000000000000006'\n    case 420: // optimism goerli\n      return '0x4200000000000000000000000000000000000006'\n    case 42161: // arbitrum\n      return '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1'\n    case 421613: // arbitrum goerli\n      return '0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3'\n    case 56: // binance smart chain\n      return '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'\n    default:\n      throw new Error(`WETH9 or UniversalRouter not deployed on chain ${chainId}`)\n  }\n}\n\nexport const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3'\n\nexport const CONTRACT_BALANCE = BigNumber.from(2).pow(255)\nexport const ETH_ADDRESS = '0x0000000000000000000000000000000000000000'\n\nexport const SENDER_AS_RECIPIENT = '0x0000000000000000000000000000000000000001'\nexport const ROUTER_AS_RECIPIENT = '0x0000000000000000000000000000000000000002'\n","import JSBI from 'jsbi'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { Trade as V2Trade, Pair } from '@uniswap/v2-sdk'\nimport { Trade as V3Trade, Pool, encodeRouteToPath } from '@uniswap/v3-sdk'\nimport {\n  Trade as RouterTrade,\n  MixedRouteTrade,\n  Protocol,\n  IRoute,\n  RouteV2,\n  RouteV3,\n  MixedRouteSDK,\n  MixedRoute,\n  SwapOptions as RouterSwapOptions,\n  getOutputOfPools,\n  encodeMixedRouteToPath,\n  partitionMixedRouteByProtocol,\n} from '@uniswap/router-sdk'\nimport { Permit2Permit } from '../../utils/permit2'\nimport { Currency, TradeType, CurrencyAmount, Percent } from '@uniswap/sdk-core'\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\nimport { SENDER_AS_RECIPIENT, ROUTER_AS_RECIPIENT, CONTRACT_BALANCE } from '../../utils/constants'\n\n// the existing router permit object doesn't include enough data for permit2\n// so we extend swap options with the permit2 permit\nexport type SwapOptions = Omit<RouterSwapOptions, 'inputTokenPermit'> & {\n  inputTokenPermit?: Permit2Permit\n}\n\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(JSBI.BigInt(50), JSBI.BigInt(100))\n\ninterface Swap<TInput extends Currency, TOutput extends Currency> {\n  route: IRoute<TInput, TOutput, Pair | Pool>\n  inputAmount: CurrencyAmount<TInput>\n  outputAmount: CurrencyAmount<TOutput>\n}\n\n// Wrapper for uniswap router-sdk trade entity to encode swaps for Universal Router\n// also translates trade objects from previous (v2, v3) SDKs\nexport class UniswapTrade implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.UniswapTrade\n  constructor(public trade: RouterTrade<Currency, Currency, TradeType>, public options: SwapOptions) {}\n\n  encode(planner: RoutePlanner, _config: TradeConfig): void {\n    let payerIsUser = true\n    if (this.trade.inputAmount.currency.isNative) {\n      // TODO: optimize if only one v2 pool we can directly send this to the pool\n      planner.addCommand(CommandType.WRAP_ETH, [\n        ROUTER_AS_RECIPIENT,\n        this.trade.maximumAmountIn(this.options.slippageTolerance).quotient.toString(),\n      ])\n      // since WETH is now owned by the router, the router pays for inputs\n      payerIsUser = false\n    }\n    this.options.recipient = this.options.recipient ?? SENDER_AS_RECIPIENT\n\n    // flag for whether we want to perform slippage check on aggregate output of multiple routes\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck =\n      this.trade.tradeType === TradeType.EXACT_INPUT && this.trade.routes.length > 2\n    const outputIsNative = this.trade.outputAmount.currency.isNative\n    const inputIsNative = this.trade.inputAmount.currency.isNative\n    const routerMustCustody = performAggregatedSlippageCheck || outputIsNative\n\n    for (const swap of this.trade.swaps) {\n      switch (swap.route.protocol) {\n        case Protocol.V2:\n          addV2Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        case Protocol.V3:\n          addV3Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        case Protocol.MIXED:\n          addMixedSwap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        default:\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL')\n      }\n    }\n\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        planner.addCommand(CommandType.UNWRAP_WETH, [\n          this.options.recipient,\n          this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString(),\n        ])\n      } else {\n        planner.addCommand(CommandType.SWEEP, [\n          this.trade.outputAmount.currency.wrapped.address,\n          this.options.recipient,\n          this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString(),\n        ])\n      }\n    }\n\n    if (inputIsNative && (this.trade.tradeType === TradeType.EXACT_OUTPUT || riskOfPartialFill(this.trade))) {\n      // for exactOutput swaps that take native currency as input\n      // we need to send back the change to the user\n      planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, 0])\n    }\n  }\n}\n\n// encode a uniswap v2 swap\nfunction addV2Swap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const trade = new V2Trade(\n    route as RouteV2<TInput, TOutput>,\n    tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n    tradeType\n  )\n\n  if (tradeType == TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n      // if native, we have to unwrap so keep in the router for now\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      route.path.map((pool) => pool.address),\n      payerIsUser,\n    ])\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_OUT, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      route.path.map((pool) => pool.address),\n      payerIsUser,\n    ])\n  }\n}\n\n// encode a uniswap v3 swap\nfunction addV3Swap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const trade = V3Trade.createUncheckedTrade({\n    route: route as RouteV3<TInput, TOutput>,\n    inputAmount,\n    outputAmount,\n    tradeType,\n  })\n\n  const path = encodeRouteToPath(route as RouteV3<TInput, TOutput>, trade.tradeType === TradeType.EXACT_OUTPUT)\n  if (tradeType == TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      path,\n      payerIsUser,\n    ])\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_OUT, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      path,\n      payerIsUser,\n    ])\n  }\n}\n\n// encode a mixed route swap, i.e. including both v2 and v3 pools\nfunction addMixedSwap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  swap: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const { route, inputAmount, outputAmount } = swap\n  const tradeRecipient = routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient\n\n  // single hop, so it can be reduced to plain v2 or v3 swap logic\n  if (route.pools.length === 1) {\n    if (route.pools[0] instanceof Pool) {\n      return addV3Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\n    } else if (route.pools[0] instanceof Pair) {\n      return addV2Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\n    } else {\n      throw new Error('Invalid route type')\n    }\n  }\n\n  const trade = MixedRouteTrade.createUncheckedTrade({\n    route: route as MixedRoute<TInput, TOutput>,\n    inputAmount,\n    outputAmount,\n    tradeType,\n  })\n\n  const amountIn = trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient.toString()\n  const amountOut = trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient.toString()\n\n  // logic from\n  // https://github.com/Uniswap/router-sdk/blob/d8eed164e6c79519983844ca8b6a3fc24ebcb8f8/src/swapRouter.ts#L276\n  const sections = partitionMixedRouteByProtocol(route as MixedRoute<TInput, TOutput>)\n  const isLastSectionInRoute = (i: number) => {\n    return i === sections.length - 1\n  }\n\n  let outputToken\n  let inputToken = route.input.wrapped\n\n  for (let i = 0; i < sections.length; i++) {\n    const section = sections[i]\n    /// Now, we get output of this section\n    outputToken = getOutputOfPools(section, inputToken)\n\n    const newRouteOriginal = new MixedRouteSDK(\n      [...section],\n      section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1,\n      outputToken\n    )\n    const newRoute = new MixedRoute(newRouteOriginal)\n\n    /// Previous output is now input\n    inputToken = outputToken\n\n    const mixedRouteIsAllV3 = (route: MixedRouteSDK<Currency, Currency>) => {\n      return route.pools.every((pool) => pool instanceof Pool)\n    }\n\n    if (mixedRouteIsAllV3(newRoute)) {\n      const path: string = encodeMixedRouteToPath(newRoute)\n\n      planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n        // if not last section: send tokens directly to the first v2 pair of the next section\n        // note: because of the partitioning function we can be sure that the next section is v2\n        isLastSectionInRoute(i) ? tradeRecipient : (sections[i + 1][0] as Pair).liquidityToken.address,\n        i == 0 ? amountIn : CONTRACT_BALANCE, // amountIn\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOut\n        path, // path\n        payerIsUser && i === 0, // payerIsUser\n      ])\n    } else {\n      planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n        isLastSectionInRoute(i) ? tradeRecipient : ROUTER_AS_RECIPIENT, // recipient\n        i === 0 ? amountIn : CONTRACT_BALANCE, // amountIn\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOutMin\n        newRoute.path.map((pool) => pool.address), // path\n        payerIsUser && i === 0,\n      ])\n    }\n  }\n}\n\n// if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\nfunction riskOfPartialFill(trade: RouterTrade<Currency, Currency, TradeType>): boolean {\n  return trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n}\n","import { ethers } from 'ethers'\nimport { PermitSingle } from '@uniswap/permit2-sdk'\nimport { CommandType, RoutePlanner } from './routerCommands'\n\nexport interface Permit2Permit extends PermitSingle {\n  signature: string\n}\n\nconst SIGNATURE_LENGTH = 65\nconst EIP_2098_SIGNATURE_LENGTH = 64\n\nexport function encodePermit(planner: RoutePlanner, permit: Permit2Permit): void {\n  let signature = permit.signature\n\n  const length = ethers.utils.arrayify(permit.signature).length\n  // signature data provided for EIP-1271 may have length different from ECDSA signature\n  if (length === SIGNATURE_LENGTH || length === EIP_2098_SIGNATURE_LENGTH) {\n    // sanitizes signature to cover edge cases of malformed EIP-2098 sigs and v used as recovery id\n    signature = ethers.utils.joinSignature(ethers.utils.splitSignature(permit.signature))\n  }\n\n  planner.addCommand(CommandType.PERMIT, [permit, signature])\n}\n","import invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/universal-router/artifacts/contracts/UniversalRouter.sol/UniversalRouter.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { MethodParameters } from '@uniswap/v3-sdk'\nimport { Trade as RouterTrade } from '@uniswap/router-sdk'\nimport { Currency, TradeType } from '@uniswap/sdk-core'\nimport { Command, RouterTradeType } from './entities/Command'\nimport { NFTTrade, SupportedProtocolsData } from './entities/NFTTrade'\nimport { UniswapTrade, SwapOptions } from './entities/protocols/uniswap'\nimport { UnwrapWETH } from './entities/protocols/unwrapWETH'\nimport { CommandType, RoutePlanner } from './utils/routerCommands'\nimport { encodePermit } from './utils/permit2'\nimport { ROUTER_AS_RECIPIENT, SENDER_AS_RECIPIENT, ETH_ADDRESS } from './utils/constants'\n\nexport type SwapRouterConfig = {\n  sender?: string // address\n  deadline?: BigNumberish\n}\n\ntype SupportedNFTTrade = NFTTrade<SupportedProtocolsData>\n\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  public static swapCallParameters(trades: Command[] | Command, config: SwapRouterConfig = {}): MethodParameters {\n    if (!Array.isArray(trades)) trades = [trades]\n\n    const nftTrades = trades.filter((trade, _, []) => trade.hasOwnProperty('market')) as SupportedNFTTrade[]\n    const allowRevert = nftTrades.length == 1 && nftTrades[0].orders.length == 1 ? false : true\n    const planner = new RoutePlanner()\n\n    // track value flow to require the right amount of native value\n    let currentNativeValueInRouter = BigNumber.from(0)\n    let transactionValue = BigNumber.from(0)\n\n    for (const trade of trades) {\n      /**\n       * is NFTTrade\n       */\n      if (trade.tradeType == RouterTradeType.NFTTrade) {\n        const nftTrade = trade as SupportedNFTTrade\n        nftTrade.encode(planner, { allowRevert })\n        const tradePrice = nftTrade.getTotalPrice()\n\n        // send enough native value to contract for NFT purchase\n        if (currentNativeValueInRouter.lt(tradePrice)) {\n          transactionValue = transactionValue.add(tradePrice.sub(currentNativeValueInRouter))\n          currentNativeValueInRouter = BigNumber.from(0)\n        } else {\n          currentNativeValueInRouter = currentNativeValueInRouter.sub(tradePrice)\n        }\n        /**\n         * is Uniswap Trade\n         */\n      } else if (trade.tradeType == RouterTradeType.UniswapTrade) {\n        const uniswapTrade = trade as UniswapTrade\n        const inputIsNative = uniswapTrade.trade.inputAmount.currency.isNative\n        const outputIsNative = uniswapTrade.trade.outputAmount.currency.isNative\n        const swapOptions = uniswapTrade.options\n\n        invariant(!(inputIsNative && !!swapOptions.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\n\n        if (!!swapOptions.inputTokenPermit) {\n          encodePermit(planner, swapOptions.inputTokenPermit)\n        }\n\n        if (inputIsNative) {\n          transactionValue = transactionValue.add(\n            BigNumber.from(uniswapTrade.trade.maximumAmountIn(swapOptions.slippageTolerance).quotient.toString())\n          )\n        }\n        // track amount of native currency in the router\n        if (outputIsNative && swapOptions.recipient == ROUTER_AS_RECIPIENT) {\n          currentNativeValueInRouter = currentNativeValueInRouter.add(\n            BigNumber.from(uniswapTrade.trade.minimumAmountOut(swapOptions.slippageTolerance).quotient.toString())\n          )\n        }\n        uniswapTrade.encode(planner, { allowRevert: false })\n        /**\n         * is UnwrapWETH\n         */\n      } else if (trade.tradeType == RouterTradeType.UnwrapWETH) {\n        const UnwrapWETH = trade as UnwrapWETH\n        trade.encode(planner, { allowRevert: false })\n        currentNativeValueInRouter = currentNativeValueInRouter.add(UnwrapWETH.amount)\n        /**\n         * else\n         */\n      } else {\n        throw 'trade must be of instance: UniswapTrade or NFTTrade'\n      }\n    }\n\n    // TODO: matches current logic for now, but should eventually only sweep for multiple NFT trades\n    // or NFT trades with potential slippage (i.e. sudo)\n    if (nftTrades.length > 0) planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0])\n    return SwapRouter.encodePlan(planner, transactionValue, config)\n  }\n\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given swap.\n   * @param trades to produce call parameters for\n   */\n  public static swapNFTCallParameters(trades: SupportedNFTTrade[], config: SwapRouterConfig = {}): MethodParameters {\n    let planner = new RoutePlanner()\n    let totalPrice = BigNumber.from(0)\n\n    const allowRevert = trades.length == 1 && trades[0].orders.length == 1 ? false : true\n\n    for (const trade of trades) {\n      trade.encode(planner, { allowRevert })\n      totalPrice = totalPrice.add(trade.getTotalPrice())\n    }\n\n    planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0])\n    return SwapRouter.encodePlan(planner, totalPrice, config)\n  }\n\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapERC20CallParameters(\n    trades: RouterTrade<Currency, Currency, TradeType>,\n    options: SwapOptions\n  ): MethodParameters {\n    // TODO: use permit if signature included in swapOptions\n    const planner = new RoutePlanner()\n\n    const trade: UniswapTrade = new UniswapTrade(trades, options)\n\n    const inputCurrency = trade.trade.inputAmount.currency\n    invariant(!(inputCurrency.isNative && !!options.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\n\n    if (options.inputTokenPermit) {\n      encodePermit(planner, options.inputTokenPermit)\n    }\n\n    const nativeCurrencyValue = inputCurrency.isNative\n      ? BigNumber.from(trade.trade.maximumAmountIn(options.slippageTolerance).quotient.toString())\n      : BigNumber.from(0)\n\n    trade.encode(planner, { allowRevert: false })\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue, {\n      deadline: options.deadlineOrPreviousBlockhash ? BigNumber.from(options.deadlineOrPreviousBlockhash) : undefined,\n    })\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue)\n  }\n\n  /**\n   * Encodes a planned route into a method name and parameters for the Router contract.\n   * @param planner the planned route\n   * @param nativeCurrencyValue the native currency value of the planned route\n   * @param config the router config\n   */\n  private static encodePlan(\n    planner: RoutePlanner,\n    nativeCurrencyValue: BigNumber,\n    config: SwapRouterConfig = {}\n  ): MethodParameters {\n    const { commands, inputs } = planner\n    const functionSignature = !!config.deadline ? 'execute(bytes,bytes[],uint256)' : 'execute(bytes,bytes[])'\n    const parameters = !!config.deadline ? [commands, inputs, config.deadline] : [commands, inputs]\n    const calldata = SwapRouter.INTERFACE.encodeFunctionData(functionSignature, parameters)\n    return { calldata, value: nativeCurrencyValue.toHexString() }\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { SeaportData } from './protocols/seaport'\nimport { FoundationData } from './protocols/foundation'\nimport { NFTXData } from './protocols/nftx'\nimport { NFT20Data } from './protocols/nft20'\nimport { RoutePlanner } from '../utils/routerCommands'\nimport { Command, RouterTradeType, TradeConfig } from './Command'\nimport { LooksRareData } from './protocols/looksRare'\nimport { SudoswapData } from './protocols/sudoswap'\nimport { CryptopunkData } from './protocols/cryptopunk'\nimport { X2Y2Data } from './protocols/x2y2'\n\nexport type SupportedProtocolsData =\n  | SeaportData\n  | FoundationData\n  | NFTXData\n  | LooksRareData\n  | X2Y2Data\n  | CryptopunkData\n  | NFT20Data\n  | SudoswapData\n\nexport abstract class NFTTrade<T> implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.NFTTrade\n  readonly orders: T[]\n  readonly market: Market\n\n  constructor(market: Market, orders: T[]) {\n    invariant(orders.length > 0, 'no buy Items')\n    this.market = market\n    this.orders = orders\n  }\n\n  abstract encode(planner: RoutePlanner, config: TradeConfig): void\n\n  abstract getBuyItems(): BuyItem[]\n\n  abstract getTotalPrice(): BigNumber\n}\n\nexport type BuyItem = {\n  tokenAddress: string\n  tokenId: BigNumberish\n  tokenType: TokenType\n  amount?: BigNumberish // for 1155\n}\n\nexport enum Market {\n  Foundation = 'foundation',\n  LooksRare = 'looksrare',\n  NFT20 = 'nft20',\n  NFTX = 'nftx',\n  Seaport = 'seaport',\n  Sudoswap = 'Sudoswap',\n  Cryptopunks = 'cryptopunks',\n  X2Y2 = 'x2y2',\n}\n\nexport enum TokenType {\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155',\n  Cryptopunk = 'Cryptopunk',\n}\n","import { TradeConfig } from '../Command'\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type CryptopunkData = {\n  tokenId: BigNumberish\n  recipient: string\n  value: BigNumberish\n}\n\nexport class CryptopunkTrade extends NFTTrade<CryptopunkData> {\n  public static CRYPTOPUNK_ADDRESS: string = '0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb'\n\n  constructor(orders: CryptopunkData[]) {\n    super(Market.Cryptopunks, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      planner.addCommand(CommandType.CRYPTOPUNKS, [item.tokenId, item.recipient, item.value], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: CryptopunkTrade.CRYPTOPUNK_ADDRESS,\n        tokenId: item.tokenId,\n        tokenType: TokenType.Cryptopunk,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/Foundation.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type FoundationData = {\n  recipient: string\n  tokenAddress: string\n  tokenId: BigNumberish\n  price: BigNumberish\n  referrer: string // address\n}\n\nexport class FoundationTrade extends NFTTrade<FoundationData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: FoundationData[]) {\n    super(Market.Foundation, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const calldata = FoundationTrade.INTERFACE.encodeFunctionData('buyV2', [\n        item.tokenAddress,\n        item.tokenId,\n        item.price,\n        item.referrer,\n      ])\n      planner.addCommand(\n        CommandType.FOUNDATION,\n        [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\n        config.allowRevert\n      )\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: TokenType.ERC721,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.price)\n    }\n    return total\n  }\n}\n","import invariant from 'tiny-invariant'\nimport abi from '../../../abis/LooksRare.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type MakerOrder = {\n  collection: string\n  tokenId: BigNumberish\n  isOrderAsk: true\n  signer: string\n  strategy: string\n  currency: string\n  amount: BigNumberish\n  price: BigNumberish\n  minPercentageToAsk: BigNumberish\n  nonce: BigNumberish\n  startTime: BigNumberish\n  endTime: BigNumberish\n  v: BigNumberish\n  r: string\n  s: string\n  params: string\n}\n\nexport type TakerOrder = {\n  minPercentageToAsk: BigNumberish\n  price: BigNumberish\n  taker: string\n  tokenId: BigNumberish\n  isOrderAsk: boolean\n  params: string\n}\n\nexport type LooksRareData = {\n  makerOrder: MakerOrder\n  takerOrder: TakerOrder\n  recipient: string\n  tokenType: TokenType\n}\n\nexport class LooksRareTrade extends NFTTrade<LooksRareData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: LooksRareData[]) {\n    super(Market.LooksRare, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const calldata = LooksRareTrade.INTERFACE.encodeFunctionData('matchAskWithTakerBidUsingETHAndWETH', [\n        item.takerOrder,\n        item.makerOrder,\n      ])\n\n      if (item.tokenType == TokenType.ERC721) {\n        invariant(item.makerOrder.amount == 1, 'ERC721 token amount must be 1')\n        planner.addCommand(\n          CommandType.LOOKS_RARE_721,\n          [item.makerOrder.price, calldata, item.recipient, item.makerOrder.collection, item.makerOrder.tokenId],\n          config.allowRevert\n        )\n      } else if (item.tokenType == TokenType.ERC1155) {\n        planner.addCommand(\n          CommandType.LOOKS_RARE_1155,\n          [\n            item.makerOrder.price,\n            calldata,\n            item.recipient,\n            item.makerOrder.collection,\n            item.makerOrder.tokenId,\n            item.makerOrder.amount,\n          ],\n          config.allowRevert\n        )\n      }\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.makerOrder.collection,\n        tokenId: item.makerOrder.tokenId,\n        tokenType: item.tokenType,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.makerOrder.price)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/NFT20.json'\nimport { Interface } from '@ethersproject/abi'\nimport { TradeConfig } from '../Command'\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type NFT20Data = {\n  tokenAddress: string\n  tokenIds: BigNumberish[]\n  tokenAmounts: BigNumberish[]\n  recipient: string\n  fee: BigNumberish\n  isV3: boolean\n  value: BigNumberish\n}\n\nexport class NFT20Trade extends NFTTrade<NFT20Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: NFT20Data[]) {\n    super(Market.NFT20, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = NFT20Trade.INTERFACE.encodeFunctionData('ethForNft', [\n        order.tokenAddress,\n        order.tokenIds,\n        order.tokenAmounts,\n        order.recipient,\n        order.fee,\n        order.isV3,\n      ])\n      planner.addCommand(CommandType.NFT20, [order.value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const pool of this.orders) {\n      for (const tokenId of pool.tokenIds) {\n        buyItems.push({\n          tokenAddress: pool.tokenAddress,\n          tokenId: tokenId,\n          tokenType: TokenType.ERC721,\n        })\n      }\n    }\n\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/NFTXZap.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { Ether } from '@uniswap/sdk-core'\n\nexport type NFTXData = {\n  recipient: string\n  vaultAddress: string\n  vaultId: BigNumberish\n  tokenAddress: string\n  tokenIds: BigNumberish[]\n  value: BigNumber\n}\n\nexport class NFTXTrade extends NFTTrade<NFTXData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: NFTXData[]) {\n    super(Market.NFTX, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = NFTXTrade.INTERFACE.encodeFunctionData('buyAndRedeem', [\n        order.vaultId,\n        order.tokenIds.length,\n        order.tokenIds,\n        [Ether.onChain(1).wrapped.address, order.vaultAddress],\n        order.recipient,\n      ])\n      planner.addCommand(CommandType.NFTX, [order.value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const tokenId of order.tokenIds) {\n        buyItems.push({\n          tokenAddress: order.tokenAddress,\n          tokenId: tokenId,\n          tokenType: TokenType.ERC721,\n        })\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/Seaport.json'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\n\nexport type SeaportData = {\n  items: Order[]\n  recipient: string // address\n}\n\nexport type FulfillmentComponent = {\n  orderIndex: BigNumberish\n  itemIndex: BigNumberish\n}\n\nexport type OfferItem = {\n  itemType: BigNumberish // enum\n  token: string // address\n  identifierOrCriteria: BigNumberish\n  startAmount: BigNumberish\n  endAmount: BigNumberish\n}\n\nexport type ConsiderationItem = OfferItem & {\n  recipient: string\n}\n\nexport type Order = {\n  parameters: OrderParameters\n  signature: string\n}\n\ntype OrderParameters = {\n  offerer: string // address,\n  offer: OfferItem[]\n  consideration: ConsiderationItem[]\n  orderType: BigNumberish // enum\n  startTime: BigNumberish\n  endTime: BigNumberish\n  zoneHash: string // bytes32\n  zone: string // address\n  salt: BigNumberish\n  conduitKey: string // bytes32,\n  totalOriginalConsiderationItems: BigNumberish\n}\n\nexport type AdvancedOrder = Order & {\n  numerator: BigNumber // uint120\n  denominator: BigNumber // uint120\n  extraData: string // bytes\n}\n\nexport class SeaportTrade extends NFTTrade<SeaportData> {\n  public static INTERFACE: Interface = new Interface(abi)\n  public static OPENSEA_CONDUIT_KEY: string = '0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000'\n\n  constructor(orders: SeaportData[]) {\n    super(Market.Seaport, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      let advancedOrders: AdvancedOrder[] = []\n      let orderFulfillments: FulfillmentComponent[][] = order.items.map((_, index) => [\n        { orderIndex: index, itemIndex: 0 },\n      ])\n      let considerationFulFillments: FulfillmentComponent[][] = this.getConsiderationFulfillments(order.items)\n\n      for (const item of order.items) {\n        const { advancedOrder } = this.getAdvancedOrderParams(item)\n        advancedOrders.push(advancedOrder)\n      }\n\n      let calldata: string\n      if (advancedOrders.length == 1) {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAdvancedOrder', [\n          advancedOrders[0],\n          [],\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\n          order.recipient,\n        ])\n      } else {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAvailableAdvancedOrders', [\n          advancedOrders,\n          [],\n          orderFulfillments,\n          considerationFulFillments,\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\n          order.recipient,\n          100, // TODO: look into making this a better number\n        ])\n      }\n      planner.addCommand(CommandType.SEAPORT, [this.getTotalPrice().toString(), calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        for (const offer of item.parameters.offer) {\n          buyItems.push({\n            tokenAddress: offer.token,\n            tokenId: offer.identifierOrCriteria,\n            tokenType: TokenType.ERC721,\n          })\n        }\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let totalPrice = BigNumber.from(0)\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        totalPrice = totalPrice.add(this.calculateValue(item.parameters.consideration))\n      }\n    }\n    return totalPrice\n  }\n\n  private getConsiderationFulfillments(protocolDatas: Order[]): FulfillmentComponent[][] {\n    let considerationFulfillments: FulfillmentComponent[][] = []\n    const considerationRecipients: string[] = []\n\n    for (const i in protocolDatas) {\n      const protocolData = protocolDatas[i]\n\n      for (const j in protocolData.parameters.consideration) {\n        const item = protocolData.parameters.consideration[j]\n\n        if (considerationRecipients.findIndex((x) => x === item.recipient) === -1) {\n          considerationRecipients.push(item.recipient)\n        }\n\n        const recipientIndex = considerationRecipients.findIndex((x) => x === item.recipient)\n\n        if (!considerationFulfillments[recipientIndex]) {\n          considerationFulfillments.push([\n            {\n              orderIndex: i,\n              itemIndex: j,\n            },\n          ])\n        } else {\n          considerationFulfillments[recipientIndex].push({\n            orderIndex: i,\n            itemIndex: j,\n          })\n        }\n      }\n    }\n    return considerationFulfillments\n  }\n\n  private getAdvancedOrderParams(data: Order): { advancedOrder: AdvancedOrder; value: BigNumber } {\n    const advancedOrder = {\n      parameters: data.parameters,\n      numerator: BigNumber.from('1'),\n      denominator: BigNumber.from('1'),\n      signature: data.signature,\n      extraData: '0x00',\n    }\n    const value = this.calculateValue(data.parameters.consideration)\n    return { advancedOrder, value }\n  }\n\n  private calculateValue(considerations: ConsiderationItem[]): BigNumber {\n    return considerations.reduce(\n      (amt: BigNumber, consideration: ConsiderationItem) => amt.add(consideration.startAmount),\n      BigNumber.from(0)\n    )\n  }\n}\n","import abi from '../../../abis/Sudoswap.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\ntype PairSwap = {\n  swapInfo: {\n    pair: string // address\n    nftIds: BigNumberish[]\n  }\n  tokenAddress: string // address\n  maxCost: BigNumberish\n}\n\nexport type SudoswapData = {\n  swaps: PairSwap[]\n  nftRecipient: string\n  ethRecipient: string\n  deadline: BigNumberish\n}\n\nexport class SudoswapTrade extends NFTTrade<SudoswapData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: SudoswapData[]) {\n    super(Market.Sudoswap, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = SudoswapTrade.INTERFACE.encodeFunctionData('robustSwapETHForSpecificNFTs', [\n        order.swaps.map((swap) => {\n          return { swapInfo: swap.swapInfo, maxCost: swap.maxCost }\n        }),\n        order.ethRecipient,\n        order.nftRecipient,\n        order.deadline,\n      ])\n      const value = order.swaps.reduce((prevVal, swap) => {\n        return prevVal.add(swap.maxCost)\n      }, BigNumber.from(0))\n      planner.addCommand(CommandType.SUDOSWAP, [value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const swap of order.swaps) {\n        for (const tokenId of swap.swapInfo.nftIds) {\n          buyItems.push({\n            tokenAddress: swap.tokenAddress,\n            tokenId,\n            tokenType: TokenType.ERC721,\n          })\n        }\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const order of this.orders) {\n      for (const swap of order.swaps) {\n        total = total.add(swap.maxCost)\n      }\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/X2Y2.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\ntype X2Y2PartialData = {\n  signedInput: string\n  recipient: string\n  tokenAddress: string\n  tokenId: BigNumberish\n  price: BigNumberish\n}\n\nexport type X2Y2_721_Data = X2Y2PartialData & {\n  tokenType: TokenType.ERC721\n}\n\nexport type X2Y2_1155_Data = X2Y2PartialData & {\n  tokenType: TokenType.ERC1155\n  tokenAmount: BigNumberish\n}\n\nexport type X2Y2Data = X2Y2_721_Data | X2Y2_1155_Data\n\nexport class X2Y2Trade extends NFTTrade<X2Y2Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: X2Y2Data[]) {\n    super(Market.X2Y2, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const functionSelector = X2Y2Trade.INTERFACE.getSighash(X2Y2Trade.INTERFACE.getFunction('run'))\n      const calldata = functionSelector + item.signedInput.slice(2)\n\n      if (item.tokenType == TokenType.ERC721) {\n        planner.addCommand(\n          CommandType.X2Y2_721,\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\n          config.allowRevert\n        )\n      } else if (item.tokenType == TokenType.ERC1155) {\n        planner.addCommand(\n          CommandType.X2Y2_1155,\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId, item.tokenAmount],\n          config.allowRevert\n        )\n      }\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: item.tokenType,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.price)\n    }\n    return total\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { BigNumberish } from 'ethers'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { Permit2Permit } from '../../utils/permit2'\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\nimport { encodePermit } from '../../utils/permit2'\nimport { ROUTER_AS_RECIPIENT, UNIVERSAL_ROUTER_ADDRESS, WETH_ADDRESS } from '../../utils/constants'\n\nexport class UnwrapWETH implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.UnwrapWETH\n  readonly permit2Data: Permit2Permit\n  readonly wethAddress: string\n  readonly routerAddress: string\n  readonly amount: BigNumberish\n\n  constructor(amount: BigNumberish, chainId: number, permit2?: Permit2Permit) {\n    this.wethAddress = WETH_ADDRESS(chainId)\n    this.routerAddress = UNIVERSAL_ROUTER_ADDRESS(chainId)\n    this.amount = amount\n\n    if (!!permit2) {\n      invariant(permit2.details.token === this.wethAddress, `must be permitting WETH address: ${this.wethAddress}`)\n      invariant(permit2.details.amount >= amount, `Did not permit enough WETH for unwrapWETH transaction`)\n      this.permit2Data = permit2\n    }\n  }\n\n  encode(planner: RoutePlanner, _: TradeConfig): void {\n    if (!!this.permit2Data) encodePermit(planner, this.permit2Data)\n    planner.addCommand(CommandType.PERMIT2_TRANSFER_FROM, [this.wethAddress, this.routerAddress, this.amount])\n    planner.addCommand(CommandType.UNWRAP_WETH, [ROUTER_AS_RECIPIENT, this.amount])\n  }\n}\n"]},"metadata":{},"sourceType":"script"}