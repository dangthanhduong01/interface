{"ast":null,"code":"import { defaultAbiCoder } from '@ethersproject/abi';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { hexZeroPad } from '@ethersproject/bytes';\nimport { AddressZero } from '@ethersproject/constants';\nimport { keccak256 } from '@ethersproject/keccak256';\nimport { randomBytes } from '@ethersproject/random';\nimport { NftStandard } from 'graphql/data/__generated__/types-and-hooks';\nconst dataParamType = `tuple(address token, uint256 tokenId, uint256 amount)[]`;\nconst orderItemParamType = `tuple(uint256 price, bytes data)`;\nconst orderParamTypes = [`uint256`, `address`, `uint256`, `uint256`, `uint256`, `uint256`, `address`, `bytes`, `uint256`, `${orderItemParamType}[]`];\nconst orderParamType = `tuple(uint256 salt, address user, uint256 network, uint256 intent, uint256 delegateType, uint256 deadline, address currency, bytes dataMask, ${orderItemParamType}[] items, bytes32 r, bytes32 s, uint8 v, uint8 signVersion)`;\nconst randomSalt = () => {\n  const randomHex = BigNumber.from(randomBytes(16)).toHexString();\n  return hexZeroPad(randomHex, 64);\n};\nconst encodeItemData = data => {\n  return defaultAbiCoder.encode([dataParamType], [data]);\n};\nexport const signOrderData = async (web3Provider, order) => {\n  const orderData = defaultAbiCoder.encode(orderParamTypes, [order.salt, order.user, order.network, order.intent, order.delegateType, order.deadline, order.currency, order.dataMask, order.items.length, order.items]);\n  const orderHash = keccak256(orderData);\n  const orderSig = await web3Provider.send('personal_sign', [orderHash, order.user]);\n  order.r = `0x${orderSig.slice(2, 66)}`;\n  order.s = `0x${orderSig.slice(66, 130)}`;\n  order.v = parseInt(orderSig.slice(130, 132), 16);\n  fixSignature(order);\n};\nconst fixSignature = data => {\n  // in geth its always 27/28, in ganache its 0/1. Change to 27/28 to prevent\n  // signature malleability if version is 0/1\n  // see https://github.com/ethereum/go-ethereum/blob/v1.8.23/internal/ethapi/api.go#L465\n  if (data.v < 27) {\n    data.v = data.v + 27;\n  }\n};\nexport const encodeOrder = order => {\n  return defaultAbiCoder.encode([orderParamType], [order]);\n};\nexport const createSellOrder = function (user, deadline, items) {\n  let nftStandard = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NftStandard.Erc721;\n  const salt = randomSalt();\n  const network = 1; // mainnet\n  const intent = 1; // INTENT_SELL\n  const delegateType = nftStandard === NftStandard.Erc721 ? 1 : 2;\n  const currency = AddressZero; // ETH\n  return {\n    salt,\n    user,\n    network,\n    intent,\n    delegateType,\n    deadline,\n    currency,\n    dataMask: '0x',\n    items: items.map(item => ({\n      price: item.price,\n      data: encodeItemData(item.tokens)\n    })),\n    r: '',\n    s: '',\n    v: 0,\n    signVersion: 1\n  };\n};","map":{"version":3,"names":["defaultAbiCoder","BigNumber","hexZeroPad","AddressZero","keccak256","randomBytes","NftStandard","dataParamType","orderItemParamType","orderParamTypes","orderParamType","randomSalt","randomHex","from","toHexString","encodeItemData","data","encode","signOrderData","web3Provider","order","orderData","salt","user","network","intent","delegateType","deadline","currency","dataMask","items","length","orderHash","orderSig","send","r","slice","s","v","parseInt","fixSignature","encodeOrder","createSellOrder","nftStandard","Erc721","map","item","price","tokens","signVersion"],"sources":["/home/diep/freelance/interface/src/nft/utils/x2y2.ts"],"sourcesContent":["import { defaultAbiCoder } from '@ethersproject/abi'\nimport { BigNumber, BigNumberish } from '@ethersproject/bignumber'\nimport { hexZeroPad } from '@ethersproject/bytes'\nimport { AddressZero } from '@ethersproject/constants'\nimport { keccak256 } from '@ethersproject/keccak256'\nimport type { Web3Provider } from '@ethersproject/providers'\nimport { randomBytes } from '@ethersproject/random'\nimport { NftStandard } from 'graphql/data/__generated__/types-and-hooks'\n\nconst dataParamType = `tuple(address token, uint256 tokenId, uint256 amount)[]`\nconst orderItemParamType = `tuple(uint256 price, bytes data)`\nconst orderParamTypes = [\n  `uint256`,\n  `address`,\n  `uint256`,\n  `uint256`,\n  `uint256`,\n  `uint256`,\n  `address`,\n  `bytes`,\n  `uint256`,\n  `${orderItemParamType}[]`,\n]\nconst orderParamType = `tuple(uint256 salt, address user, uint256 network, uint256 intent, uint256 delegateType, uint256 deadline, address currency, bytes dataMask, ${orderItemParamType}[] items, bytes32 r, bytes32 s, uint8 v, uint8 signVersion)`\n\nexport type OfferItem = {\n  price: BigNumber\n  tokens: {\n    token: string\n    tokenId: BigNumberish\n    amount: number\n  }[]\n}\n\ntype OrderItem = {\n  price: BigNumberish\n  data: string\n}\n\ntype Order = {\n  salt: BigNumberish\n  user: string\n  network: BigNumberish\n  intent: BigNumberish\n  delegateType: BigNumberish\n  deadline: BigNumberish\n  currency: string\n  dataMask: string\n  items: OrderItem[]\n  // signature\n  r: string\n  s: string\n  v: number\n  signVersion: number\n}\n\nexport type OrderPayload = {\n  order: string\n  isBundle: boolean\n  bundleName: string\n  bundleDesc: string\n  orderIds: number[]\n  changePrice: boolean\n  isCollection: boolean\n}\n\nconst randomSalt = () => {\n  const randomHex = BigNumber.from(randomBytes(16)).toHexString()\n  return hexZeroPad(randomHex, 64)\n}\n\nconst encodeItemData = (data: { token: string; tokenId: BigNumberish; amount: number }[]) => {\n  return defaultAbiCoder.encode([dataParamType], [data])\n}\n\nexport const signOrderData = async (web3Provider: Web3Provider, order: Order) => {\n  const orderData = defaultAbiCoder.encode(orderParamTypes, [\n    order.salt,\n    order.user,\n    order.network,\n    order.intent,\n    order.delegateType,\n    order.deadline,\n    order.currency,\n    order.dataMask,\n    order.items.length,\n    order.items,\n  ])\n  const orderHash = keccak256(orderData)\n  const orderSig = (await web3Provider.send('personal_sign', [orderHash, order.user])) as string\n  order.r = `0x${orderSig.slice(2, 66)}`\n  order.s = `0x${orderSig.slice(66, 130)}`\n  order.v = parseInt(orderSig.slice(130, 132), 16)\n  fixSignature(order)\n}\n\nconst fixSignature = (data: Order) => {\n  // in geth its always 27/28, in ganache its 0/1. Change to 27/28 to prevent\n  // signature malleability if version is 0/1\n  // see https://github.com/ethereum/go-ethereum/blob/v1.8.23/internal/ethapi/api.go#L465\n  if (data.v < 27) {\n    data.v = data.v + 27\n  }\n}\n\nexport const encodeOrder = (order: Order): string => {\n  return defaultAbiCoder.encode([orderParamType], [order])\n}\n\nexport const createSellOrder = (\n  user: string,\n  deadline: number,\n  items: OfferItem[],\n  nftStandard: NftStandard = NftStandard.Erc721\n): Order => {\n  const salt = randomSalt()\n  const network = 1 // mainnet\n  const intent = 1 // INTENT_SELL\n  const delegateType = nftStandard === NftStandard.Erc721 ? 1 : 2\n  const currency = AddressZero // ETH\n  return {\n    salt,\n    user,\n    network,\n    intent,\n    delegateType,\n    deadline,\n    currency,\n    dataMask: '0x',\n    items: items.map((item) => ({\n      price: item.price,\n      data: encodeItemData(item.tokens),\n    })),\n    r: '',\n    s: '',\n    v: 0,\n    signVersion: 1,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}