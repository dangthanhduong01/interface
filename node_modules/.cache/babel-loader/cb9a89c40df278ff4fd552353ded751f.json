{"ast":null,"code":"var _s = $RefreshSig$();\nimport { WRAPPED_NATIVE_CURRENCY } from 'constants/tokens';\nimport gql from 'graphql-tag';\nimport { useMemo } from 'react';\nimport { Chain, useSearchTokensQuery } from './__generated__/types-and-hooks';\nimport { chainIdToBackendName } from './util';\ngql`\n  query SearchTokens($searchQuery: String!) {\n    searchTokens(searchQuery: $searchQuery) {\n      id\n      decimals\n      name\n      chain\n      standard\n      address\n      symbol\n      market(currency: USD) {\n        id\n        price {\n          id\n          value\n          currency\n        }\n        pricePercentChange(duration: DAY) {\n          id\n          value\n        }\n        volume24H: volume(duration: DAY) {\n          id\n          value\n          currency\n        }\n      }\n      project {\n        id\n        logoUrl\n        safetyLevel\n      }\n    }\n  }\n`;\nfunction isMoreRevelantToken(current, existing, searchChain) {\n  if (!existing) return true;\n\n  // Always priotize natives, and if both tokens are native, prefer native on current chain (i.e. Matic on Polygon over Matic on Mainnet )\n  if (current.standard === 'NATIVE' && (existing.standard !== 'NATIVE' || current.chain === searchChain)) return true;\n\n  // Prefer tokens on the searched chain, otherwise prefer mainnet tokens\n  return current.chain === searchChain || existing.chain !== searchChain && current.chain === Chain.Ethereum;\n}\n\n// Places natives first, wrapped native on current chain next, then sorts by volume\nfunction searchTokenSortFunction(searchChain, wrappedNativeAddress, a, b) {\n  var _b$market$volume24H$v, _b$market, _b$market$volume24H, _a$market$volume24H$v, _a$market, _a$market$volume24H;\n  if (a.standard === 'NATIVE') {\n    if (b.standard === 'NATIVE') {\n      if (a.chain === searchChain) return -1;else if (b.chain === searchChain) return 1;else return 0;\n    } else return -1;\n  } else if (b.standard === 'NATIVE') return 1;else if (wrappedNativeAddress && a.address === wrappedNativeAddress) return -1;else if (wrappedNativeAddress && b.address === wrappedNativeAddress) return 1;else return ((_b$market$volume24H$v = (_b$market = b.market) === null || _b$market === void 0 ? void 0 : (_b$market$volume24H = _b$market.volume24H) === null || _b$market$volume24H === void 0 ? void 0 : _b$market$volume24H.value) !== null && _b$market$volume24H$v !== void 0 ? _b$market$volume24H$v : 0) - ((_a$market$volume24H$v = (_a$market = a.market) === null || _a$market === void 0 ? void 0 : (_a$market$volume24H = _a$market.volume24H) === null || _a$market$volume24H === void 0 ? void 0 : _a$market$volume24H.value) !== null && _a$market$volume24H$v !== void 0 ? _a$market$volume24H$v : 0);\n}\nexport function useSearchTokens(searchQuery, chainId) {\n  _s();\n  const {\n    data,\n    loading,\n    error\n  } = useSearchTokensQuery({\n    variables: {\n      searchQuery\n    },\n    skip: !searchQuery\n  });\n  const sortedTokens = useMemo(() => {\n    var _data$searchTokens, _WRAPPED_NATIVE_CURRE;\n    const searchChain = chainIdToBackendName(chainId);\n    // Stores results, allowing overwriting cross-chain tokens w/ more 'relevant token'\n    const selectionMap = {};\n    data === null || data === void 0 ? void 0 : (_data$searchTokens = data.searchTokens) === null || _data$searchTokens === void 0 ? void 0 : _data$searchTokens.forEach(token => {\n      var _token$project;\n      if ((_token$project = token.project) === null || _token$project === void 0 ? void 0 : _token$project.id) {\n        const existing = selectionMap[token.project.id];\n        if (isMoreRevelantToken(token, existing, searchChain)) selectionMap[token.project.id] = token;\n      }\n    });\n    return Object.values(selectionMap).sort(searchTokenSortFunction.bind(null, searchChain, (_WRAPPED_NATIVE_CURRE = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _WRAPPED_NATIVE_CURRE === void 0 ? void 0 : _WRAPPED_NATIVE_CURRE.address));\n  }, [data, chainId]);\n  return {\n    data: sortedTokens,\n    loading,\n    error\n  };\n}\n_s(useSearchTokens, \"UsEwDA3vwP3HlQ36itm0vY/jwyQ=\", false, function () {\n  return [useSearchTokensQuery];\n});","map":{"version":3,"names":["WRAPPED_NATIVE_CURRENCY","gql","useMemo","Chain","useSearchTokensQuery","chainIdToBackendName","isMoreRevelantToken","current","existing","searchChain","standard","chain","Ethereum","searchTokenSortFunction","wrappedNativeAddress","a","b","address","market","volume24H","value","useSearchTokens","searchQuery","chainId","data","loading","error","variables","skip","sortedTokens","selectionMap","searchTokens","forEach","token","project","id","Object","values","sort","bind"],"sources":["/home/diep/freelance/interface/src/graphql/data/SearchTokens.ts"],"sourcesContent":["import { WRAPPED_NATIVE_CURRENCY } from 'constants/tokens'\nimport gql from 'graphql-tag'\nimport { useMemo } from 'react'\n\nimport { Chain, SearchTokensQuery, useSearchTokensQuery } from './__generated__/types-and-hooks'\nimport { chainIdToBackendName } from './util'\n\ngql`\n  query SearchTokens($searchQuery: String!) {\n    searchTokens(searchQuery: $searchQuery) {\n      id\n      decimals\n      name\n      chain\n      standard\n      address\n      symbol\n      market(currency: USD) {\n        id\n        price {\n          id\n          value\n          currency\n        }\n        pricePercentChange(duration: DAY) {\n          id\n          value\n        }\n        volume24H: volume(duration: DAY) {\n          id\n          value\n          currency\n        }\n      }\n      project {\n        id\n        logoUrl\n        safetyLevel\n      }\n    }\n  }\n`\n\nexport type SearchToken = NonNullable<NonNullable<SearchTokensQuery['searchTokens']>[number]>\n\nfunction isMoreRevelantToken(current: SearchToken, existing: SearchToken | undefined, searchChain: Chain) {\n  if (!existing) return true\n\n  // Always priotize natives, and if both tokens are native, prefer native on current chain (i.e. Matic on Polygon over Matic on Mainnet )\n  if (current.standard === 'NATIVE' && (existing.standard !== 'NATIVE' || current.chain === searchChain)) return true\n\n  // Prefer tokens on the searched chain, otherwise prefer mainnet tokens\n  return current.chain === searchChain || (existing.chain !== searchChain && current.chain === Chain.Ethereum)\n}\n\n// Places natives first, wrapped native on current chain next, then sorts by volume\nfunction searchTokenSortFunction(\n  searchChain: Chain,\n  wrappedNativeAddress: string | undefined,\n  a: SearchToken,\n  b: SearchToken\n) {\n  if (a.standard === 'NATIVE') {\n    if (b.standard === 'NATIVE') {\n      if (a.chain === searchChain) return -1\n      else if (b.chain === searchChain) return 1\n      else return 0\n    } else return -1\n  } else if (b.standard === 'NATIVE') return 1\n  else if (wrappedNativeAddress && a.address === wrappedNativeAddress) return -1\n  else if (wrappedNativeAddress && b.address === wrappedNativeAddress) return 1\n  else return (b.market?.volume24H?.value ?? 0) - (a.market?.volume24H?.value ?? 0)\n}\n\nexport function useSearchTokens(searchQuery: string, chainId: number) {\n  const { data, loading, error } = useSearchTokensQuery({\n    variables: {\n      searchQuery,\n    },\n    skip: !searchQuery,\n  })\n\n  const sortedTokens = useMemo(() => {\n    const searchChain = chainIdToBackendName(chainId)\n    // Stores results, allowing overwriting cross-chain tokens w/ more 'relevant token'\n    const selectionMap: { [projectId: string]: SearchToken } = {}\n    data?.searchTokens?.forEach((token) => {\n      if (token.project?.id) {\n        const existing = selectionMap[token.project.id]\n        if (isMoreRevelantToken(token, existing, searchChain)) selectionMap[token.project.id] = token\n      }\n    })\n    return Object.values(selectionMap).sort(\n      searchTokenSortFunction.bind(null, searchChain, WRAPPED_NATIVE_CURRENCY[chainId]?.address)\n    )\n  }, [data, chainId])\n\n  return {\n    data: sortedTokens,\n    loading,\n    error,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}