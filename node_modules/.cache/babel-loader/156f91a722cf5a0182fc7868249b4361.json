{"ast":null,"code":"import { parseRetryAfterHeader, logger, envelopeContainsItemType } from '@sentry/utils';\nconst MIN_DELAY = 100; // 100 ms\nconst START_DELAY = 5000; // 5 seconds\nconst MAX_DELAY = 3.6e6; // 1 hour\n\nfunction log(msg, error) {\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.info(`[Offline]: ${msg}`, error);\n}\n\n/**\n * Wraps a transport and stores and retries events when they fail to send.\n *\n * @param createTransport The transport to wrap.\n */\nfunction makeOfflineTransport(createTransport) {\n  return options => {\n    const transport = createTransport(options);\n    const store = options.createStore ? options.createStore(options) : undefined;\n    let retryDelay = START_DELAY;\n    let flushTimer;\n    function shouldQueue(env, error, retryDelay) {\n      // We don't queue Session Replay envelopes because they are:\n      // - Ordered and Replay relies on the response status to know when they're successfully sent.\n      // - Likely to fill the queue quickly and block other events from being sent.\n      // We also want to drop client reports because they can be generated when we retry sending events while offline.\n      if (envelopeContainsItemType(env, ['replay_event', 'replay_recording', 'client_report'])) {\n        return false;\n      }\n      if (options.shouldStore) {\n        return options.shouldStore(env, error, retryDelay);\n      }\n      return true;\n    }\n    function flushIn(delay) {\n      if (!store) {\n        return;\n      }\n      if (flushTimer) {\n        clearTimeout(flushTimer);\n      }\n      flushTimer = setTimeout(async () => {\n        flushTimer = undefined;\n        const found = await store.pop();\n        if (found) {\n          log('Attempting to send previously queued event');\n          void send(found).catch(e => {\n            log('Failed to retry sending', e);\n          });\n        }\n      }, delay);\n\n      // We need to unref the timer in node.js, otherwise the node process never exit.\n      if (typeof flushTimer !== 'number' && flushTimer.unref) {\n        flushTimer.unref();\n      }\n    }\n    function flushWithBackOff() {\n      if (flushTimer) {\n        return;\n      }\n      flushIn(retryDelay);\n      retryDelay = Math.min(retryDelay * 2, MAX_DELAY);\n    }\n    async function send(envelope) {\n      try {\n        const result = await transport.send(envelope);\n        let delay = MIN_DELAY;\n        if (result) {\n          // If there's a retry-after header, use that as the next delay.\n          if (result.headers && result.headers['retry-after']) {\n            delay = parseRetryAfterHeader(result.headers['retry-after']);\n          } // If we have a server error, return now so we don't flush the queue.\n          else if ((result.statusCode || 0) >= 400) {\n            return result;\n          }\n        }\n        flushIn(delay);\n        retryDelay = START_DELAY;\n        return result;\n      } catch (e) {\n        if (store && (await shouldQueue(envelope, e, retryDelay))) {\n          await store.insert(envelope);\n          flushWithBackOff();\n          log('Error sending. Event queued', e);\n          return {};\n        } else {\n          throw e;\n        }\n      }\n    }\n    if (options.flushAtStartup) {\n      flushWithBackOff();\n    }\n    return {\n      send,\n      flush: t => transport.flush(t)\n    };\n  };\n}\nexport { MIN_DELAY, START_DELAY, makeOfflineTransport };","map":{"version":3,"sources":["../../../src/transports/offline.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Envelope, InternalBaseTransportOptions, Transport, TransportMakeRequestResponse } from '@sentry/types';\nimport { envelopeContainsItemType, logger, parseRetryAfterHeader } from '@sentry/utils';\n\nexport const MIN_DELAY = 100; // 100 ms\nexport const START_DELAY = 5_000; // 5 seconds\nconst MAX_DELAY = 3.6e6; // 1 hour\n\nfunction log(msg: string, error?: Error): void {\n  __DEBUG_BUILD__ && logger.info(`[Offline]: ${msg}`, error);\n}\n\nexport interface OfflineStore {\n  insert(env: Envelope): Promise<void>;\n  pop(): Promise<Envelope | undefined>;\n}\n\nexport type CreateOfflineStore = (options: OfflineTransportOptions) => OfflineStore;\n\nexport interface OfflineTransportOptions extends InternalBaseTransportOptions {\n  /**\n   * A function that creates the offline store instance.\n   */\n  createStore?: CreateOfflineStore;\n\n  /**\n   * Flush the offline store shortly after startup.\n   *\n   * Defaults: false\n   */\n  flushAtStartup?: boolean;\n\n  /**\n   * Called before an event is stored.\n   *\n   * Return false to drop the envelope rather than store it.\n   *\n   * @param envelope The envelope that failed to send.\n   * @param error The error that occurred.\n   * @param retryDelay The current retry delay in milliseconds.\n   */\n  shouldStore?: (envelope: Envelope, error: Error, retryDelay: number) => boolean | Promise<boolean>;\n}\n\ntype Timer = number | { unref?: () => void };\n\n/**\n * Wraps a transport and stores and retries events when they fail to send.\n *\n * @param createTransport The transport to wrap.\n */\nexport function makeOfflineTransport<TO>(\n  createTransport: (options: TO) => Transport,\n): (options: TO & OfflineTransportOptions) => Transport {\n  return options => {\n    const transport = createTransport(options);\n    const store = options.createStore ? options.createStore(options) : undefined;\n\n    let retryDelay = START_DELAY;\n    let flushTimer: Timer | undefined;\n\n    function shouldQueue(env: Envelope, error: Error, retryDelay: number): boolean | Promise<boolean> {\n      // We don't queue Session Replay envelopes because they are:\n      // - Ordered and Replay relies on the response status to know when they're successfully sent.\n      // - Likely to fill the queue quickly and block other events from being sent.\n      // We also want to drop client reports because they can be generated when we retry sending events while offline.\n      if (envelopeContainsItemType(env, ['replay_event', 'replay_recording', 'client_report'])) {\n        return false;\n      }\n\n      if (options.shouldStore) {\n        return options.shouldStore(env, error, retryDelay);\n      }\n\n      return true;\n    }\n\n    function flushIn(delay: number): void {\n      if (!store) {\n        return;\n      }\n\n      if (flushTimer) {\n        clearTimeout(flushTimer as ReturnType<typeof setTimeout>);\n      }\n\n      flushTimer = setTimeout(async () => {\n        flushTimer = undefined;\n\n        const found = await store.pop();\n        if (found) {\n          log('Attempting to send previously queued event');\n          void send(found).catch(e => {\n            log('Failed to retry sending', e);\n          });\n        }\n      }, delay) as Timer;\n\n      // We need to unref the timer in node.js, otherwise the node process never exit.\n      if (typeof flushTimer !== 'number' && flushTimer.unref) {\n        flushTimer.unref();\n      }\n    }\n\n    function flushWithBackOff(): void {\n      if (flushTimer) {\n        return;\n      }\n\n      flushIn(retryDelay);\n\n      retryDelay = Math.min(retryDelay * 2, MAX_DELAY);\n    }\n\n    async function send(envelope: Envelope): Promise<void | TransportMakeRequestResponse> {\n      try {\n        const result = await transport.send(envelope);\n\n        let delay = MIN_DELAY;\n\n        if (result) {\n          // If there's a retry-after header, use that as the next delay.\n          if (result.headers && result.headers['retry-after']) {\n            delay = parseRetryAfterHeader(result.headers['retry-after']);\n          } // If we have a server error, return now so we don't flush the queue.\n          else if ((result.statusCode || 0) >= 400) {\n            return result;\n          }\n        }\n\n        flushIn(delay);\n        retryDelay = START_DELAY;\n        return result;\n      } catch (e) {\n        if (store && (await shouldQueue(envelope, e, retryDelay))) {\n          await store.insert(envelope);\n          flushWithBackOff();\n          log('Error sending. Event queued', e);\n          return {};\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    if (options.flushAtStartup) {\n      flushWithBackOff();\n    }\n\n    return {\n      send,\n      flush: t => transport.flush(t),\n    };\n  };\n}\n"]},"metadata":{},"sourceType":"module"}