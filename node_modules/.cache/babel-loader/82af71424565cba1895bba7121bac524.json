{"ast":null,"code":"const STACKTRACE_FRAME_LIMIT = 50;\n// Used to sanitize webpack (error: *) wrapped stack errors\nconst WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nfunction createStackParser() {\n  for (var _len = arguments.length, parsers = new Array(_len), _key = 0; _key < _len; _key++) {\n    parsers[_key] = arguments[_key];\n  }\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n  return function (stack) {\n    let skipFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const frames = [];\n    const lines = stack.split('\\n');\n    for (let i = skipFirst; i < lines.length; i++) {\n      const line = lines[i];\n      // Ignore lines over 1kb as they are unlikely to be stack frames.\n      // Many of the regular expressions use backtracking which results in run time that increases exponentially with\n      // input size. Huge strings can result in hangs/Denial of Service:\n      // https://github.com/getsentry/sentry-javascript/issues/2286\n      if (line.length > 1024) {\n        continue;\n      }\n\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;\n      for (const parser of sortedParsers) {\n        const frame = parser(cleanedLine);\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n      if (frames.length >= STACKTRACE_FRAME_LIMIT) {\n        break;\n      }\n    }\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nfunction stackParserFromStackParserOptions(stackParser) {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * Removes Sentry frames from the top and bottom of the stack if present and enforces a limit of max number of frames.\n * Assumes stack input is ordered from top to bottom and returns the reverse representation so call site of the\n * function that caused the crash is the last frame in the array.\n * @hidden\n */\nfunction stripSentryFramesAndReverse(stack) {\n  if (!stack.length) {\n    return [];\n  }\n  const localStack = stack.slice(0, STACKTRACE_FRAME_LIMIT);\n  const lastFrameFunction = localStack[localStack.length - 1].function;\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (lastFrameFunction && /sentryWrapped/.test(lastFrameFunction)) {\n    localStack.pop();\n  }\n\n  // Reversing in the middle of the procedure allows us to just pop the values off the stack\n  localStack.reverse();\n  const firstFrameFunction = localStack[localStack.length - 1].function;\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (firstFrameFunction && /captureMessage|captureException/.test(firstFrameFunction)) {\n    localStack.pop();\n  }\n  return localStack.map(frame => ({\n    ...frame,\n    filename: frame.filename || localStack[localStack.length - 1].filename,\n    function: frame.function || '?'\n  }));\n}\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nfunction getFunctionName(fn) {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\n// eslint-disable-next-line complexity\nfunction node(getModule) {\n  const FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n  // eslint-disable-next-line complexity\n  return line => {\n    const lineMatch = line.match(FULL_MATCH);\n    if (lineMatch) {\n      let object;\n      let method;\n      let functionName;\n      let typeName;\n      let methodName;\n      if (lineMatch[1]) {\n        functionName = lineMatch[1];\n        let methodStart = functionName.lastIndexOf('.');\n        if (functionName[methodStart - 1] === '.') {\n          methodStart--;\n        }\n        if (methodStart > 0) {\n          object = functionName.slice(0, methodStart);\n          method = functionName.slice(methodStart + 1);\n          const objectEnd = object.indexOf('.Module');\n          if (objectEnd > 0) {\n            functionName = functionName.slice(objectEnd + 1);\n            object = object.slice(0, objectEnd);\n          }\n        }\n        typeName = undefined;\n      }\n      if (method) {\n        typeName = object;\n        methodName = method;\n      }\n      if (method === '<anonymous>') {\n        methodName = undefined;\n        functionName = undefined;\n      }\n      if (functionName === undefined) {\n        methodName = methodName || '<anonymous>';\n        functionName = typeName ? `${typeName}.${methodName}` : methodName;\n      }\n      let filename = lineMatch[2] && lineMatch[2].startsWith('file://') ? lineMatch[2].slice(7) : lineMatch[2];\n      const isNative = lineMatch[5] === 'native';\n      if (!filename && lineMatch[5] && !isNative) {\n        filename = lineMatch[5];\n      }\n      const isInternal = isNative || filename && !filename.startsWith('/') && !filename.startsWith('.') && !filename.includes(':\\\\');\n\n      // in_app is all that's not an internal Node function or a module within node_modules\n      // note that isNative appears to return true even for node core libraries\n      // see https://github.com/getsentry/raven-node/issues/176\n\n      const in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n      return {\n        filename,\n        module: getModule ? getModule(filename) : undefined,\n        function: functionName,\n        lineno: parseInt(lineMatch[3], 10) || undefined,\n        colno: parseInt(lineMatch[4], 10) || undefined,\n        in_app\n      };\n    }\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line\n      };\n    }\n    return undefined;\n  };\n}\n\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */\nfunction nodeStackLineParser(getModule) {\n  return [90, node(getModule)];\n}\nexport { createStackParser, getFunctionName, nodeStackLineParser, stackParserFromStackParserOptions, stripSentryFramesAndReverse };","map":{"version":3,"sources":["../../src/stacktrace.ts"],"names":[],"mappings":"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","sourcesContent":["import type { StackFrame, StackLineParser, StackLineParserFn, StackParser } from '@sentry/types';\n\nconst STACKTRACE_FRAME_LIMIT = 50;\n// Used to sanitize webpack (error: *) wrapped stack errors\nconst WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nexport function createStackParser(...parsers: StackLineParser[]): StackParser {\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack: string, skipFirst: number = 0): StackFrame[] => {\n    const frames: StackFrame[] = [];\n    const lines = stack.split('\\n');\n\n    for (let i = skipFirst; i < lines.length; i++) {\n      const line = lines[i];\n      // Ignore lines over 1kb as they are unlikely to be stack frames.\n      // Many of the regular expressions use backtracking which results in run time that increases exponentially with\n      // input size. Huge strings can result in hangs/Denial of Service:\n      // https://github.com/getsentry/sentry-javascript/issues/2286\n      if (line.length > 1024) {\n        continue;\n      }\n\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;\n\n      for (const parser of sortedParsers) {\n        const frame = parser(cleanedLine);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n\n      if (frames.length >= STACKTRACE_FRAME_LIMIT) {\n        break;\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nexport function stackParserFromStackParserOptions(stackParser: StackParser | StackLineParser[]): StackParser {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * Removes Sentry frames from the top and bottom of the stack if present and enforces a limit of max number of frames.\n * Assumes stack input is ordered from top to bottom and returns the reverse representation so call site of the\n * function that caused the crash is the last frame in the array.\n * @hidden\n */\nexport function stripSentryFramesAndReverse(stack: ReadonlyArray<StackFrame>): StackFrame[] {\n  if (!stack.length) {\n    return [];\n  }\n\n  const localStack = stack.slice(0, STACKTRACE_FRAME_LIMIT);\n\n  const lastFrameFunction = localStack[localStack.length - 1].function;\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (lastFrameFunction && /sentryWrapped/.test(lastFrameFunction)) {\n    localStack.pop();\n  }\n\n  // Reversing in the middle of the procedure allows us to just pop the values off the stack\n  localStack.reverse();\n\n  const firstFrameFunction = localStack[localStack.length - 1].function;\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (firstFrameFunction && /captureMessage|captureException/.test(firstFrameFunction)) {\n    localStack.pop();\n  }\n\n  return localStack.map(frame => ({\n    ...frame,\n    filename: frame.filename || localStack[localStack.length - 1].filename,\n    function: frame.function || '?',\n  }));\n}\n\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nexport function getFunctionName(fn: unknown): string {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\ntype GetModuleFn = (filename: string | undefined) => string | undefined;\n\n// eslint-disable-next-line complexity\nfunction node(getModule?: GetModuleFn): StackLineParserFn {\n  const FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n  // eslint-disable-next-line complexity\n  return (line: string) => {\n    const lineMatch = line.match(FULL_MATCH);\n\n    if (lineMatch) {\n      let object: string | undefined;\n      let method: string | undefined;\n      let functionName: string | undefined;\n      let typeName: string | undefined;\n      let methodName: string | undefined;\n\n      if (lineMatch[1]) {\n        functionName = lineMatch[1];\n\n        let methodStart = functionName.lastIndexOf('.');\n        if (functionName[methodStart - 1] === '.') {\n          methodStart--;\n        }\n\n        if (methodStart > 0) {\n          object = functionName.slice(0, methodStart);\n          method = functionName.slice(methodStart + 1);\n          const objectEnd = object.indexOf('.Module');\n          if (objectEnd > 0) {\n            functionName = functionName.slice(objectEnd + 1);\n            object = object.slice(0, objectEnd);\n          }\n        }\n        typeName = undefined;\n      }\n\n      if (method) {\n        typeName = object;\n        methodName = method;\n      }\n\n      if (method === '<anonymous>') {\n        methodName = undefined;\n        functionName = undefined;\n      }\n\n      if (functionName === undefined) {\n        methodName = methodName || '<anonymous>';\n        functionName = typeName ? `${typeName}.${methodName}` : methodName;\n      }\n\n      let filename = lineMatch[2] && lineMatch[2].startsWith('file://') ? lineMatch[2].slice(7) : lineMatch[2];\n      const isNative = lineMatch[5] === 'native';\n\n      if (!filename && lineMatch[5] && !isNative) {\n        filename = lineMatch[5];\n      }\n\n      const isInternal =\n        isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && !filename.includes(':\\\\'));\n\n      // in_app is all that's not an internal Node function or a module within node_modules\n      // note that isNative appears to return true even for node core libraries\n      // see https://github.com/getsentry/raven-node/issues/176\n\n      const in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n\n      return {\n        filename,\n        module: getModule ? getModule(filename) : undefined,\n        function: functionName,\n        lineno: parseInt(lineMatch[3], 10) || undefined,\n        colno: parseInt(lineMatch[4], 10) || undefined,\n        in_app,\n      };\n    }\n\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line,\n      };\n    }\n\n    return undefined;\n  };\n}\n\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */\nexport function nodeStackLineParser(getModule?: GetModuleFn): StackLineParser {\n  return [90, node(getModule)];\n}\n"]},"metadata":{},"sourceType":"module"}