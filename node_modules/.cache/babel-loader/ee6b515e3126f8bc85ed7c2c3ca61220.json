{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { SupportedChainId } from 'constants/chains';\nimport { NATIVE_CHAIN_ID, nativeOnChain } from 'constants/tokens';\nimport { useRecentlySearchedAssetsQuery } from 'graphql/data/__generated__/types-and-hooks';\nimport { CHAIN_NAME_TO_CHAIN_ID } from 'graphql/data/util';\nimport { useAtom } from 'jotai';\nimport { atomWithStorage, useAtomValue } from 'jotai/utils';\nimport { useCallback, useMemo } from 'react';\nimport { getNativeTokenDBAddress } from 'utils/nativeTokens';\n// Temporary measure used until backend supports addressing by \"NATIVE\"\nconst NATIVE_QUERY_ADDRESS_INPUT = null;\nfunction getQueryAddress(chain) {\n  var _getNativeTokenDBAddr;\n  return (_getNativeTokenDBAddr = getNativeTokenDBAddress(chain)) !== null && _getNativeTokenDBAddr !== void 0 ? _getNativeTokenDBAddr : NATIVE_QUERY_ADDRESS_INPUT;\n}\nconst recentlySearchedAssetsAtom = atomWithStorage('recentlySearchedAssets', []);\nexport function useAddRecentlySearchedAsset() {\n  _s();\n  const [searchHistory, updateSearchHistory] = useAtom(recentlySearchedAssetsAtom);\n  return useCallback(asset => {\n    // Removes the new asset if it was already in the array\n    const newHistory = searchHistory.filter(oldAsset => !(oldAsset.address === asset.address && oldAsset.chain === asset.chain));\n    newHistory.unshift(asset);\n    updateSearchHistory(newHistory);\n  }, [searchHistory, updateSearchHistory]);\n}\n_s(useAddRecentlySearchedAsset, \"mXoP8wmRi5KiUJtyHgVFFYuWaow=\", false, function () {\n  return [useAtom];\n});\nexport function useRecentlySearchedAssets() {\n  _s2();\n  const history = useAtomValue(recentlySearchedAssetsAtom);\n  const shortenedHistory = useMemo(() => history.slice(0, 4), [history]);\n  const {\n    data: queryData,\n    loading\n  } = useRecentlySearchedAssetsQuery({\n    variables: {\n      collectionAddresses: shortenedHistory.filter(asset => asset.isNft).map(asset => asset.address),\n      contracts: shortenedHistory.filter(asset => !asset.isNft).map(token => ({\n        address: token.address === NATIVE_CHAIN_ID ? getQueryAddress(token.chain) : token.address,\n        chain: token.chain\n      }))\n    }\n  });\n  const data = useMemo(() => {\n    var _queryData$nftCollect, _queryData$tokens;\n    if (shortenedHistory.length === 0) return [];else if (!queryData) return undefined;\n    // Collects both tokens and collections in a map, so they can later be returned in original order\n    const resultsMap = {};\n    const queryCollections = queryData === null || queryData === void 0 ? void 0 : (_queryData$nftCollect = queryData.nftCollections) === null || _queryData$nftCollect === void 0 ? void 0 : _queryData$nftCollect.edges.map(edge => edge.node);\n    const collections = queryCollections === null || queryCollections === void 0 ? void 0 : queryCollections.map(queryCollection => {\n      var _queryCollection$nftC, _queryCollection$nftC2, _queryCollection$nftC3, _queryCollection$mark, _queryCollection$mark2, _queryCollection$mark3, _queryCollection$imag, _queryCollection$imag2;\n      return {\n        address: (_queryCollection$nftC = (_queryCollection$nftC2 = queryCollection.nftContracts) === null || _queryCollection$nftC2 === void 0 ? void 0 : (_queryCollection$nftC3 = _queryCollection$nftC2[0]) === null || _queryCollection$nftC3 === void 0 ? void 0 : _queryCollection$nftC3.address) !== null && _queryCollection$nftC !== void 0 ? _queryCollection$nftC : '',\n        isVerified: queryCollection === null || queryCollection === void 0 ? void 0 : queryCollection.isVerified,\n        name: queryCollection === null || queryCollection === void 0 ? void 0 : queryCollection.name,\n        stats: {\n          floor_price: queryCollection === null || queryCollection === void 0 ? void 0 : (_queryCollection$mark = queryCollection.markets) === null || _queryCollection$mark === void 0 ? void 0 : (_queryCollection$mark2 = _queryCollection$mark[0]) === null || _queryCollection$mark2 === void 0 ? void 0 : (_queryCollection$mark3 = _queryCollection$mark2.floorPrice) === null || _queryCollection$mark3 === void 0 ? void 0 : _queryCollection$mark3.value,\n          total_supply: queryCollection === null || queryCollection === void 0 ? void 0 : queryCollection.numAssets\n        },\n        imageUrl: (_queryCollection$imag = queryCollection === null || queryCollection === void 0 ? void 0 : (_queryCollection$imag2 = queryCollection.image) === null || _queryCollection$imag2 === void 0 ? void 0 : _queryCollection$imag2.url) !== null && _queryCollection$imag !== void 0 ? _queryCollection$imag : ''\n      };\n    }, [queryCollections]);\n    collections === null || collections === void 0 ? void 0 : collections.forEach(collection => resultsMap[collection.address] = collection);\n    (_queryData$tokens = queryData.tokens) === null || _queryData$tokens === void 0 ? void 0 : _queryData$tokens.filter(Boolean).forEach(token => {\n      var _token$address;\n      resultsMap[(_token$address = token.address) !== null && _token$address !== void 0 ? _token$address : `NATIVE-${token.chain}`] = token;\n    });\n    const data = [];\n    shortenedHistory.forEach(asset => {\n      if (asset.address === 'NATIVE') {\n        var _CHAIN_NAME_TO_CHAIN_, _getQueryAddress$toLo, _getQueryAddress;\n        // Handles special case where wMATIC data needs to be used for MATIC\n        const native = nativeOnChain((_CHAIN_NAME_TO_CHAIN_ = CHAIN_NAME_TO_CHAIN_ID[asset.chain]) !== null && _CHAIN_NAME_TO_CHAIN_ !== void 0 ? _CHAIN_NAME_TO_CHAIN_ : SupportedChainId.MAINNET);\n        const queryAddress = (_getQueryAddress$toLo = (_getQueryAddress = getQueryAddress(asset.chain)) === null || _getQueryAddress === void 0 ? void 0 : _getQueryAddress.toLowerCase()) !== null && _getQueryAddress$toLo !== void 0 ? _getQueryAddress$toLo : `NATIVE-${asset.chain}`;\n        const result = resultsMap[queryAddress];\n        if (result) data.push({\n          ...result,\n          address: 'NATIVE',\n          ...native\n        });\n      } else {\n        const result = resultsMap[asset.address];\n        if (result) data.push(result);\n      }\n    });\n    return data;\n  }, [queryData, shortenedHistory]);\n  return {\n    data,\n    loading\n  };\n}\n_s2(useRecentlySearchedAssets, \"PMMYdneyurcRRlj9XothZK0AbYs=\", false, function () {\n  return [useAtomValue, useRecentlySearchedAssetsQuery];\n});","map":{"version":3,"names":["SupportedChainId","NATIVE_CHAIN_ID","nativeOnChain","useRecentlySearchedAssetsQuery","CHAIN_NAME_TO_CHAIN_ID","useAtom","atomWithStorage","useAtomValue","useCallback","useMemo","getNativeTokenDBAddress","NATIVE_QUERY_ADDRESS_INPUT","getQueryAddress","chain","recentlySearchedAssetsAtom","useAddRecentlySearchedAsset","searchHistory","updateSearchHistory","asset","newHistory","filter","oldAsset","address","unshift","useRecentlySearchedAssets","history","shortenedHistory","slice","data","queryData","loading","variables","collectionAddresses","isNft","map","contracts","token","length","undefined","resultsMap","queryCollections","nftCollections","edges","edge","node","collections","queryCollection","nftContracts","isVerified","name","stats","floor_price","markets","floorPrice","value","total_supply","numAssets","imageUrl","image","url","forEach","collection","tokens","Boolean","native","MAINNET","queryAddress","toLowerCase","result","push"],"sources":["/home/diep/freelance/interface/src/components/NavBar/RecentlySearchedAssets.ts"],"sourcesContent":["import { SupportedChainId } from 'constants/chains'\nimport { NATIVE_CHAIN_ID, nativeOnChain } from 'constants/tokens'\nimport { Chain, NftCollection, useRecentlySearchedAssetsQuery } from 'graphql/data/__generated__/types-and-hooks'\nimport { SearchToken } from 'graphql/data/SearchTokens'\nimport { CHAIN_NAME_TO_CHAIN_ID } from 'graphql/data/util'\nimport { useAtom } from 'jotai'\nimport { atomWithStorage, useAtomValue } from 'jotai/utils'\nimport { GenieCollection } from 'nft/types'\nimport { useCallback, useMemo } from 'react'\nimport { getNativeTokenDBAddress } from 'utils/nativeTokens'\n\ntype RecentlySearchedAsset = {\n  isNft?: boolean\n  address: string\n  chain: Chain\n}\n\n// Temporary measure used until backend supports addressing by \"NATIVE\"\nconst NATIVE_QUERY_ADDRESS_INPUT = null as unknown as string\nfunction getQueryAddress(chain: Chain) {\n  return getNativeTokenDBAddress(chain) ?? NATIVE_QUERY_ADDRESS_INPUT\n}\n\nconst recentlySearchedAssetsAtom = atomWithStorage<RecentlySearchedAsset[]>('recentlySearchedAssets', [])\n\nexport function useAddRecentlySearchedAsset() {\n  const [searchHistory, updateSearchHistory] = useAtom(recentlySearchedAssetsAtom)\n\n  return useCallback(\n    (asset: RecentlySearchedAsset) => {\n      // Removes the new asset if it was already in the array\n      const newHistory = searchHistory.filter(\n        (oldAsset) => !(oldAsset.address === asset.address && oldAsset.chain === asset.chain)\n      )\n      newHistory.unshift(asset)\n      updateSearchHistory(newHistory)\n    },\n    [searchHistory, updateSearchHistory]\n  )\n}\n\nexport function useRecentlySearchedAssets() {\n  const history = useAtomValue(recentlySearchedAssetsAtom)\n  const shortenedHistory = useMemo(() => history.slice(0, 4), [history])\n\n  const { data: queryData, loading } = useRecentlySearchedAssetsQuery({\n    variables: {\n      collectionAddresses: shortenedHistory.filter((asset) => asset.isNft).map((asset) => asset.address),\n      contracts: shortenedHistory\n        .filter((asset) => !asset.isNft)\n        .map((token) => ({\n          address: token.address === NATIVE_CHAIN_ID ? getQueryAddress(token.chain) : token.address,\n          chain: token.chain,\n        })),\n    },\n  })\n\n  const data = useMemo(() => {\n    if (shortenedHistory.length === 0) return []\n    else if (!queryData) return undefined\n    // Collects both tokens and collections in a map, so they can later be returned in original order\n    const resultsMap: { [key: string]: GenieCollection | SearchToken } = {}\n\n    const queryCollections = queryData?.nftCollections?.edges.map((edge) => edge.node as NonNullable<NftCollection>)\n    const collections = queryCollections?.map(\n      (queryCollection): GenieCollection => {\n        return {\n          address: queryCollection.nftContracts?.[0]?.address ?? '',\n          isVerified: queryCollection?.isVerified,\n          name: queryCollection?.name,\n          stats: {\n            floor_price: queryCollection?.markets?.[0]?.floorPrice?.value,\n            total_supply: queryCollection?.numAssets,\n          },\n          imageUrl: queryCollection?.image?.url ?? '',\n        }\n      },\n      [queryCollections]\n    )\n    collections?.forEach((collection) => (resultsMap[collection.address] = collection))\n    queryData.tokens?.filter(Boolean).forEach((token) => {\n      resultsMap[token.address ?? `NATIVE-${token.chain}`] = token\n    })\n\n    const data: (SearchToken | GenieCollection)[] = []\n    shortenedHistory.forEach((asset) => {\n      if (asset.address === 'NATIVE') {\n        // Handles special case where wMATIC data needs to be used for MATIC\n        const native = nativeOnChain(CHAIN_NAME_TO_CHAIN_ID[asset.chain] ?? SupportedChainId.MAINNET)\n        const queryAddress = getQueryAddress(asset.chain)?.toLowerCase() ?? `NATIVE-${asset.chain}`\n        const result = resultsMap[queryAddress]\n        if (result) data.push({ ...result, address: 'NATIVE', ...native })\n      } else {\n        const result = resultsMap[asset.address]\n        if (result) data.push(result)\n      }\n    })\n    return data\n  }, [queryData, shortenedHistory])\n\n  return { data, loading }\n}\n"],"mappings":";;AAAA,SAASA,gBAAgB,QAAQ,kBAAkB;AACnD,SAASC,eAAe,EAAEC,aAAa,QAAQ,kBAAkB;AACjE,SAA+BC,8BAA8B,QAAQ,4CAA4C;AAEjH,SAASC,sBAAsB,QAAQ,mBAAmB;AAC1D,SAASC,OAAO,QAAQ,OAAO;AAC/B,SAASC,eAAe,EAAEC,YAAY,QAAQ,aAAa;AAE3D,SAASC,WAAW,EAAEC,OAAO,QAAQ,OAAO;AAC5C,SAASC,uBAAuB,QAAQ,oBAAoB;AAQ5D;AACA,MAAMC,0BAA0B,GAAG,IAAyB;AAC5D,SAASC,eAAe,CAACC,KAAY,EAAE;EAAA;EACrC,gCAAOH,uBAAuB,CAACG,KAAK,CAAC,yEAAIF,0BAA0B;AACrE;AAEA,MAAMG,0BAA0B,GAAGR,eAAe,CAA0B,wBAAwB,EAAE,EAAE,CAAC;AAEzG,OAAO,SAASS,2BAA2B,GAAG;EAAA;EAC5C,MAAM,CAACC,aAAa,EAAEC,mBAAmB,CAAC,GAAGZ,OAAO,CAACS,0BAA0B,CAAC;EAEhF,OAAON,WAAW,CACfU,KAA4B,IAAK;IAChC;IACA,MAAMC,UAAU,GAAGH,aAAa,CAACI,MAAM,CACpCC,QAAQ,IAAK,EAAEA,QAAQ,CAACC,OAAO,KAAKJ,KAAK,CAACI,OAAO,IAAID,QAAQ,CAACR,KAAK,KAAKK,KAAK,CAACL,KAAK,CAAC,CACtF;IACDM,UAAU,CAACI,OAAO,CAACL,KAAK,CAAC;IACzBD,mBAAmB,CAACE,UAAU,CAAC;EACjC,CAAC,EACD,CAACH,aAAa,EAAEC,mBAAmB,CAAC,CACrC;AACH;AAAC,GAdeF,2BAA2B;EAAA,QACIV,OAAO;AAAA;AAetD,OAAO,SAASmB,yBAAyB,GAAG;EAAA;EAC1C,MAAMC,OAAO,GAAGlB,YAAY,CAACO,0BAA0B,CAAC;EACxD,MAAMY,gBAAgB,GAAGjB,OAAO,CAAC,MAAMgB,OAAO,CAACE,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAACF,OAAO,CAAC,CAAC;EAEtE,MAAM;IAAEG,IAAI,EAAEC,SAAS;IAAEC;EAAQ,CAAC,GAAG3B,8BAA8B,CAAC;IAClE4B,SAAS,EAAE;MACTC,mBAAmB,EAAEN,gBAAgB,CAACN,MAAM,CAAEF,KAAK,IAAKA,KAAK,CAACe,KAAK,CAAC,CAACC,GAAG,CAAEhB,KAAK,IAAKA,KAAK,CAACI,OAAO,CAAC;MAClGa,SAAS,EAAET,gBAAgB,CACxBN,MAAM,CAAEF,KAAK,IAAK,CAACA,KAAK,CAACe,KAAK,CAAC,CAC/BC,GAAG,CAAEE,KAAK,KAAM;QACfd,OAAO,EAAEc,KAAK,CAACd,OAAO,KAAKrB,eAAe,GAAGW,eAAe,CAACwB,KAAK,CAACvB,KAAK,CAAC,GAAGuB,KAAK,CAACd,OAAO;QACzFT,KAAK,EAAEuB,KAAK,CAACvB;MACf,CAAC,CAAC;IACN;EACF,CAAC,CAAC;EAEF,MAAMe,IAAI,GAAGnB,OAAO,CAAC,MAAM;IAAA;IACzB,IAAIiB,gBAAgB,CAACW,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE,MACvC,IAAI,CAACR,SAAS,EAAE,OAAOS,SAAS;IACrC;IACA,MAAMC,UAA4D,GAAG,CAAC,CAAC;IAEvE,MAAMC,gBAAgB,GAAGX,SAAS,aAATA,SAAS,gDAATA,SAAS,CAAEY,cAAc,0DAAzB,sBAA2BC,KAAK,CAACR,GAAG,CAAES,IAAI,IAAKA,IAAI,CAACC,IAAkC,CAAC;IAChH,MAAMC,WAAW,GAAGL,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEN,GAAG,CACtCY,eAAe,IAAsB;MAAA;MACpC,OAAO;QACLxB,OAAO,qDAAEwB,eAAe,CAACC,YAAY,qFAA5B,uBAA+B,CAAC,CAAC,2DAAjC,uBAAmCzB,OAAO,yEAAI,EAAE;QACzD0B,UAAU,EAAEF,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEE,UAAU;QACvCC,IAAI,EAAEH,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEG,IAAI;QAC3BC,KAAK,EAAE;UACLC,WAAW,EAAEL,eAAe,aAAfA,eAAe,gDAAfA,eAAe,CAAEM,OAAO,oFAAxB,sBAA2B,CAAC,CAAC,qFAA7B,uBAA+BC,UAAU,2DAAzC,uBAA2CC,KAAK;UAC7DC,YAAY,EAAET,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEU;QACjC,CAAC;QACDC,QAAQ,2BAAEX,eAAe,aAAfA,eAAe,iDAAfA,eAAe,CAAEY,KAAK,2DAAtB,uBAAwBC,GAAG,yEAAI;MAC3C,CAAC;IACH,CAAC,EACD,CAACnB,gBAAgB,CAAC,CACnB;IACDK,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEe,OAAO,CAAEC,UAAU,IAAMtB,UAAU,CAACsB,UAAU,CAACvC,OAAO,CAAC,GAAGuC,UAAW,CAAC;IACnF,qBAAAhC,SAAS,CAACiC,MAAM,sDAAhB,kBAAkB1C,MAAM,CAAC2C,OAAO,CAAC,CAACH,OAAO,CAAExB,KAAK,IAAK;MAAA;MACnDG,UAAU,mBAACH,KAAK,CAACd,OAAO,2DAAK,UAASc,KAAK,CAACvB,KAAM,EAAC,CAAC,GAAGuB,KAAK;IAC9D,CAAC,CAAC;IAEF,MAAMR,IAAuC,GAAG,EAAE;IAClDF,gBAAgB,CAACkC,OAAO,CAAE1C,KAAK,IAAK;MAClC,IAAIA,KAAK,CAACI,OAAO,KAAK,QAAQ,EAAE;QAAA;QAC9B;QACA,MAAM0C,MAAM,GAAG9D,aAAa,0BAACE,sBAAsB,CAACc,KAAK,CAACL,KAAK,CAAC,yEAAIb,gBAAgB,CAACiE,OAAO,CAAC;QAC7F,MAAMC,YAAY,gDAAGtD,eAAe,CAACM,KAAK,CAACL,KAAK,CAAC,qDAA5B,iBAA8BsD,WAAW,EAAE,yEAAK,UAASjD,KAAK,CAACL,KAAM,EAAC;QAC3F,MAAMuD,MAAM,GAAG7B,UAAU,CAAC2B,YAAY,CAAC;QACvC,IAAIE,MAAM,EAAExC,IAAI,CAACyC,IAAI,CAAC;UAAE,GAAGD,MAAM;UAAE9C,OAAO,EAAE,QAAQ;UAAE,GAAG0C;QAAO,CAAC,CAAC;MACpE,CAAC,MAAM;QACL,MAAMI,MAAM,GAAG7B,UAAU,CAACrB,KAAK,CAACI,OAAO,CAAC;QACxC,IAAI8C,MAAM,EAAExC,IAAI,CAACyC,IAAI,CAACD,MAAM,CAAC;MAC/B;IACF,CAAC,CAAC;IACF,OAAOxC,IAAI;EACb,CAAC,EAAE,CAACC,SAAS,EAAEH,gBAAgB,CAAC,CAAC;EAEjC,OAAO;IAAEE,IAAI;IAAEE;EAAQ,CAAC;AAC1B;AAAC,IA5DeN,yBAAyB;EAAA,QACvBjB,YAAY,EAGSJ,8BAA8B;AAAA"},"metadata":{},"sourceType":"module"}