{"ast":null,"code":"import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';\nimport { logger, loadModule, fill, isThenable } from '@sentry/utils';\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils.js';\n\n// This allows us to use the same array for both defaults options and the type itself.\n// (note `as const` at the end to make it a union of string literal types (i.e. \"a\" | \"b\" | ... )\n// and not just a string[])\n\nconst OPERATIONS = ['aggregate',\n// aggregate(pipeline, options, callback)\n'bulkWrite',\n// bulkWrite(operations, options, callback)\n'countDocuments',\n// countDocuments(query, options, callback)\n'createIndex',\n// createIndex(fieldOrSpec, options, callback)\n'createIndexes',\n// createIndexes(indexSpecs, options, callback)\n'deleteMany',\n// deleteMany(filter, options, callback)\n'deleteOne',\n// deleteOne(filter, options, callback)\n'distinct',\n// distinct(key, query, options, callback)\n'drop',\n// drop(options, callback)\n'dropIndex',\n// dropIndex(indexName, options, callback)\n'dropIndexes',\n// dropIndexes(options, callback)\n'estimatedDocumentCount',\n// estimatedDocumentCount(options, callback)\n'find',\n// find(query, options, callback)\n'findOne',\n// findOne(query, options, callback)\n'findOneAndDelete',\n// findOneAndDelete(filter, options, callback)\n'findOneAndReplace',\n// findOneAndReplace(filter, replacement, options, callback)\n'findOneAndUpdate',\n// findOneAndUpdate(filter, update, options, callback)\n'indexes',\n// indexes(options, callback)\n'indexExists',\n// indexExists(indexes, options, callback)\n'indexInformation',\n// indexInformation(options, callback)\n'initializeOrderedBulkOp',\n// initializeOrderedBulkOp(options, callback)\n'insertMany',\n// insertMany(docs, options, callback)\n'insertOne',\n// insertOne(doc, options, callback)\n'isCapped',\n// isCapped(options, callback)\n'mapReduce',\n// mapReduce(map, reduce, options, callback)\n'options',\n// options(options, callback)\n'parallelCollectionScan',\n// parallelCollectionScan(options, callback)\n'rename',\n// rename(newName, options, callback)\n'replaceOne',\n// replaceOne(filter, doc, options, callback)\n'stats',\n// stats(options, callback)\n'updateMany',\n// updateMany(filter, update, options, callback)\n'updateOne' // updateOne(filter, update, options, callback)\n];\n\n// All of the operations above take `options` and `callback` as their final parameters, but some of them\n// take additional parameters as well. For those operations, this is a map of\n// { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's\n// positional arguments when we add them to the span's `data` object later\nconst OPERATION_SIGNATURES = {\n  // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well\n  // see https://github.com/getsentry/sentry-javascript/pull/3102\n  bulkWrite: ['operations'],\n  countDocuments: ['query'],\n  createIndex: ['fieldOrSpec'],\n  createIndexes: ['indexSpecs'],\n  deleteMany: ['filter'],\n  deleteOne: ['filter'],\n  distinct: ['key', 'query'],\n  dropIndex: ['indexName'],\n  find: ['query'],\n  findOne: ['query'],\n  findOneAndDelete: ['filter'],\n  findOneAndReplace: ['filter', 'replacement'],\n  findOneAndUpdate: ['filter', 'update'],\n  indexExists: ['indexes'],\n  insertMany: ['docs'],\n  insertOne: ['doc'],\n  mapReduce: ['map', 'reduce'],\n  rename: ['newName'],\n  replaceOne: ['filter', 'doc'],\n  updateMany: ['filter', 'update'],\n  updateOne: ['filter', 'update']\n};\nfunction isCursor(maybeCursor) {\n  return maybeCursor && typeof maybeCursor === 'object' && maybeCursor.once && typeof maybeCursor.once === 'function';\n}\n\n/** Tracing integration for mongo package */\nclass Mongo {\n  /**\n   * @inheritDoc\n   */\n  static __initStatic() {\n    this.id = 'Mongo';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  __init() {\n    this.name = Mongo.id;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Mongo.prototype.__init.call(this);\n    this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;\n    this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;\n    this._useMongoose = !!options.useMongoose;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setupOnce(_, getCurrentHub) {\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Mongo Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n    const moduleName = this._useMongoose ? 'mongoose' : 'mongodb';\n    const pkg = loadModule(moduleName);\n    if (!pkg) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(`Mongo Integration was unable to require \\`${moduleName}\\` package.`);\n      return;\n    }\n    this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);\n  }\n\n  /**\n   * Patches original collection methods\n   */\n  _instrumentOperations(collection, operations, getCurrentHub) {\n    operations.forEach(operation => this._patchOperation(collection, operation, getCurrentHub));\n  }\n\n  /**\n   * Patches original collection to utilize our tracing functionality\n   */\n  _patchOperation(collection, operation, getCurrentHub) {\n    if (!(operation in collection.prototype)) return;\n    const getSpanContext = this._getSpanContextFromOperationArguments.bind(this);\n    fill(collection.prototype, operation, function (orig) {\n      return function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        const lastArg = args[args.length - 1];\n        const scope = getCurrentHub().getScope();\n        const parentSpan = _optionalChain([scope, 'optionalAccess', _2 => _2.getSpan, 'call', _3 => _3()]);\n\n        // Check if the operation was passed a callback. (mapReduce requires a different check, as\n        // its (non-callback) arguments can also be functions.)\n        if (typeof lastArg !== 'function' || operation === 'mapReduce' && args.length === 2) {\n          const span = _optionalChain([parentSpan, 'optionalAccess', _4 => _4.startChild, 'call', _5 => _5(getSpanContext(this, operation, args))]);\n          const maybePromiseOrCursor = orig.call(this, ...args);\n          if (isThenable(maybePromiseOrCursor)) {\n            return maybePromiseOrCursor.then(res => {\n              _optionalChain([span, 'optionalAccess', _6 => _6.finish, 'call', _7 => _7()]);\n              return res;\n            });\n          }\n          // If the operation returns a Cursor\n          // we need to attach a listener to it to finish the span when the cursor is closed.\n          else if (isCursor(maybePromiseOrCursor)) {\n            const cursor = maybePromiseOrCursor;\n            try {\n              cursor.once('close', () => {\n                _optionalChain([span, 'optionalAccess', _8 => _8.finish, 'call', _9 => _9()]);\n              });\n            } catch (e) {\n              // If the cursor is already closed, `once` will throw an error. In that case, we can\n              // finish the span immediately.\n              _optionalChain([span, 'optionalAccess', _10 => _10.finish, 'call', _11 => _11()]);\n            }\n            return cursor;\n          } else {\n            _optionalChain([span, 'optionalAccess', _12 => _12.finish, 'call', _13 => _13()]);\n            return maybePromiseOrCursor;\n          }\n        }\n        const span = _optionalChain([parentSpan, 'optionalAccess', _14 => _14.startChild, 'call', _15 => _15(getSpanContext(this, operation, args.slice(0, -1)))]);\n        return orig.call(this, ...args.slice(0, -1), function (err, result) {\n          _optionalChain([span, 'optionalAccess', _16 => _16.finish, 'call', _17 => _17()]);\n          lastArg(err, result);\n        });\n      };\n    });\n  }\n\n  /**\n   * Form a SpanContext based on the user input to a given operation.\n   */\n  _getSpanContextFromOperationArguments(collection, operation, args) {\n    const data = {\n      collectionName: collection.collectionName,\n      dbName: collection.dbName,\n      namespace: collection.namespace\n    };\n    const spanContext = {\n      op: 'db',\n      description: operation,\n      data\n    };\n\n    // If the operation takes no arguments besides `options` and `callback`, or if argument\n    // collection is disabled for this operation, just return early.\n    const signature = OPERATION_SIGNATURES[operation];\n    const shouldDescribe = Array.isArray(this._describeOperations) ? this._describeOperations.includes(operation) : this._describeOperations;\n    if (!signature || !shouldDescribe) {\n      return spanContext;\n    }\n    try {\n      // Special case for `mapReduce`, as the only one accepting functions as arguments.\n      if (operation === 'mapReduce') {\n        const [map, reduce] = args;\n        data[signature[0]] = typeof map === 'string' ? map : map.name || '<anonymous>';\n        data[signature[1]] = typeof reduce === 'string' ? reduce : reduce.name || '<anonymous>';\n      } else {\n        for (let i = 0; i < signature.length; i++) {\n          data[signature[i]] = JSON.stringify(args[i]);\n        }\n      }\n    } catch (_oO) {\n      // no-empty\n    }\n    return spanContext;\n  }\n}\nMongo.__initStatic();\nexport { Mongo };","map":{"version":3,"sources":["../../../../src/node/integrations/mongo.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Hub } from '@sentry/core';\nimport type { EventProcessor, Integration, SpanContext } from '@sentry/types';\nimport { fill, isThenable, loadModule, logger } from '@sentry/utils';\n\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils';\n\n// This allows us to use the same array for both defaults options and the type itself.\n// (note `as const` at the end to make it a union of string literal types (i.e. \"a\" | \"b\" | ... )\n// and not just a string[])\ntype Operation = typeof OPERATIONS[number];\nconst OPERATIONS = [\n  'aggregate', // aggregate(pipeline, options, callback)\n  'bulkWrite', // bulkWrite(operations, options, callback)\n  'countDocuments', // countDocuments(query, options, callback)\n  'createIndex', // createIndex(fieldOrSpec, options, callback)\n  'createIndexes', // createIndexes(indexSpecs, options, callback)\n  'deleteMany', // deleteMany(filter, options, callback)\n  'deleteOne', // deleteOne(filter, options, callback)\n  'distinct', // distinct(key, query, options, callback)\n  'drop', // drop(options, callback)\n  'dropIndex', // dropIndex(indexName, options, callback)\n  'dropIndexes', // dropIndexes(options, callback)\n  'estimatedDocumentCount', // estimatedDocumentCount(options, callback)\n  'find', // find(query, options, callback)\n  'findOne', // findOne(query, options, callback)\n  'findOneAndDelete', // findOneAndDelete(filter, options, callback)\n  'findOneAndReplace', // findOneAndReplace(filter, replacement, options, callback)\n  'findOneAndUpdate', // findOneAndUpdate(filter, update, options, callback)\n  'indexes', // indexes(options, callback)\n  'indexExists', // indexExists(indexes, options, callback)\n  'indexInformation', // indexInformation(options, callback)\n  'initializeOrderedBulkOp', // initializeOrderedBulkOp(options, callback)\n  'insertMany', // insertMany(docs, options, callback)\n  'insertOne', // insertOne(doc, options, callback)\n  'isCapped', // isCapped(options, callback)\n  'mapReduce', // mapReduce(map, reduce, options, callback)\n  'options', // options(options, callback)\n  'parallelCollectionScan', // parallelCollectionScan(options, callback)\n  'rename', // rename(newName, options, callback)\n  'replaceOne', // replaceOne(filter, doc, options, callback)\n  'stats', // stats(options, callback)\n  'updateMany', // updateMany(filter, update, options, callback)\n  'updateOne', // updateOne(filter, update, options, callback)\n] as const;\n\n// All of the operations above take `options` and `callback` as their final parameters, but some of them\n// take additional parameters as well. For those operations, this is a map of\n// { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's\n// positional arguments when we add them to the span's `data` object later\nconst OPERATION_SIGNATURES: {\n  [op in Operation]?: string[];\n} = {\n  // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well\n  // see https://github.com/getsentry/sentry-javascript/pull/3102\n  bulkWrite: ['operations'],\n  countDocuments: ['query'],\n  createIndex: ['fieldOrSpec'],\n  createIndexes: ['indexSpecs'],\n  deleteMany: ['filter'],\n  deleteOne: ['filter'],\n  distinct: ['key', 'query'],\n  dropIndex: ['indexName'],\n  find: ['query'],\n  findOne: ['query'],\n  findOneAndDelete: ['filter'],\n  findOneAndReplace: ['filter', 'replacement'],\n  findOneAndUpdate: ['filter', 'update'],\n  indexExists: ['indexes'],\n  insertMany: ['docs'],\n  insertOne: ['doc'],\n  mapReduce: ['map', 'reduce'],\n  rename: ['newName'],\n  replaceOne: ['filter', 'doc'],\n  updateMany: ['filter', 'update'],\n  updateOne: ['filter', 'update'],\n};\n\ninterface MongoCollection {\n  collectionName: string;\n  dbName: string;\n  namespace: string;\n  prototype: {\n    [operation in Operation]: (...args: unknown[]) => unknown;\n  };\n}\n\ninterface MongoOptions {\n  operations?: Operation[];\n  describeOperations?: boolean | Operation[];\n  useMongoose?: boolean;\n}\n\ninterface MongoCursor {\n  once(event: 'close', listener: () => void): void;\n}\n\nfunction isCursor(maybeCursor: MongoCursor): maybeCursor is MongoCursor {\n  return maybeCursor && typeof maybeCursor === 'object' && maybeCursor.once && typeof maybeCursor.once === 'function';\n}\n\n/** Tracing integration for mongo package */\nexport class Mongo implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Mongo';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Mongo.id;\n\n  private _operations: Operation[];\n  private _describeOperations?: boolean | Operation[];\n  private _useMongoose: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: MongoOptions = {}) {\n    this._operations = Array.isArray(options.operations) ? options.operations : (OPERATIONS as unknown as Operation[]);\n    this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;\n    this._useMongoose = !!options.useMongoose;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      __DEBUG_BUILD__ && logger.log('Mongo Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    const moduleName = this._useMongoose ? 'mongoose' : 'mongodb';\n    const pkg = loadModule<{ Collection: MongoCollection }>(moduleName);\n\n    if (!pkg) {\n      __DEBUG_BUILD__ && logger.error(`Mongo Integration was unable to require \\`${moduleName}\\` package.`);\n      return;\n    }\n\n    this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);\n  }\n\n  /**\n   * Patches original collection methods\n   */\n  private _instrumentOperations(collection: MongoCollection, operations: Operation[], getCurrentHub: () => Hub): void {\n    operations.forEach((operation: Operation) => this._patchOperation(collection, operation, getCurrentHub));\n  }\n\n  /**\n   * Patches original collection to utilize our tracing functionality\n   */\n  private _patchOperation(collection: MongoCollection, operation: Operation, getCurrentHub: () => Hub): void {\n    if (!(operation in collection.prototype)) return;\n\n    const getSpanContext = this._getSpanContextFromOperationArguments.bind(this);\n\n    fill(collection.prototype, operation, function (orig: () => void | Promise<unknown>) {\n      return function (this: unknown, ...args: unknown[]) {\n        const lastArg = args[args.length - 1];\n        const scope = getCurrentHub().getScope();\n        const parentSpan = scope?.getSpan();\n\n        // Check if the operation was passed a callback. (mapReduce requires a different check, as\n        // its (non-callback) arguments can also be functions.)\n        if (typeof lastArg !== 'function' || (operation === 'mapReduce' && args.length === 2)) {\n          const span = parentSpan?.startChild(getSpanContext(this, operation, args));\n          const maybePromiseOrCursor = orig.call(this, ...args);\n\n          if (isThenable(maybePromiseOrCursor)) {\n            return maybePromiseOrCursor.then((res: unknown) => {\n              span?.finish();\n              return res;\n            });\n          }\n          // If the operation returns a Cursor\n          // we need to attach a listener to it to finish the span when the cursor is closed.\n          else if (isCursor(maybePromiseOrCursor)) {\n            const cursor = maybePromiseOrCursor as MongoCursor;\n\n            try {\n              cursor.once('close', () => {\n                span?.finish();\n              });\n            } catch (e) {\n              // If the cursor is already closed, `once` will throw an error. In that case, we can\n              // finish the span immediately.\n              span?.finish();\n            }\n\n            return cursor;\n          } else {\n            span?.finish();\n            return maybePromiseOrCursor;\n          }\n        }\n\n        const span = parentSpan?.startChild(getSpanContext(this, operation, args.slice(0, -1)));\n\n        return orig.call(this, ...args.slice(0, -1), function (err: Error, result: unknown) {\n          span?.finish();\n          lastArg(err, result);\n        });\n      };\n    });\n  }\n\n  /**\n   * Form a SpanContext based on the user input to a given operation.\n   */\n  private _getSpanContextFromOperationArguments(\n    collection: MongoCollection,\n    operation: Operation,\n    args: unknown[],\n  ): SpanContext {\n    const data: { [key: string]: string } = {\n      collectionName: collection.collectionName,\n      dbName: collection.dbName,\n      namespace: collection.namespace,\n    };\n    const spanContext: SpanContext = {\n      op: 'db',\n      description: operation,\n      data,\n    };\n\n    // If the operation takes no arguments besides `options` and `callback`, or if argument\n    // collection is disabled for this operation, just return early.\n    const signature = OPERATION_SIGNATURES[operation];\n    const shouldDescribe = Array.isArray(this._describeOperations)\n      ? this._describeOperations.includes(operation)\n      : this._describeOperations;\n\n    if (!signature || !shouldDescribe) {\n      return spanContext;\n    }\n\n    try {\n      // Special case for `mapReduce`, as the only one accepting functions as arguments.\n      if (operation === 'mapReduce') {\n        const [map, reduce] = args as { name?: string }[];\n        data[signature[0]] = typeof map === 'string' ? map : map.name || '<anonymous>';\n        data[signature[1]] = typeof reduce === 'string' ? reduce : reduce.name || '<anonymous>';\n      } else {\n        for (let i = 0; i < signature.length; i++) {\n          data[signature[i]] = JSON.stringify(args[i]);\n        }\n      }\n    } catch (_oO) {\n      // no-empty\n    }\n\n    return spanContext;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}