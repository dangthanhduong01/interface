{"ast":null,"code":"/**\n * Creates a cache that evicts keys in fifo order\n * @param size {Number}\n */\nfunction makeProfilingCache(size) {\n  // Maintain a fifo queue of keys, we cannot rely on Object.keys as the browser may not support it.\n  let evictionOrder = [];\n  let cache = {};\n  return {\n    add(key, value) {\n      while (evictionOrder.length >= size) {\n        // shift is O(n) but this is small size and only happens if we are\n        // exceeding the cache size so it should be fine.\n        const evictCandidate = evictionOrder.shift();\n        if (evictCandidate !== undefined) {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete cache[evictCandidate];\n        }\n      }\n\n      // in case we have a collision, delete the old key.\n      if (cache[key]) {\n        this.delete(key);\n      }\n      evictionOrder.push(key);\n      cache[key] = value;\n    },\n    clear() {\n      cache = {};\n      evictionOrder = [];\n    },\n    get(key) {\n      return cache[key];\n    },\n    size() {\n      return evictionOrder.length;\n    },\n    // Delete cache key and return true if it existed, false otherwise.\n    delete(key) {\n      if (!cache[key]) {\n        return false;\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete cache[key];\n      for (let i = 0; i < evictionOrder.length; i++) {\n        if (evictionOrder[i] === key) {\n          evictionOrder.splice(i, 1);\n          break;\n        }\n      }\n      return true;\n    }\n  };\n}\nconst PROFILING_EVENT_CACHE = makeProfilingCache(20);\nexport { PROFILING_EVENT_CACHE, makeProfilingCache };","map":{"version":3,"sources":["../../../../src/profiling/cache.ts"],"names":[],"mappings":"AAEA;AACA;AACA;AACA;AACA,SAAA,kBAAA,CACA,IAAA,EAOA;EACA;EACA,IAAA,aAAA,GAAA,EAAA;EACA,IAAA,KAAA,GAAA,CAAA,CAAA;EAEA,OAAA;IACA,GAAA,CAAA,GAAA,EAAA,KAAA,EAAA;MACA,OAAA,aAAA,CAAA,MAAA,IAAA,IAAA,EAAA;QACA;QACA;QACA,MAAA,cAAA,GAAA,aAAA,CAAA,KAAA,EAAA;QAEA,IAAA,cAAA,KAAA,SAAA,EAAA;UACA;UACA,OAAA,KAAA,CAAA,cAAA,CAAA;QACA;MACA;;MAEA;MACA,IAAA,KAAA,CAAA,GAAA,CAAA,EAAA;QACA,IAAA,CAAA,MAAA,CAAA,GAAA,CAAA;MACA;MAEA,aAAA,CAAA,IAAA,CAAA,GAAA,CAAA;MACA,KAAA,CAAA,GAAA,CAAA,GAAA,KAAA;IACA,CAAA;IACA,KAAA,GAAA;MACA,KAAA,GAAA,CAAA,CAAA;MACA,aAAA,GAAA,EAAA;IACA,CAAA;IACA,GAAA,CAAA,GAAA,EAAA;MACA,OAAA,KAAA,CAAA,GAAA,CAAA;IACA,CAAA;IACA,IAAA,GAAA;MACA,OAAA,aAAA,CAAA,MAAA;IACA,CAAA;IACA;IACA,MAAA,CAAA,GAAA,EAAA;MACA,IAAA,CAAA,KAAA,CAAA,GAAA,CAAA,EAAA;QACA,OAAA,KAAA;MACA;;MAEA;MACA,OAAA,KAAA,CAAA,GAAA,CAAA;MAEA,KAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,aAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EAAA;QACA,IAAA,aAAA,CAAA,CAAA,CAAA,KAAA,GAAA,EAAA;UACA,aAAA,CAAA,MAAA,CAAA,CAAA,EAAA,CAAA,CAAA;UACA;QACA;MACA;MAEA,OAAA,IAAA;IACA;EACA,CAAA;AACA;AAEA,MAAA,qBAAA,GAAA,kBAAA,CAAA,EAAA,CAAA","sourcesContent":["import type { Event } from '@sentry/types';\n\n/**\n * Creates a cache that evicts keys in fifo order\n * @param size {Number}\n */\nexport function makeProfilingCache<Key extends string, Value extends Event>(\n  size: number,\n): {\n  get: (key: Key) => Value | undefined;\n  add: (key: Key, value: Value) => void;\n  delete: (key: Key) => boolean;\n  clear: () => void;\n  size: () => number;\n} {\n  // Maintain a fifo queue of keys, we cannot rely on Object.keys as the browser may not support it.\n  let evictionOrder: Key[] = [];\n  let cache: Record<string, Value> = {};\n\n  return {\n    add(key: Key, value: Value) {\n      while (evictionOrder.length >= size) {\n        // shift is O(n) but this is small size and only happens if we are\n        // exceeding the cache size so it should be fine.\n        const evictCandidate = evictionOrder.shift();\n\n        if (evictCandidate !== undefined) {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete cache[evictCandidate];\n        }\n      }\n\n      // in case we have a collision, delete the old key.\n      if (cache[key]) {\n        this.delete(key);\n      }\n\n      evictionOrder.push(key);\n      cache[key] = value;\n    },\n    clear() {\n      cache = {};\n      evictionOrder = [];\n    },\n    get(key: Key): Value | undefined {\n      return cache[key];\n    },\n    size() {\n      return evictionOrder.length;\n    },\n    // Delete cache key and return true if it existed, false otherwise.\n    delete(key: Key): boolean {\n      if (!cache[key]) {\n        return false;\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete cache[key];\n\n      for (let i = 0; i < evictionOrder.length; i++) {\n        if (evictionOrder[i] === key) {\n          evictionOrder.splice(i, 1);\n          break;\n        }\n      }\n\n      return true;\n    },\n  };\n}\n\nexport const PROFILING_EVENT_CACHE = makeProfilingCache<string, Event>(20);\n"]},"metadata":{},"sourceType":"module"}