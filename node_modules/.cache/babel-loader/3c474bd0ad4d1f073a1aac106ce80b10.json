{"ast":null,"code":"import { didUserReject } from 'utils/swapErrorToUserReadableMessage';\n\n/* `responseStatus` is only currently supported on certain browsers.\n * see: https://caniuse.com/mdn-api_performanceresourcetiming_responsestatus\n */\n\n/** Identifies ethers request errors (as thrown by {@type import(@ethersproject/web).fetchJson}). */\nfunction isEthersRequestError(error) {\n  return 'requestBody' in error && typeof error.requestBody === 'string';\n}\nexport function beforeSend(event, hint) {\n  var _event$request;\n  /*\n   * Since the interface currently uses HashRouter, URLs will have a # before the path.\n   * This leads to issues when we send the URL into Sentry, as the path gets parsed as a \"fragment\".\n   * Instead, this logic removes the # part of the URL.\n   * See https://romain-clement.net/articles/sentry-url-fragments/#url-fragments\n   **/\n  if ((_event$request = event.request) === null || _event$request === void 0 ? void 0 : _event$request.url) {\n    event.request.url = event.request.url.replace('/#', '');\n  }\n  return filterKnownErrors(event, hint);\n}\nfunction shouldFilterChunkError(asset) {\n  var _performance$getEntri, _performance;\n  const entries = [...((_performance$getEntri = (_performance = performance) === null || _performance === void 0 ? void 0 : _performance.getEntriesByType('resource')) !== null && _performance$getEntri !== void 0 ? _performance$getEntri : [])];\n  const resource = entries === null || entries === void 0 ? void 0 : entries.find(_ref => {\n    let {\n      name\n    } = _ref;\n    return name === asset;\n  });\n  const status = resource === null || resource === void 0 ? void 0 : resource.responseStatus;\n\n  /*\n   * If the status if 499, then we ignore.\n   * If there's no status (meaning the browser doesn't support `responseStatus`) then we also ignore.\n   * These errors are likely also 499 errors, and we can catch any spikes in non-499 chunk errors via other browsers.\n   */\n  return !status || status === 499;\n}\n\n/**\n * Filters known (ignorable) errors out before sending them to Sentry.\n * Intended as a {@link ClientOptions.beforeSend} callback. Returning null filters the error from Sentry.\n */\nexport const filterKnownErrors = (event, hint) => {\n  const error = hint.originalException;\n  if (error instanceof Error) {\n    // ethers aggressively polls for block number, and it sometimes fails (whether spuriously or through rate-limiting).\n    // If block number polling, it should not be considered an exception.\n    if (isEthersRequestError(error)) {\n      const method = JSON.parse(error.requestBody).method;\n      if (method === 'eth_blockNumber') return null;\n    }\n\n    // If the error is a network change, it should not be considered an exception.\n    if (error.message.match(/underlying network changed/)) return null;\n\n    // If the error is based on a user rejecting, it should not be considered an exception.\n    if (didUserReject(error)) return null;\n\n    /*\n     * This ignores 499 errors, which are caused by Cloudflare when a request is cancelled.\n     * CF claims that some number of these is expected, and that they should be ignored.\n     * See https://groups.google.com/a/uniswap.org/g/cloudflare-eng/c/t3xvAiJFujY.\n     */\n    if (error.message.match(/Loading chunk \\d+ failed\\. \\(([a-zA-Z]+): .+\\.chunk\\.js\\)/)) {\n      var _error$message$match;\n      const asset = (_error$message$match = error.message.match(/https?:\\/\\/.+?\\.chunk\\.js/)) === null || _error$message$match === void 0 ? void 0 : _error$message$match[0];\n      if (shouldFilterChunkError(asset)) return null;\n    }\n    if (error.message.match(/Loading CSS chunk \\d+ failed\\. \\(.+\\.chunk\\.css\\)/)) {\n      var _error$message$match2;\n      const relativePath = (_error$message$match2 = error.message.match(/\\/static\\/css\\/.*\\.chunk\\.css/)) === null || _error$message$match2 === void 0 ? void 0 : _error$message$match2[0];\n      const asset = `https://app.uniswap.org${relativePath}`;\n      if (shouldFilterChunkError(asset)) return null;\n    }\n\n    /*\n     * This is caused by HTML being returned for a chunk from Cloudflare.\n     * Usually, it's the result of a 499 exception right before it, which should be handled.\n     * Therefore, this can be ignored.\n     */\n    if (error.message.match(/Unexpected token '<'/)) return null;\n\n    /*\n     * Content security policy 'unsafe-eval' errors can be filtered out because there are expected failures.\n     * For example, if a user runs an eval statement in console this error would still get thrown.\n     * TODO(INFRA-176): We should extend this to filter out any type of CSP error.\n     */\n    if (error.message.match(/'unsafe-eval'.*content security policy/i)) {\n      return null;\n    }\n  }\n  return event;\n};","map":{"version":3,"names":["didUserReject","isEthersRequestError","error","requestBody","beforeSend","event","hint","request","url","replace","filterKnownErrors","shouldFilterChunkError","asset","entries","performance","getEntriesByType","resource","find","name","status","responseStatus","originalException","Error","method","JSON","parse","message","match","relativePath"],"sources":["/home/diep/freelance/interface/src/tracing/errors.ts"],"sourcesContent":["import { ClientOptions, ErrorEvent, EventHint } from '@sentry/types'\nimport { didUserReject } from 'utils/swapErrorToUserReadableMessage'\n\n/* `responseStatus` is only currently supported on certain browsers.\n * see: https://caniuse.com/mdn-api_performanceresourcetiming_responsestatus\n */\ndeclare global {\n  interface PerformanceEntry {\n    responseStatus?: number\n  }\n}\n\n/** Identifies ethers request errors (as thrown by {@type import(@ethersproject/web).fetchJson}). */\nfunction isEthersRequestError(error: Error): error is Error & { requestBody: string } {\n  return 'requestBody' in error && typeof (error as unknown as Record<'requestBody', unknown>).requestBody === 'string'\n}\n\nexport function beforeSend(event: ErrorEvent, hint: EventHint) {\n  /*\n   * Since the interface currently uses HashRouter, URLs will have a # before the path.\n   * This leads to issues when we send the URL into Sentry, as the path gets parsed as a \"fragment\".\n   * Instead, this logic removes the # part of the URL.\n   * See https://romain-clement.net/articles/sentry-url-fragments/#url-fragments\n   **/\n  if (event.request?.url) {\n    event.request.url = event.request.url.replace('/#', '')\n  }\n\n  return filterKnownErrors(event, hint)\n}\n\nfunction shouldFilterChunkError(asset?: string) {\n  const entries = [...(performance?.getEntriesByType('resource') ?? [])]\n  const resource = entries?.find(({ name }) => name === asset)\n  const status = resource?.responseStatus\n\n  /*\n   * If the status if 499, then we ignore.\n   * If there's no status (meaning the browser doesn't support `responseStatus`) then we also ignore.\n   * These errors are likely also 499 errors, and we can catch any spikes in non-499 chunk errors via other browsers.\n   */\n  return !status || status === 499\n}\n\n/**\n * Filters known (ignorable) errors out before sending them to Sentry.\n * Intended as a {@link ClientOptions.beforeSend} callback. Returning null filters the error from Sentry.\n */\nexport const filterKnownErrors: Required<ClientOptions>['beforeSend'] = (event: ErrorEvent, hint: EventHint) => {\n  const error = hint.originalException\n  if (error instanceof Error) {\n    // ethers aggressively polls for block number, and it sometimes fails (whether spuriously or through rate-limiting).\n    // If block number polling, it should not be considered an exception.\n    if (isEthersRequestError(error)) {\n      const method = JSON.parse(error.requestBody).method\n      if (method === 'eth_blockNumber') return null\n    }\n\n    // If the error is a network change, it should not be considered an exception.\n    if (error.message.match(/underlying network changed/)) return null\n\n    // If the error is based on a user rejecting, it should not be considered an exception.\n    if (didUserReject(error)) return null\n\n    /*\n     * This ignores 499 errors, which are caused by Cloudflare when a request is cancelled.\n     * CF claims that some number of these is expected, and that they should be ignored.\n     * See https://groups.google.com/a/uniswap.org/g/cloudflare-eng/c/t3xvAiJFujY.\n     */\n    if (error.message.match(/Loading chunk \\d+ failed\\. \\(([a-zA-Z]+): .+\\.chunk\\.js\\)/)) {\n      const asset = error.message.match(/https?:\\/\\/.+?\\.chunk\\.js/)?.[0]\n      if (shouldFilterChunkError(asset)) return null\n    }\n\n    if (error.message.match(/Loading CSS chunk \\d+ failed\\. \\(.+\\.chunk\\.css\\)/)) {\n      const relativePath = error.message.match(/\\/static\\/css\\/.*\\.chunk\\.css/)?.[0]\n      const asset = `https://app.uniswap.org${relativePath}`\n      if (shouldFilterChunkError(asset)) return null\n    }\n\n    /*\n     * This is caused by HTML being returned for a chunk from Cloudflare.\n     * Usually, it's the result of a 499 exception right before it, which should be handled.\n     * Therefore, this can be ignored.\n     */\n    if (error.message.match(/Unexpected token '<'/)) return null\n\n    /*\n     * Content security policy 'unsafe-eval' errors can be filtered out because there are expected failures.\n     * For example, if a user runs an eval statement in console this error would still get thrown.\n     * TODO(INFRA-176): We should extend this to filter out any type of CSP error.\n     */\n    if (error.message.match(/'unsafe-eval'.*content security policy/i)) {\n      return null\n    }\n  }\n\n  return event\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}