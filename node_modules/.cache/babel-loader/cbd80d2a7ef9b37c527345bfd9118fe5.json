{"ast":null,"code":"var _jsxFileName = \"/home/diep/freelance/interface/src/featureFlags/index.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$(),\n  _s5 = $RefreshSig$();\nimport { atomWithStorage, useAtomValue, useUpdateAtom } from 'jotai/utils';\nimport { createContext, useCallback, useContext } from 'react';\nimport { useGate } from 'statsig-react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport { FeatureFlag } from './flags/featureFlags';\nconst FeatureFlagContext = /*#__PURE__*/createContext({\n  isLoaded: false,\n  flags: {}\n});\nfunction useFeatureFlagsContext() {\n  _s();\n  const context = useContext(FeatureFlagContext);\n  if (!context) {\n    throw Error('Feature flag hooks can only be used by children of FeatureFlagProvider.');\n  } else {\n    return context;\n  }\n}\n\n/* update and save feature flag settings */\n_s(useFeatureFlagsContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const featureFlagSettings = atomWithStorage('featureFlags', {});\nexport function useUpdateFlag() {\n  _s2();\n  const setFeatureFlags = useUpdateAtom(featureFlagSettings);\n  return useCallback((featureFlag, option) => {\n    setFeatureFlags(featureFlags => ({\n      ...featureFlags,\n      [featureFlag]: option\n    }));\n  }, [setFeatureFlags]);\n}\n_s2(useUpdateFlag, \"NH69eOABph/r3ulrUJmyGRvJvcY=\", false, function () {\n  return [useUpdateAtom];\n});\nexport function FeatureFlagsProvider(_ref) {\n  _s3();\n  let {\n    children\n  } = _ref;\n  // TODO(vm): `isLoaded` to `true` so `App.tsx` will render. Later, this will be dependent on\n  // flags loading from Amplitude, with a timeout.\n  const featureFlags = useAtomValue(featureFlagSettings);\n  const value = {\n    isLoaded: true,\n    flags: featureFlags\n  };\n  return /*#__PURE__*/_jsxDEV(FeatureFlagContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 47,\n    columnNumber: 10\n  }, this);\n}\n_s3(FeatureFlagsProvider, \"q/qlXxD9+QTenuGqcOH6ANis9Ps=\", false, function () {\n  return [useAtomValue];\n});\n_c = FeatureFlagsProvider;\nexport function useFeatureFlagsIsLoaded() {\n  _s4();\n  return useFeatureFlagsContext().isLoaded;\n}\n_s4(useFeatureFlagsIsLoaded, \"af47cXdFJWf9WIhgnyIPAwK+9a8=\", false, function () {\n  return [useFeatureFlagsContext];\n});\nexport let BaseVariant;\n(function (BaseVariant) {\n  BaseVariant[\"Control\"] = \"control\";\n  BaseVariant[\"Enabled\"] = \"enabled\";\n})(BaseVariant || (BaseVariant = {}));\nexport function useBaseFlag(flag) {\n  _s5();\n  let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BaseVariant.Control;\n  const {\n    value: statsigValue\n  } = useGate(flag); // non-existent gates return false\n  const featureFlagsContext = useFeatureFlagsContext();\n  if (statsigValue) {\n    return BaseVariant.Enabled;\n  }\n  switch (featureFlagsContext.flags[flag]) {\n    case 'enabled':\n      return BaseVariant.Enabled;\n    case 'control':\n      return BaseVariant.Control;\n    default:\n      return defaultValue;\n  }\n}\n_s5(useBaseFlag, \"ozF46iGhSCUW3T6Khz9uF9w+Abg=\", false, function () {\n  return [useGate, useFeatureFlagsContext];\n});\nvar _c;\n$RefreshReg$(_c, \"FeatureFlagsProvider\");","map":{"version":3,"names":["atomWithStorage","useAtomValue","useUpdateAtom","createContext","useCallback","useContext","useGate","FeatureFlag","FeatureFlagContext","isLoaded","flags","useFeatureFlagsContext","context","Error","featureFlagSettings","useUpdateFlag","setFeatureFlags","featureFlag","option","featureFlags","FeatureFlagsProvider","children","value","useFeatureFlagsIsLoaded","BaseVariant","useBaseFlag","flag","defaultValue","Control","statsigValue","featureFlagsContext","Enabled"],"sources":["/home/diep/freelance/interface/src/featureFlags/index.tsx"],"sourcesContent":["import { atomWithStorage, useAtomValue, useUpdateAtom } from 'jotai/utils'\nimport { createContext, ReactNode, useCallback, useContext } from 'react'\nimport { useGate } from 'statsig-react'\nexport { FeatureFlag } from './flags/featureFlags'\n\ninterface FeatureFlagsContextType {\n  isLoaded: boolean\n  flags: Record<string, string>\n}\n\nconst FeatureFlagContext = createContext<FeatureFlagsContextType>({ isLoaded: false, flags: {} })\n\nfunction useFeatureFlagsContext(): FeatureFlagsContextType {\n  const context = useContext(FeatureFlagContext)\n  if (!context) {\n    throw Error('Feature flag hooks can only be used by children of FeatureFlagProvider.')\n  } else {\n    return context\n  }\n}\n\n/* update and save feature flag settings */\nexport const featureFlagSettings = atomWithStorage<Record<string, string>>('featureFlags', {})\n\nexport function useUpdateFlag() {\n  const setFeatureFlags = useUpdateAtom(featureFlagSettings)\n\n  return useCallback(\n    (featureFlag: string, option: string) => {\n      setFeatureFlags((featureFlags) => ({\n        ...featureFlags,\n        [featureFlag]: option,\n      }))\n    },\n    [setFeatureFlags]\n  )\n}\n\nexport function FeatureFlagsProvider({ children }: { children: ReactNode }) {\n  // TODO(vm): `isLoaded` to `true` so `App.tsx` will render. Later, this will be dependent on\n  // flags loading from Amplitude, with a timeout.\n  const featureFlags = useAtomValue(featureFlagSettings)\n  const value = {\n    isLoaded: true,\n    flags: featureFlags,\n  }\n  return <FeatureFlagContext.Provider value={value}>{children}</FeatureFlagContext.Provider>\n}\n\nexport function useFeatureFlagsIsLoaded(): boolean {\n  return useFeatureFlagsContext().isLoaded\n}\n\nexport enum BaseVariant {\n  Control = 'control',\n  Enabled = 'enabled',\n}\n\nexport function useBaseFlag(flag: string, defaultValue = BaseVariant.Control): BaseVariant {\n  const { value: statsigValue } = useGate(flag) // non-existent gates return false\n  const featureFlagsContext = useFeatureFlagsContext()\n  if (statsigValue) {\n    return BaseVariant.Enabled\n  }\n  switch (featureFlagsContext.flags[flag]) {\n    case 'enabled':\n      return BaseVariant.Enabled\n    case 'control':\n      return BaseVariant.Control\n    default:\n      return defaultValue\n  }\n}\n"],"mappings":";;;;;;AAAA,SAASA,eAAe,EAAEC,YAAY,EAAEC,aAAa,QAAQ,aAAa;AAC1E,SAASC,aAAa,EAAaC,WAAW,EAAEC,UAAU,QAAQ,OAAO;AACzE,SAASC,OAAO,QAAQ,eAAe;AAAA;AACvC,SAASC,WAAW,QAAQ,sBAAsB;AAOlD,MAAMC,kBAAkB,gBAAGL,aAAa,CAA0B;EAAEM,QAAQ,EAAE,KAAK;EAAEC,KAAK,EAAE,CAAC;AAAE,CAAC,CAAC;AAEjG,SAASC,sBAAsB,GAA4B;EAAA;EACzD,MAAMC,OAAO,GAAGP,UAAU,CAACG,kBAAkB,CAAC;EAC9C,IAAI,CAACI,OAAO,EAAE;IACZ,MAAMC,KAAK,CAAC,yEAAyE,CAAC;EACxF,CAAC,MAAM;IACL,OAAOD,OAAO;EAChB;AACF;;AAEA;AAAA,GATSD,sBAAsB;AAU/B,OAAO,MAAMG,mBAAmB,GAAGd,eAAe,CAAyB,cAAc,EAAE,CAAC,CAAC,CAAC;AAE9F,OAAO,SAASe,aAAa,GAAG;EAAA;EAC9B,MAAMC,eAAe,GAAGd,aAAa,CAACY,mBAAmB,CAAC;EAE1D,OAAOV,WAAW,CAChB,CAACa,WAAmB,EAAEC,MAAc,KAAK;IACvCF,eAAe,CAAEG,YAAY,KAAM;MACjC,GAAGA,YAAY;MACf,CAACF,WAAW,GAAGC;IACjB,CAAC,CAAC,CAAC;EACL,CAAC,EACD,CAACF,eAAe,CAAC,CAClB;AACH;AAAC,IAZeD,aAAa;EAAA,QACHb,aAAa;AAAA;AAavC,OAAO,SAASkB,oBAAoB,OAAwC;EAAA;EAAA,IAAvC;IAAEC;EAAkC,CAAC;EACxE;EACA;EACA,MAAMF,YAAY,GAAGlB,YAAY,CAACa,mBAAmB,CAAC;EACtD,MAAMQ,KAAK,GAAG;IACZb,QAAQ,EAAE,IAAI;IACdC,KAAK,EAAES;EACT,CAAC;EACD,oBAAO,QAAC,kBAAkB,CAAC,QAAQ;IAAC,KAAK,EAAEG,KAAM;IAAA,UAAED;EAAQ;IAAA;IAAA;IAAA;EAAA,QAA+B;AAC5F;AAAC,IATeD,oBAAoB;EAAA,QAGbnB,YAAY;AAAA;AAAA,KAHnBmB,oBAAoB;AAWpC,OAAO,SAASG,uBAAuB,GAAY;EAAA;EACjD,OAAOZ,sBAAsB,EAAE,CAACF,QAAQ;AAC1C;AAAC,IAFec,uBAAuB;EAAA,QAC9BZ,sBAAsB;AAAA;AAG/B,WAAYa,WAAW;AAGtB,WAHWA,WAAW;EAAXA,WAAW;EAAXA,WAAW;AAAA,GAAXA,WAAW,KAAXA,WAAW;AAKvB,OAAO,SAASC,WAAW,CAACC,IAAY,EAAmD;EAAA;EAAA,IAAjDC,YAAY,uEAAGH,WAAW,CAACI,OAAO;EAC1E,MAAM;IAAEN,KAAK,EAAEO;EAAa,CAAC,GAAGvB,OAAO,CAACoB,IAAI,CAAC,EAAC;EAC9C,MAAMI,mBAAmB,GAAGnB,sBAAsB,EAAE;EACpD,IAAIkB,YAAY,EAAE;IAChB,OAAOL,WAAW,CAACO,OAAO;EAC5B;EACA,QAAQD,mBAAmB,CAACpB,KAAK,CAACgB,IAAI,CAAC;IACrC,KAAK,SAAS;MACZ,OAAOF,WAAW,CAACO,OAAO;IAC5B,KAAK,SAAS;MACZ,OAAOP,WAAW,CAACI,OAAO;IAC5B;MACE,OAAOD,YAAY;EAAA;AAEzB;AAAC,IAdeF,WAAW;EAAA,QACOnB,OAAO,EACXK,sBAAsB;AAAA;AAAA;AAAA"},"metadata":{},"sourceType":"module"}