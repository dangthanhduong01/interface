{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useWeb3React } from '@web3-react/core';\nimport { useNftRouteLazyQuery } from 'graphql/data/__generated__/types-and-hooks';\nimport { BagStatus } from 'nft/types';\nimport { buildNftTradeInputFromBagItems, recalculateBagUsingPooledAssets } from 'nft/utils';\nimport { getNextBagState, getPurchasableAssets } from 'nft/utils/bag';\nimport { buildRouteResponse } from 'nft/utils/nftRoute';\nimport { useCallback, useMemo } from 'react';\nimport { shallow } from 'zustand/shallow';\nimport { useBag } from './useBag';\nimport { usePurchaseAssets } from './usePurchaseAssets';\nimport { useTokenInput } from './useTokenInput';\nexport function useFetchAssets() {\n  _s();\n  const {\n    account\n  } = useWeb3React();\n  const {\n    itemsInBag: uncheckedItemsInBag,\n    setBagStatus,\n    didOpenUnavailableAssets,\n    setDidOpenUnavailableAssets,\n    isLocked: bagIsLocked,\n    setLocked: setBagLocked,\n    setItemsInBag\n  } = useBag(_ref => {\n    let {\n      itemsInBag,\n      setBagStatus,\n      didOpenUnavailableAssets,\n      setDidOpenUnavailableAssets,\n      isLocked,\n      setLocked,\n      setItemsInBag\n    } = _ref;\n    return {\n      itemsInBag,\n      setBagStatus,\n      didOpenUnavailableAssets,\n      setDidOpenUnavailableAssets,\n      isLocked,\n      setLocked,\n      setItemsInBag\n    };\n  }, shallow);\n  const tokenTradeInput = useTokenInput(state => state.tokenTradeInput);\n  const itemsInBag = useMemo(() => recalculateBagUsingPooledAssets(uncheckedItemsInBag), [uncheckedItemsInBag]);\n  const [fetchGqlRoute] = useNftRouteLazyQuery();\n  const purchaseAssets = usePurchaseAssets();\n  const resetStateBeforeFetch = useCallback(() => {\n    didOpenUnavailableAssets && setDidOpenUnavailableAssets(false);\n    !bagIsLocked && setBagLocked(true);\n    setBagStatus(BagStatus.FETCHING_ROUTE);\n  }, [bagIsLocked, didOpenUnavailableAssets, setBagLocked, setBagStatus, setDidOpenUnavailableAssets]);\n  return useCallback(async () => {\n    resetStateBeforeFetch();\n    fetchGqlRoute({\n      variables: {\n        senderAddress: account ? account : '',\n        nftTrades: buildNftTradeInputFromBagItems(itemsInBag),\n        tokenTrades: tokenTradeInput ? tokenTradeInput : undefined\n      },\n      onCompleted: data => {\n        if (!data.nftRoute || !data.nftRoute.route) {\n          setBagStatus(BagStatus.ADDING_TO_BAG);\n          setBagLocked(false);\n          return;\n        }\n        const wishAssetsToBuy = getPurchasableAssets(itemsInBag);\n        const purchasingWithErc20 = !!tokenTradeInput;\n        const {\n          route,\n          routeResponse\n        } = buildRouteResponse(data.nftRoute, purchasingWithErc20);\n        const {\n          newBagItems,\n          nextBagStatus\n        } = getNextBagState(wishAssetsToBuy, route, purchasingWithErc20);\n        setItemsInBag(newBagItems);\n        setBagStatus(nextBagStatus);\n        if (nextBagStatus === BagStatus.CONFIRMING_IN_WALLET) {\n          purchaseAssets(routeResponse, wishAssetsToBuy, purchasingWithErc20);\n          setBagLocked(true);\n          return;\n        }\n        setBagLocked(false);\n      }\n    });\n  }, [account, fetchGqlRoute, itemsInBag, purchaseAssets, resetStateBeforeFetch, setBagLocked, setBagStatus, setItemsInBag, tokenTradeInput]);\n}\n_s(useFetchAssets, \"TPV7eBiAcsHiEyO4afmneSyqgdA=\", false, function () {\n  return [useWeb3React, useBag, useTokenInput, useNftRouteLazyQuery, usePurchaseAssets];\n});","map":{"version":3,"names":["useWeb3React","useNftRouteLazyQuery","BagStatus","buildNftTradeInputFromBagItems","recalculateBagUsingPooledAssets","getNextBagState","getPurchasableAssets","buildRouteResponse","useCallback","useMemo","shallow","useBag","usePurchaseAssets","useTokenInput","useFetchAssets","account","itemsInBag","uncheckedItemsInBag","setBagStatus","didOpenUnavailableAssets","setDidOpenUnavailableAssets","isLocked","bagIsLocked","setLocked","setBagLocked","setItemsInBag","tokenTradeInput","state","fetchGqlRoute","purchaseAssets","resetStateBeforeFetch","FETCHING_ROUTE","variables","senderAddress","nftTrades","tokenTrades","undefined","onCompleted","data","nftRoute","route","ADDING_TO_BAG","wishAssetsToBuy","purchasingWithErc20","routeResponse","newBagItems","nextBagStatus","CONFIRMING_IN_WALLET"],"sources":["/home/diep/freelance/interface/src/nft/hooks/useFetchAssets.ts"],"sourcesContent":["import { useWeb3React } from '@web3-react/core'\nimport { useNftRouteLazyQuery } from 'graphql/data/__generated__/types-and-hooks'\nimport { BagStatus } from 'nft/types'\nimport { buildNftTradeInputFromBagItems, recalculateBagUsingPooledAssets } from 'nft/utils'\nimport { getNextBagState, getPurchasableAssets } from 'nft/utils/bag'\nimport { buildRouteResponse } from 'nft/utils/nftRoute'\nimport { useCallback, useMemo } from 'react'\nimport { shallow } from 'zustand/shallow'\n\nimport { useBag } from './useBag'\nimport { usePurchaseAssets } from './usePurchaseAssets'\nimport { useTokenInput } from './useTokenInput'\n\nexport function useFetchAssets(): () => Promise<void> {\n  const { account } = useWeb3React()\n\n  const {\n    itemsInBag: uncheckedItemsInBag,\n    setBagStatus,\n    didOpenUnavailableAssets,\n    setDidOpenUnavailableAssets,\n    isLocked: bagIsLocked,\n    setLocked: setBagLocked,\n    setItemsInBag,\n  } = useBag(\n    ({\n      itemsInBag,\n      setBagStatus,\n      didOpenUnavailableAssets,\n      setDidOpenUnavailableAssets,\n      isLocked,\n      setLocked,\n      setItemsInBag,\n    }) => ({\n      itemsInBag,\n      setBagStatus,\n      didOpenUnavailableAssets,\n      setDidOpenUnavailableAssets,\n      isLocked,\n      setLocked,\n      setItemsInBag,\n    }),\n    shallow\n  )\n  const tokenTradeInput = useTokenInput((state) => state.tokenTradeInput)\n  const itemsInBag = useMemo(() => recalculateBagUsingPooledAssets(uncheckedItemsInBag), [uncheckedItemsInBag])\n\n  const [fetchGqlRoute] = useNftRouteLazyQuery()\n  const purchaseAssets = usePurchaseAssets()\n\n  const resetStateBeforeFetch = useCallback(() => {\n    didOpenUnavailableAssets && setDidOpenUnavailableAssets(false)\n    !bagIsLocked && setBagLocked(true)\n    setBagStatus(BagStatus.FETCHING_ROUTE)\n  }, [bagIsLocked, didOpenUnavailableAssets, setBagLocked, setBagStatus, setDidOpenUnavailableAssets])\n\n  return useCallback(async () => {\n    resetStateBeforeFetch()\n\n    fetchGqlRoute({\n      variables: {\n        senderAddress: account ? account : '',\n        nftTrades: buildNftTradeInputFromBagItems(itemsInBag),\n        tokenTrades: tokenTradeInput ? tokenTradeInput : undefined,\n      },\n      onCompleted: (data) => {\n        if (!data.nftRoute || !data.nftRoute.route) {\n          setBagStatus(BagStatus.ADDING_TO_BAG)\n          setBagLocked(false)\n          return\n        }\n\n        const wishAssetsToBuy = getPurchasableAssets(itemsInBag)\n        const purchasingWithErc20 = !!tokenTradeInput\n        const { route, routeResponse } = buildRouteResponse(data.nftRoute, purchasingWithErc20)\n\n        const { newBagItems, nextBagStatus } = getNextBagState(wishAssetsToBuy, route, purchasingWithErc20)\n\n        setItemsInBag(newBagItems)\n        setBagStatus(nextBagStatus)\n\n        if (nextBagStatus === BagStatus.CONFIRMING_IN_WALLET) {\n          purchaseAssets(routeResponse, wishAssetsToBuy, purchasingWithErc20)\n          setBagLocked(true)\n          return\n        }\n\n        setBagLocked(false)\n      },\n    })\n  }, [\n    account,\n    fetchGqlRoute,\n    itemsInBag,\n    purchaseAssets,\n    resetStateBeforeFetch,\n    setBagLocked,\n    setBagStatus,\n    setItemsInBag,\n    tokenTradeInput,\n  ])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}