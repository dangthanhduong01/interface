{"ast":null,"code":"import { logger, timestampWithMs } from '@sentry/utils';\nimport { SpanRecorder } from './span.js';\nimport { Transaction } from './transaction.js';\nconst TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  heartbeatInterval: 5000\n};\nconst FINISH_REASON_TAG = 'finishReason';\nconst IDLE_TRANSACTION_FINISH_REASONS = ['heartbeatFailed', 'idleTimeout', 'documentHidden', 'finalTimeout', 'externalFinish', 'cancelled'];\n\n/**\n * @inheritDoc\n */\nclass IdleTransactionSpanRecorder extends SpanRecorder {\n  constructor(_pushActivity, _popActivity, transactionSpanId, maxlen) {\n    super(maxlen);\n    this._pushActivity = _pushActivity;\n    this._popActivity = _popActivity;\n    this.transactionSpanId = transactionSpanId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  add(span) {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = endTimestamp => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n    super.add(span);\n  }\n}\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nclass IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  __init() {\n    this.activities = {};\n  }\n\n  // Track state of activities in previous heartbeat\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  __init2() {\n    this._heartbeatCounter = 0;\n  }\n\n  // We should not use heartbeat if we finished a transaction\n  __init3() {\n    this._finished = false;\n  }\n\n  // Idle timeout was canceled and we should finish the transaction with the last span end.\n  __init4() {\n    this._idleTimeoutCanceledPermanently = false;\n  }\n  __init5() {\n    this._beforeFinishCallbacks = [];\n  }\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n\n  __init6() {\n    this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[4];\n  }\n  constructor(transactionContext, _idleHub) {\n    let _idleTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TRACING_DEFAULTS.idleTimeout;\n    let _finalTimeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TRACING_DEFAULTS.finalTimeout;\n    let _heartbeatInterval = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TRACING_DEFAULTS.heartbeatInterval;\n    let _onScope = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    super(transactionContext, _idleHub);\n    this._idleHub = _idleHub;\n    this._idleTimeout = _idleTimeout;\n    this._finalTimeout = _finalTimeout;\n    this._heartbeatInterval = _heartbeatInterval;\n    this._onScope = _onScope;\n    IdleTransaction.prototype.__init.call(this);\n    IdleTransaction.prototype.__init2.call(this);\n    IdleTransaction.prototype.__init3.call(this);\n    IdleTransaction.prototype.__init4.call(this);\n    IdleTransaction.prototype.__init5.call(this);\n    IdleTransaction.prototype.__init6.call(this);\n    if (_onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n    this._restartIdleTimeout();\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3];\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n  finish() {\n    let endTimestamp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : timestampWithMs();\n    this._finished = true;\n    this.activities = {};\n    if (this.op === 'ui.action.click') {\n      this.setTag(FINISH_REASON_TAG, this._finishReason);\n    }\n    if (this.spanRecorder) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n      this.spanRecorder.spans = this.spanRecorder.spans.filter(span => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] discarding Span since it happened after Transaction was finished', JSON.stringify(span, undefined, 2));\n        }\n        return keepSpan;\n      });\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  registerBeforeFinishCallback(callback) {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  initSpanRecorder(maxlen) {\n    if (!this.spanRecorder) {\n      const pushActivity = id => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = id => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   * @param restartOnChildSpanChange Default is `true`.\n   *                                 If set to false the transaction will end\n   *                                 with the last child span.\n   */\n  cancelIdleTimeout(endTimestamp) {\n    let {\n      restartOnChildSpanChange\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      restartOnChildSpanChange: true\n    };\n    this._idleTimeoutCanceledPermanently = restartOnChildSpanChange === false;\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n      if (Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n        this.finish(endTimestamp);\n      }\n    }\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  _restartIdleTimeout(endTimestamp) {\n    this.cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1];\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  _pushActivity(spanId) {\n    this.cancelIdleTimeout(undefined, {\n      restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently\n    });\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  _popActivity(spanId) {\n    if (this.activities[spanId]) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n    if (Object.keys(this.activities).length === 0) {\n      const endTimestamp = timestampWithMs();\n      if (this._idleTimeoutCanceledPermanently) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n        this.finish(endTimestamp);\n      } else {\n        // We need to add the timeout here to have the real endtimestamp of the transaction\n        // Remember timestampWithMs is in seconds, timeout is in ms\n        this._restartIdleTimeout(endTimestamp + this._idleTimeout / 1000);\n      }\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  _beat() {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n    const heartbeatString = Object.keys(this.activities).join('');\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter++;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n    this._prevHeartbeatString = heartbeatString;\n    if (this._heartbeatCounter >= 3) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0];\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  _pingHeartbeat() {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, this._heartbeatInterval);\n  }\n}\n\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub) {\n  const scope = hub.getScope();\n  if (scope.getTransaction()) {\n    scope.setSpan(undefined);\n  }\n}\nexport { IdleTransaction, IdleTransactionSpanRecorder, TRACING_DEFAULTS };","map":{"version":3,"sources":["../../../src/tracing/idletransaction.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport type { TransactionContext } from '@sentry/types';\nimport { logger, timestampWithMs } from '@sentry/utils';\n\nimport type { Hub } from '../hub';\nimport type { Span } from './span';\nimport { SpanRecorder } from './span';\nimport { Transaction } from './transaction';\n\nexport const TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  heartbeatInterval: 5000,\n};\n\nconst FINISH_REASON_TAG = 'finishReason';\n\nconst IDLE_TRANSACTION_FINISH_REASONS = [\n  'heartbeatFailed',\n  'idleTimeout',\n  'documentHidden',\n  'finalTimeout',\n  'externalFinish',\n  'cancelled',\n];\n\n/**\n * @inheritDoc\n */\nexport class IdleTransactionSpanRecorder extends SpanRecorder {\n  public constructor(\n    private readonly _pushActivity: (id: string) => void,\n    private readonly _popActivity: (id: string) => void,\n    public transactionSpanId: string,\n    maxlen?: number,\n  ) {\n    super(maxlen);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(span: Span): void {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = (endTimestamp?: number) => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\nexport type BeforeFinishCallback = (transactionSpan: IdleTransaction, endTimestamp: number) => void;\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nexport class IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  public activities: Record<string, boolean> = {};\n\n  // Track state of activities in previous heartbeat\n  private _prevHeartbeatString: string | undefined;\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  private _heartbeatCounter: number = 0;\n\n  // We should not use heartbeat if we finished a transaction\n  private _finished: boolean = false;\n\n  // Idle timeout was canceled and we should finish the transaction with the last span end.\n  private _idleTimeoutCanceledPermanently: boolean = false;\n\n  private readonly _beforeFinishCallbacks: BeforeFinishCallback[] = [];\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n  private _idleTimeoutID: ReturnType<typeof setTimeout> | undefined;\n\n  private _finishReason: typeof IDLE_TRANSACTION_FINISH_REASONS[number] = IDLE_TRANSACTION_FINISH_REASONS[4];\n\n  public constructor(\n    transactionContext: TransactionContext,\n    private readonly _idleHub: Hub,\n    /**\n     * The time to wait in ms until the idle transaction will be finished. This timer is started each time\n     * there are no active spans on this transaction.\n     */\n    private readonly _idleTimeout: number = TRACING_DEFAULTS.idleTimeout,\n    /**\n     * The final value in ms that a transaction cannot exceed\n     */\n    private readonly _finalTimeout: number = TRACING_DEFAULTS.finalTimeout,\n    private readonly _heartbeatInterval: number = TRACING_DEFAULTS.heartbeatInterval,\n    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n    private readonly _onScope: boolean = false,\n  ) {\n    super(transactionContext, _idleHub);\n\n    if (_onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      __DEBUG_BUILD__ && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n\n    this._restartIdleTimeout();\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3];\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n  public finish(endTimestamp: number = timestampWithMs()): string | undefined {\n    this._finished = true;\n    this.activities = {};\n\n    if (this.op === 'ui.action.click') {\n      this.setTag(FINISH_REASON_TAG, this._finishReason);\n    }\n\n    if (this.spanRecorder) {\n      __DEBUG_BUILD__ &&\n        logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span: Span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          __DEBUG_BUILD__ &&\n            logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          __DEBUG_BUILD__ &&\n            logger.log(\n              '[Tracing] discarding Span since it happened after Transaction was finished',\n              JSON.stringify(span, undefined, 2),\n            );\n        }\n        return keepSpan;\n      });\n\n      __DEBUG_BUILD__ && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      __DEBUG_BUILD__ && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  public registerBeforeFinishCallback(callback: BeforeFinishCallback): void {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public initSpanRecorder(maxlen?: number): void {\n    if (!this.spanRecorder) {\n      const pushActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      __DEBUG_BUILD__ && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   * @param restartOnChildSpanChange Default is `true`.\n   *                                 If set to false the transaction will end\n   *                                 with the last child span.\n   */\n  public cancelIdleTimeout(\n    endTimestamp?: Parameters<IdleTransaction['finish']>[0],\n    {\n      restartOnChildSpanChange,\n    }: {\n      restartOnChildSpanChange?: boolean;\n    } = {\n      restartOnChildSpanChange: true,\n    },\n  ): void {\n    this._idleTimeoutCanceledPermanently = restartOnChildSpanChange === false;\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n\n      if (Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n        this.finish(endTimestamp);\n      }\n    }\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  private _restartIdleTimeout(endTimestamp?: Parameters<IdleTransaction['finish']>[0]): void {\n    this.cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1];\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  private _pushActivity(spanId: string): void {\n    this.cancelIdleTimeout(undefined, { restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently });\n    __DEBUG_BUILD__ && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    __DEBUG_BUILD__ && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  private _popActivity(spanId: string): void {\n    if (this.activities[spanId]) {\n      __DEBUG_BUILD__ && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      __DEBUG_BUILD__ && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      const endTimestamp = timestampWithMs();\n      if (this._idleTimeoutCanceledPermanently) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n        this.finish(endTimestamp);\n      } else {\n        // We need to add the timeout here to have the real endtimestamp of the transaction\n        // Remember timestampWithMs is in seconds, timeout is in ms\n        this._restartIdleTimeout(endTimestamp + this._idleTimeout / 1000);\n      }\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  private _beat(): void {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    const heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter++;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      __DEBUG_BUILD__ && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0];\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  private _pingHeartbeat(): void {\n    __DEBUG_BUILD__ && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, this._heartbeatInterval);\n  }\n}\n\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub: Hub): void {\n  const scope = hub.getScope();\n  if (scope.getTransaction()) {\n    scope.setSpan(undefined);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}