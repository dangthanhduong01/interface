{"ast":null,"code":"import { Protocol } from '@uniswap/router-sdk';\nimport { TradeType } from '@uniswap/sdk-core';\nimport { FeeAmount } from '@uniswap/v3-sdk';\nimport _ from 'lodash';\nimport { CELO, CELO_ALFAJORES, CEUR_CELO, CEUR_CELO_ALFAJORES, CUSD_CELO, CUSD_CELO_ALFAJORES, DAI_ARBITRUM, DAI_ARBITRUM_RINKEBY, DAI_BSC, DAI_MAINNET, DAI_MOONBEAM, DAI_OPTIMISM, DAI_OPTIMISM_GOERLI, DAI_OPTIMISTIC_KOVAN, DAI_POLYGON_MUMBAI, DAI_RINKEBY_1, DAI_RINKEBY_2, FEI_MAINNET, USDC_ARBITRUM, USDC_ARBITRUM_GOERLI, USDC_BSC, USDC_ETHEREUM_GNOSIS, USDC_MAINNET, USDC_MOONBEAM, USDC_OPTIMISM, USDC_OPTIMISM_GOERLI, USDC_OPTIMISTIC_KOVAN, USDC_POLYGON, USDT_ARBITRUM, USDT_ARBITRUM_RINKEBY, USDT_BSC, USDT_MAINNET, USDT_OPTIMISM, USDT_OPTIMISM_GOERLI, USDT_OPTIMISTIC_KOVAN, WBTC_ARBITRUM, WBTC_GNOSIS, WBTC_MAINNET, WBTC_MOONBEAM, WBTC_OPTIMISM, WBTC_OPTIMISM_GOERLI, WBTC_OPTIMISTIC_KOVAN, WGLMR_MOONBEAM, WMATIC_POLYGON, WMATIC_POLYGON_MUMBAI, WXDAI_GNOSIS } from '../../../providers/token-provider';\nimport { ChainId, WRAPPED_NATIVE_CURRENCY } from '../../../util';\nimport { parseFeeAmount, unparseFeeAmount } from '../../../util/amounts';\nimport { log } from '../../../util/log';\nimport { metric, MetricLoggerUnit } from '../../../util/metric';\nconst baseTokensByChain = {\n  [ChainId.MAINNET]: [USDC_MAINNET, USDT_MAINNET, WBTC_MAINNET, DAI_MAINNET, WRAPPED_NATIVE_CURRENCY[1], FEI_MAINNET],\n  [ChainId.RINKEBY]: [DAI_RINKEBY_1, DAI_RINKEBY_2],\n  [ChainId.OPTIMISM]: [DAI_OPTIMISM, USDC_OPTIMISM, USDT_OPTIMISM, WBTC_OPTIMISM],\n  [ChainId.OPTIMISM_GOERLI]: [DAI_OPTIMISM_GOERLI, USDC_OPTIMISM_GOERLI, USDT_OPTIMISM_GOERLI, WBTC_OPTIMISM_GOERLI],\n  [ChainId.OPTIMISTIC_KOVAN]: [DAI_OPTIMISTIC_KOVAN, USDC_OPTIMISTIC_KOVAN, WBTC_OPTIMISTIC_KOVAN, USDT_OPTIMISTIC_KOVAN],\n  [ChainId.ARBITRUM_ONE]: [DAI_ARBITRUM, USDC_ARBITRUM, WBTC_ARBITRUM, USDT_ARBITRUM],\n  [ChainId.ARBITRUM_RINKEBY]: [DAI_ARBITRUM_RINKEBY, USDT_ARBITRUM_RINKEBY],\n  [ChainId.ARBITRUM_GOERLI]: [USDC_ARBITRUM_GOERLI],\n  [ChainId.POLYGON]: [USDC_POLYGON, WMATIC_POLYGON],\n  [ChainId.POLYGON_MUMBAI]: [DAI_POLYGON_MUMBAI, WMATIC_POLYGON_MUMBAI],\n  [ChainId.CELO]: [CUSD_CELO, CEUR_CELO, CELO],\n  [ChainId.CELO_ALFAJORES]: [CUSD_CELO_ALFAJORES, CEUR_CELO_ALFAJORES, CELO_ALFAJORES],\n  [ChainId.GNOSIS]: [WBTC_GNOSIS, WXDAI_GNOSIS, USDC_ETHEREUM_GNOSIS],\n  [ChainId.MOONBEAM]: [DAI_MOONBEAM, USDC_MOONBEAM, WBTC_MOONBEAM, WGLMR_MOONBEAM],\n  [ChainId.BSC]: [DAI_BSC, USDC_BSC, USDT_BSC]\n};\nexport async function getV3CandidatePools(_ref) {\n  let {\n    tokenIn,\n    tokenOut,\n    routeType,\n    routingConfig,\n    subgraphProvider,\n    tokenProvider,\n    poolProvider,\n    blockedTokenListProvider,\n    chainId\n  } = _ref;\n  var _a, _b, _c, _d, _e;\n  const {\n    blockNumber,\n    v3PoolSelection: {\n      topN,\n      topNDirectSwaps,\n      topNTokenInOut,\n      topNSecondHop,\n      topNWithEachBaseToken,\n      topNWithBaseToken\n    }\n  } = routingConfig;\n  const tokenInAddress = tokenIn.address.toLowerCase();\n  const tokenOutAddress = tokenOut.address.toLowerCase();\n  const beforeSubgraphPools = Date.now();\n  const allPoolsRaw = await subgraphProvider.getPools(tokenIn, tokenOut, {\n    blockNumber\n  });\n  log.info({\n    samplePools: allPoolsRaw.slice(0, 3)\n  }, 'Got all pools from V3 subgraph provider');\n  const allPools = _.map(allPoolsRaw, pool => {\n    return {\n      ...pool,\n      token0: {\n        ...pool.token0,\n        id: pool.token0.id.toLowerCase()\n      },\n      token1: {\n        ...pool.token1,\n        id: pool.token1.id.toLowerCase()\n      }\n    };\n  });\n  metric.putMetric('V3SubgraphPoolsLoad', Date.now() - beforeSubgraphPools, MetricLoggerUnit.Milliseconds);\n  // Only consider pools where neither tokens are in the blocked token list.\n  let filteredPools = allPools;\n  if (blockedTokenListProvider) {\n    filteredPools = [];\n    for (const pool of allPools) {\n      const token0InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token0.id);\n      const token1InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token1.id);\n      if (token0InBlocklist || token1InBlocklist) {\n        continue;\n      }\n      filteredPools.push(pool);\n    }\n  }\n  const subgraphPoolsSorted = _(filteredPools).sortBy(tokenListPool => -tokenListPool.tvlUSD).value();\n  log.info(`After filtering blocked tokens went from ${allPools.length} to ${subgraphPoolsSorted.length}.`);\n  const poolAddressesSoFar = new Set();\n  const addToAddressSet = pools => {\n    _(pools).map(pool => pool.id).forEach(poolAddress => poolAddressesSoFar.add(poolAddress));\n  };\n  const baseTokens = (_a = baseTokensByChain[chainId]) !== null && _a !== void 0 ? _a : [];\n  const topByBaseWithTokenIn = _(baseTokens).flatMap(token => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      const tokenAddress = token.address.toLowerCase();\n      return subgraphPool.token0.id == tokenAddress && subgraphPool.token1.id == tokenInAddress || subgraphPool.token1.id == tokenAddress && subgraphPool.token0.id == tokenInAddress;\n    }).sortBy(tokenListPool => -tokenListPool.tvlUSD).slice(0, topNWithEachBaseToken).value();\n  }).sortBy(tokenListPool => -tokenListPool.tvlUSD).slice(0, topNWithBaseToken).value();\n  const topByBaseWithTokenOut = _(baseTokens).flatMap(token => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      const tokenAddress = token.address.toLowerCase();\n      return subgraphPool.token0.id == tokenAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == tokenAddress && subgraphPool.token0.id == tokenOutAddress;\n    }).sortBy(tokenListPool => -tokenListPool.tvlUSD).slice(0, topNWithEachBaseToken).value();\n  }).sortBy(tokenListPool => -tokenListPool.tvlUSD).slice(0, topNWithBaseToken).value();\n  let top2DirectSwapPool = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenInAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == tokenInAddress && subgraphPool.token0.id == tokenOutAddress);\n  }).slice(0, topNDirectSwaps).value();\n  if (top2DirectSwapPool.length == 0 && topNDirectSwaps > 0) {\n    // If we requested direct swap pools but did not find any in the subgraph query.\n    // Optimistically add them into the query regardless. Invalid pools ones will be dropped anyway\n    // when we query the pool on-chain. Ensures that new pools for new pairs can be swapped on immediately.\n    top2DirectSwapPool = _.map([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW, FeeAmount.LOWEST], feeAmount => {\n      const {\n        token0,\n        token1,\n        poolAddress\n      } = poolProvider.getPoolAddress(tokenIn, tokenOut, feeAmount);\n      return {\n        id: poolAddress,\n        feeTier: unparseFeeAmount(feeAmount),\n        liquidity: '10000',\n        token0: {\n          id: token0.address\n        },\n        token1: {\n          id: token1.address\n        },\n        tvlETH: 10000,\n        tvlUSD: 10000\n      };\n    });\n  }\n  addToAddressSet(top2DirectSwapPool);\n  const wrappedNativeAddress = (_b = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _b === void 0 ? void 0 : _b.address;\n  // Main reason we need this is for gas estimates, only needed if token out is not native.\n  // We don't check the seen address set because if we've already added pools for getting native quotes\n  // theres no need to add more.\n  let top2EthQuoteTokenPool = [];\n  if (((_c = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _c === void 0 ? void 0 : _c.symbol) == ((_d = WRAPPED_NATIVE_CURRENCY[ChainId.MAINNET]) === null || _d === void 0 ? void 0 : _d.symbol) && tokenOut.symbol != 'WETH' && tokenOut.symbol != 'WETH9' && tokenOut.symbol != 'ETH' || ((_e = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _e === void 0 ? void 0 : _e.symbol) == WMATIC_POLYGON.symbol && tokenOut.symbol != 'MATIC' && tokenOut.symbol != 'WMATIC') {\n    top2EthQuoteTokenPool = _(subgraphPoolsSorted).filter(subgraphPool => {\n      if (routeType == TradeType.EXACT_INPUT) {\n        return subgraphPool.token0.id == wrappedNativeAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == wrappedNativeAddress && subgraphPool.token0.id == tokenOutAddress;\n      } else {\n        return subgraphPool.token0.id == wrappedNativeAddress && subgraphPool.token1.id == tokenInAddress || subgraphPool.token1.id == wrappedNativeAddress && subgraphPool.token0.id == tokenInAddress;\n      }\n    }).slice(0, 1).value();\n  }\n  addToAddressSet(top2EthQuoteTokenPool);\n  const topByTVL = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id);\n  }).slice(0, topN).value();\n  addToAddressSet(topByTVL);\n  const topByTVLUsingTokenIn = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenInAddress || subgraphPool.token1.id == tokenInAddress);\n  }).slice(0, topNTokenInOut).value();\n  addToAddressSet(topByTVLUsingTokenIn);\n  const topByTVLUsingTokenOut = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenOutAddress || subgraphPool.token1.id == tokenOutAddress);\n  }).slice(0, topNTokenInOut).value();\n  addToAddressSet(topByTVLUsingTokenOut);\n  const topByTVLUsingTokenInSecondHops = _(topByTVLUsingTokenIn).map(subgraphPool => {\n    return tokenInAddress == subgraphPool.token0.id ? subgraphPool.token1.id : subgraphPool.token0.id;\n  }).flatMap(secondHopId => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == secondHopId || subgraphPool.token1.id == secondHopId);\n    }).slice(0, topNSecondHop).value();\n  }).uniqBy(pool => pool.id).sortBy(tokenListPool => -tokenListPool.tvlUSD).slice(0, topNSecondHop).value();\n  addToAddressSet(topByTVLUsingTokenInSecondHops);\n  const topByTVLUsingTokenOutSecondHops = _(topByTVLUsingTokenOut).map(subgraphPool => {\n    return tokenOutAddress == subgraphPool.token0.id ? subgraphPool.token1.id : subgraphPool.token0.id;\n  }).flatMap(secondHopId => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == secondHopId || subgraphPool.token1.id == secondHopId);\n    }).slice(0, topNSecondHop).value();\n  }).uniqBy(pool => pool.id).sortBy(tokenListPool => -tokenListPool.tvlUSD).slice(0, topNSecondHop).value();\n  addToAddressSet(topByTVLUsingTokenOutSecondHops);\n  const subgraphPools = _([...topByBaseWithTokenIn, ...topByBaseWithTokenOut, ...top2DirectSwapPool, ...top2EthQuoteTokenPool, ...topByTVL, ...topByTVLUsingTokenIn, ...topByTVLUsingTokenOut, ...topByTVLUsingTokenInSecondHops, ...topByTVLUsingTokenOutSecondHops]).compact().uniqBy(pool => pool.id).value();\n  const tokenAddresses = _(subgraphPools).flatMap(subgraphPool => [subgraphPool.token0.id, subgraphPool.token1.id]).compact().uniq().value();\n  log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} V3 pools we are considering`);\n  const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {\n    blockNumber\n  });\n  const printV3SubgraphPool = s => {\n    var _a, _b, _c, _d;\n    return `${(_b = (_a = tokenAccessor.getTokenByAddress(s.token0.id)) === null || _a === void 0 ? void 0 : _a.symbol) !== null && _b !== void 0 ? _b : s.token0.id}/${(_d = (_c = tokenAccessor.getTokenByAddress(s.token1.id)) === null || _c === void 0 ? void 0 : _c.symbol) !== null && _d !== void 0 ? _d : s.token1.id}/${s.feeTier}`;\n  };\n  log.info({\n    topByBaseWithTokenIn: topByBaseWithTokenIn.map(printV3SubgraphPool),\n    topByBaseWithTokenOut: topByBaseWithTokenOut.map(printV3SubgraphPool),\n    topByTVL: topByTVL.map(printV3SubgraphPool),\n    topByTVLUsingTokenIn: topByTVLUsingTokenIn.map(printV3SubgraphPool),\n    topByTVLUsingTokenOut: topByTVLUsingTokenOut.map(printV3SubgraphPool),\n    topByTVLUsingTokenInSecondHops: topByTVLUsingTokenInSecondHops.map(printV3SubgraphPool),\n    topByTVLUsingTokenOutSecondHops: topByTVLUsingTokenOutSecondHops.map(printV3SubgraphPool),\n    top2DirectSwap: top2DirectSwapPool.map(printV3SubgraphPool),\n    top2EthQuotePool: top2EthQuoteTokenPool.map(printV3SubgraphPool)\n  }, `V3 Candidate Pools`);\n  const tokenPairsRaw = _.map(subgraphPools, subgraphPool => {\n    const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n    const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n    let fee;\n    try {\n      fee = parseFeeAmount(subgraphPool.feeTier);\n    } catch (err) {\n      log.info({\n        subgraphPool\n      }, `Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${subgraphPool.feeTier} because fee tier not supported`);\n      return undefined;\n    }\n    if (!tokenA || !tokenB) {\n      log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${fee} because ${tokenA ? subgraphPool.token1.id : subgraphPool.token0.id} not found by token provider`);\n      return undefined;\n    }\n    return [tokenA, tokenB, fee];\n  });\n  const tokenPairs = _.compact(tokenPairsRaw);\n  const beforePoolsLoad = Date.now();\n  const poolAccessor = await poolProvider.getPools(tokenPairs);\n  metric.putMetric('V3PoolsLoad', Date.now() - beforePoolsLoad, MetricLoggerUnit.Milliseconds);\n  const poolsBySelection = {\n    protocol: Protocol.V3,\n    selections: {\n      topByBaseWithTokenIn,\n      topByBaseWithTokenOut,\n      topByDirectSwapPool: top2DirectSwapPool,\n      topByEthQuoteTokenPool: top2EthQuoteTokenPool,\n      topByTVL,\n      topByTVLUsingTokenIn,\n      topByTVLUsingTokenOut,\n      topByTVLUsingTokenInSecondHops,\n      topByTVLUsingTokenOutSecondHops\n    }\n  };\n  return {\n    poolAccessor,\n    candidatePools: poolsBySelection,\n    subgraphPools\n  };\n}\nexport async function getV2CandidatePools(_ref2) {\n  let {\n    tokenIn,\n    tokenOut,\n    routeType,\n    routingConfig,\n    subgraphProvider,\n    tokenProvider,\n    poolProvider,\n    blockedTokenListProvider,\n    chainId\n  } = _ref2;\n  var _a;\n  const {\n    blockNumber,\n    v2PoolSelection: {\n      topN,\n      topNDirectSwaps,\n      topNTokenInOut,\n      topNSecondHop,\n      topNWithEachBaseToken,\n      topNWithBaseToken\n    }\n  } = routingConfig;\n  const tokenInAddress = tokenIn.address.toLowerCase();\n  const tokenOutAddress = tokenOut.address.toLowerCase();\n  const beforeSubgraphPools = Date.now();\n  const allPoolsRaw = await subgraphProvider.getPools(tokenIn, tokenOut, {\n    blockNumber\n  });\n  const allPools = _.map(allPoolsRaw, pool => {\n    return {\n      ...pool,\n      token0: {\n        ...pool.token0,\n        id: pool.token0.id.toLowerCase()\n      },\n      token1: {\n        ...pool.token1,\n        id: pool.token1.id.toLowerCase()\n      }\n    };\n  });\n  metric.putMetric('V2SubgraphPoolsLoad', Date.now() - beforeSubgraphPools, MetricLoggerUnit.Milliseconds);\n  // Only consider pools where neither tokens are in the blocked token list.\n  let filteredPools = allPools;\n  if (blockedTokenListProvider) {\n    filteredPools = [];\n    for (const pool of allPools) {\n      const token0InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token0.id);\n      const token1InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token1.id);\n      if (token0InBlocklist || token1InBlocklist) {\n        continue;\n      }\n      filteredPools.push(pool);\n    }\n  }\n  const subgraphPoolsSorted = _(filteredPools).sortBy(tokenListPool => -tokenListPool.reserve).value();\n  log.info(`After filtering blocked tokens went from ${allPools.length} to ${subgraphPoolsSorted.length}.`);\n  const poolAddressesSoFar = new Set();\n  const addToAddressSet = pools => {\n    _(pools).map(pool => pool.id).forEach(poolAddress => poolAddressesSoFar.add(poolAddress));\n  };\n  const baseTokens = (_a = baseTokensByChain[chainId]) !== null && _a !== void 0 ? _a : [];\n  const topByBaseWithTokenIn = _(baseTokens).flatMap(token => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      const tokenAddress = token.address.toLowerCase();\n      return subgraphPool.token0.id == tokenAddress && subgraphPool.token1.id == tokenInAddress || subgraphPool.token1.id == tokenAddress && subgraphPool.token0.id == tokenInAddress;\n    }).sortBy(tokenListPool => -tokenListPool.reserve).slice(0, topNWithEachBaseToken).value();\n  }).sortBy(tokenListPool => -tokenListPool.reserve).slice(0, topNWithBaseToken).value();\n  const topByBaseWithTokenOut = _(baseTokens).flatMap(token => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      const tokenAddress = token.address.toLowerCase();\n      return subgraphPool.token0.id == tokenAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == tokenAddress && subgraphPool.token0.id == tokenOutAddress;\n    }).sortBy(tokenListPool => -tokenListPool.reserve).slice(0, topNWithEachBaseToken).value();\n  }).sortBy(tokenListPool => -tokenListPool.reserve).slice(0, topNWithBaseToken).value();\n  // Always add the direct swap pool into the mix regardless of if it exists in the subgraph pool list.\n  // Ensures that new pools can be swapped on immediately, and that if a pool was filtered out of the\n  // subgraph query for some reason (e.g. trackedReserveETH was 0), then we still consider it.\n  let topByDirectSwapPool = [];\n  if (topNDirectSwaps != 0) {\n    const {\n      token0,\n      token1,\n      poolAddress\n    } = poolProvider.getPoolAddress(tokenIn, tokenOut);\n    topByDirectSwapPool = [{\n      id: poolAddress,\n      token0: {\n        id: token0.address\n      },\n      token1: {\n        id: token1.address\n      },\n      supply: 10000,\n      reserve: 10000,\n      reserveUSD: 10000 // Not used. Set to arbitrary number.\n    }];\n  }\n\n  addToAddressSet(topByDirectSwapPool);\n  const wethAddress = WRAPPED_NATIVE_CURRENCY[chainId].address;\n  // Main reason we need this is for gas estimates, only needed if token out is not ETH.\n  // We don't check the seen address set because if we've already added pools for getting ETH quotes\n  // theres no need to add more.\n  // Note: we do not need to check other native currencies for the V2 Protocol\n  let topByEthQuoteTokenPool = [];\n  if (tokenOut.symbol != 'WETH' && tokenOut.symbol != 'WETH9' && tokenOut.symbol != 'ETH') {\n    topByEthQuoteTokenPool = _(subgraphPoolsSorted).filter(subgraphPool => {\n      if (routeType == TradeType.EXACT_INPUT) {\n        return subgraphPool.token0.id == wethAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == wethAddress && subgraphPool.token0.id == tokenOutAddress;\n      } else {\n        return subgraphPool.token0.id == wethAddress && subgraphPool.token1.id == tokenInAddress || subgraphPool.token1.id == wethAddress && subgraphPool.token0.id == tokenInAddress;\n      }\n    }).slice(0, 1).value();\n  }\n  addToAddressSet(topByEthQuoteTokenPool);\n  const topByTVL = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id);\n  }).slice(0, topN).value();\n  addToAddressSet(topByTVL);\n  const topByTVLUsingTokenIn = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenInAddress || subgraphPool.token1.id == tokenInAddress);\n  }).slice(0, topNTokenInOut).value();\n  addToAddressSet(topByTVLUsingTokenIn);\n  const topByTVLUsingTokenOut = _(subgraphPoolsSorted).filter(subgraphPool => {\n    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenOutAddress || subgraphPool.token1.id == tokenOutAddress);\n  }).slice(0, topNTokenInOut).value();\n  addToAddressSet(topByTVLUsingTokenOut);\n  const topByTVLUsingTokenInSecondHops = _(topByTVLUsingTokenIn).map(subgraphPool => {\n    return tokenInAddress == subgraphPool.token0.id ? subgraphPool.token1.id : subgraphPool.token0.id;\n  }).flatMap(secondHopId => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == secondHopId || subgraphPool.token1.id == secondHopId);\n    }).slice(0, topNSecondHop).value();\n  }).uniqBy(pool => pool.id).sortBy(tokenListPool => -tokenListPool.reserve).slice(0, topNSecondHop).value();\n  addToAddressSet(topByTVLUsingTokenInSecondHops);\n  const topByTVLUsingTokenOutSecondHops = _(topByTVLUsingTokenOut).map(subgraphPool => {\n    return tokenOutAddress == subgraphPool.token0.id ? subgraphPool.token1.id : subgraphPool.token0.id;\n  }).flatMap(secondHopId => {\n    return _(subgraphPoolsSorted).filter(subgraphPool => {\n      return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == secondHopId || subgraphPool.token1.id == secondHopId);\n    }).slice(0, topNSecondHop).value();\n  }).uniqBy(pool => pool.id).sortBy(tokenListPool => -tokenListPool.reserve).slice(0, topNSecondHop).value();\n  addToAddressSet(topByTVLUsingTokenOutSecondHops);\n  const subgraphPools = _([...topByBaseWithTokenIn, ...topByBaseWithTokenOut, ...topByDirectSwapPool, ...topByEthQuoteTokenPool, ...topByTVL, ...topByTVLUsingTokenIn, ...topByTVLUsingTokenOut, ...topByTVLUsingTokenInSecondHops, ...topByTVLUsingTokenOutSecondHops]).compact().uniqBy(pool => pool.id).value();\n  const tokenAddresses = _(subgraphPools).flatMap(subgraphPool => [subgraphPool.token0.id, subgraphPool.token1.id]).compact().uniq().value();\n  log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} V2 pools we are considering`);\n  const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {\n    blockNumber\n  });\n  const printV2SubgraphPool = s => {\n    var _a, _b, _c, _d;\n    return `${(_b = (_a = tokenAccessor.getTokenByAddress(s.token0.id)) === null || _a === void 0 ? void 0 : _a.symbol) !== null && _b !== void 0 ? _b : s.token0.id}/${(_d = (_c = tokenAccessor.getTokenByAddress(s.token1.id)) === null || _c === void 0 ? void 0 : _c.symbol) !== null && _d !== void 0 ? _d : s.token1.id}`;\n  };\n  log.info({\n    topByBaseWithTokenIn: topByBaseWithTokenIn.map(printV2SubgraphPool),\n    topByBaseWithTokenOut: topByBaseWithTokenOut.map(printV2SubgraphPool),\n    topByTVL: topByTVL.map(printV2SubgraphPool),\n    topByTVLUsingTokenIn: topByTVLUsingTokenIn.map(printV2SubgraphPool),\n    topByTVLUsingTokenOut: topByTVLUsingTokenOut.map(printV2SubgraphPool),\n    topByTVLUsingTokenInSecondHops: topByTVLUsingTokenInSecondHops.map(printV2SubgraphPool),\n    topByTVLUsingTokenOutSecondHops: topByTVLUsingTokenOutSecondHops.map(printV2SubgraphPool),\n    top2DirectSwap: topByDirectSwapPool.map(printV2SubgraphPool),\n    top2EthQuotePool: topByEthQuoteTokenPool.map(printV2SubgraphPool)\n  }, `V2 Candidate pools`);\n  const tokenPairsRaw = _.map(subgraphPools, subgraphPool => {\n    const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n    const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n    if (!tokenA || !tokenB) {\n      log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}`);\n      return undefined;\n    }\n    return [tokenA, tokenB];\n  });\n  const tokenPairs = _.compact(tokenPairsRaw);\n  const beforePoolsLoad = Date.now();\n  const poolAccessor = await poolProvider.getPools(tokenPairs, {\n    blockNumber\n  });\n  metric.putMetric('V2PoolsLoad', Date.now() - beforePoolsLoad, MetricLoggerUnit.Milliseconds);\n  const poolsBySelection = {\n    protocol: Protocol.V2,\n    selections: {\n      topByBaseWithTokenIn,\n      topByBaseWithTokenOut,\n      topByDirectSwapPool,\n      topByEthQuoteTokenPool: topByEthQuoteTokenPool,\n      topByTVL,\n      topByTVLUsingTokenIn,\n      topByTVLUsingTokenOut,\n      topByTVLUsingTokenInSecondHops,\n      topByTVLUsingTokenOutSecondHops\n    }\n  };\n  return {\n    poolAccessor,\n    candidatePools: poolsBySelection,\n    subgraphPools\n  };\n}\nexport async function getMixedRouteCandidatePools(_ref3) {\n  let {\n    tokenIn,\n    tokenOut,\n    routeType,\n    routingConfig,\n    v3subgraphProvider,\n    v2subgraphProvider,\n    tokenProvider,\n    v3poolProvider,\n    v2poolProvider,\n    blockedTokenListProvider,\n    chainId\n  } = _ref3;\n  const {\n    blockNumber\n  } = routingConfig;\n  const {\n    subgraphPools: V3subgraphPools,\n    candidatePools: V3candidatePools\n  } = await getV3CandidatePools({\n    tokenIn,\n    tokenOut,\n    tokenProvider,\n    blockedTokenListProvider,\n    poolProvider: v3poolProvider,\n    routeType,\n    subgraphProvider: v3subgraphProvider,\n    routingConfig,\n    chainId\n  });\n  const {\n    subgraphPools: V2subgraphPools,\n    candidatePools: V2candidatePools\n  } = await getV2CandidatePools({\n    tokenIn,\n    tokenOut,\n    tokenProvider,\n    blockedTokenListProvider,\n    poolProvider: v2poolProvider,\n    routeType,\n    subgraphProvider: v2subgraphProvider,\n    routingConfig,\n    chainId\n  });\n  /**\n   * Main heuristic for pruning mixedRoutes:\n   * - we pick V2 pools with higher liq than respective V3 pools, or if the v3 pool doesn't exist\n   *\n   * This way we can reduce calls to our provider since it's possible to generate a lot of mixed routes\n   */\n  /// We only really care about pools involving the tokenIn or tokenOut explictly,\n  /// since there's no way a long tail token in V2 would be routed through as an intermediary\n  const V2topByTVLPoolIds = new Set([...V2candidatePools.selections.topByTVLUsingTokenIn, ...V2candidatePools.selections.topByBaseWithTokenIn,\n  /// tokenOut:\n  ...V2candidatePools.selections.topByTVLUsingTokenOut, ...V2candidatePools.selections.topByBaseWithTokenOut,\n  /// Direct swap:\n  ...V2candidatePools.selections.topByDirectSwapPool].map(poolId => poolId.id));\n  const V2topByTVLSortedPools = _(V2subgraphPools).filter(pool => V2topByTVLPoolIds.has(pool.id)).sortBy(pool => -pool.reserveUSD).value();\n  /// we consider all returned V3 pools for this heuristic to \"fill in the gaps\"\n  const V3sortedPools = _(V3subgraphPools).sortBy(pool => -pool.tvlUSD).value();\n  /// Finding pools with greater reserveUSD on v2 than tvlUSD on v3, or if there is no v3 liquidity\n  const buildV2Pools = [];\n  V2topByTVLSortedPools.forEach(V2subgraphPool => {\n    const V3subgraphPool = V3sortedPools.find(pool => pool.token0.id == V2subgraphPool.token0.id && pool.token1.id == V2subgraphPool.token1.id || pool.token0.id == V2subgraphPool.token1.id && pool.token1.id == V2subgraphPool.token0.id);\n    if (V3subgraphPool) {\n      if (V2subgraphPool.reserveUSD > V3subgraphPool.tvlUSD) {\n        log.info({\n          token0: V2subgraphPool.token0.id,\n          token1: V2subgraphPool.token1.id,\n          v2reserveUSD: V2subgraphPool.reserveUSD,\n          v3tvlUSD: V3subgraphPool.tvlUSD\n        }, `MixedRoute heuristic, found a V2 pool with higher liquidity than its V3 counterpart`);\n        buildV2Pools.push(V2subgraphPool);\n      }\n    } else {\n      log.info({\n        token0: V2subgraphPool.token0.id,\n        token1: V2subgraphPool.token1.id,\n        v2reserveUSD: V2subgraphPool.reserveUSD\n      }, `MixedRoute heuristic, found a V2 pool with no V3 counterpart`);\n      buildV2Pools.push(V2subgraphPool);\n    }\n  });\n  log.info(buildV2Pools.length, `Number of V2 candidate pools that fit first heuristic`);\n  const subgraphPools = [...buildV2Pools, ...V3sortedPools];\n  const tokenAddresses = _(subgraphPools).flatMap(subgraphPool => [subgraphPool.token0.id, subgraphPool.token1.id]).compact().uniq().value();\n  log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} pools we are considering`);\n  const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {\n    blockNumber\n  });\n  const V3tokenPairsRaw = _.map(V3sortedPools, subgraphPool => {\n    const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n    const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n    let fee;\n    try {\n      fee = parseFeeAmount(subgraphPool.feeTier);\n    } catch (err) {\n      log.info({\n        subgraphPool\n      }, `Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${subgraphPool.feeTier} because fee tier not supported`);\n      return undefined;\n    }\n    if (!tokenA || !tokenB) {\n      log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${fee} because ${tokenA ? subgraphPool.token1.id : subgraphPool.token0.id} not found by token provider`);\n      return undefined;\n    }\n    return [tokenA, tokenB, fee];\n  });\n  const V3tokenPairs = _.compact(V3tokenPairsRaw);\n  const V2tokenPairsRaw = _.map(buildV2Pools, subgraphPool => {\n    const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n    const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n    if (!tokenA || !tokenB) {\n      log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}`);\n      return undefined;\n    }\n    return [tokenA, tokenB];\n  });\n  const V2tokenPairs = _.compact(V2tokenPairsRaw);\n  const [V2poolAccessor, V3poolAccessor] = await Promise.all([v2poolProvider.getPools(V2tokenPairs, {\n    blockNumber\n  }), v3poolProvider.getPools(V3tokenPairs, {\n    blockNumber\n  })]);\n  /// @dev a bit tricky here since the original V2CandidateSelections object included pools that we may have dropped\n  /// as part of the heuristic. We need to reconstruct a new object with the v3 pools too.\n  const buildPoolsBySelection = key => {\n    return [...buildV2Pools.filter(pool => V2candidatePools.selections[key].map(p => p.id).includes(pool.id)), ...V3candidatePools.selections[key]];\n  };\n  const poolsBySelection = {\n    protocol: Protocol.MIXED,\n    selections: {\n      topByBaseWithTokenIn: buildPoolsBySelection('topByBaseWithTokenIn'),\n      topByBaseWithTokenOut: buildPoolsBySelection('topByBaseWithTokenOut'),\n      topByDirectSwapPool: buildPoolsBySelection('topByDirectSwapPool'),\n      topByEthQuoteTokenPool: buildPoolsBySelection('topByEthQuoteTokenPool'),\n      topByTVL: buildPoolsBySelection('topByTVL'),\n      topByTVLUsingTokenIn: buildPoolsBySelection('topByTVLUsingTokenIn'),\n      topByTVLUsingTokenOut: buildPoolsBySelection('topByTVLUsingTokenOut'),\n      topByTVLUsingTokenInSecondHops: buildPoolsBySelection('topByTVLUsingTokenInSecondHops'),\n      topByTVLUsingTokenOutSecondHops: buildPoolsBySelection('topByTVLUsingTokenOutSecondHops')\n    }\n  };\n  return {\n    V2poolAccessor,\n    V3poolAccessor,\n    candidatePools: poolsBySelection,\n    subgraphPools\n  };\n}","map":{"version":3,"sources":["../../../../../src/routers/alpha-router/functions/get-candidate-pools.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Protocol } from '@uniswap/router-sdk';\nimport { TradeType } from '@uniswap/sdk-core';\nimport { FeeAmount } from '@uniswap/v3-sdk';\nimport _ from 'lodash';\nimport { CELO, CELO_ALFAJORES, CEUR_CELO, CEUR_CELO_ALFAJORES, CUSD_CELO, CUSD_CELO_ALFAJORES, DAI_ARBITRUM, DAI_ARBITRUM_RINKEBY, DAI_BSC, DAI_MAINNET, DAI_MOONBEAM, DAI_OPTIMISM, DAI_OPTIMISM_GOERLI, DAI_OPTIMISTIC_KOVAN, DAI_POLYGON_MUMBAI, DAI_RINKEBY_1, DAI_RINKEBY_2, FEI_MAINNET, USDC_ARBITRUM, USDC_ARBITRUM_GOERLI, USDC_BSC, USDC_ETHEREUM_GNOSIS, USDC_MAINNET, USDC_MOONBEAM, USDC_OPTIMISM, USDC_OPTIMISM_GOERLI, USDC_OPTIMISTIC_KOVAN, USDC_POLYGON, USDT_ARBITRUM, USDT_ARBITRUM_RINKEBY, USDT_BSC, USDT_MAINNET, USDT_OPTIMISM, USDT_OPTIMISM_GOERLI, USDT_OPTIMISTIC_KOVAN, WBTC_ARBITRUM, WBTC_GNOSIS, WBTC_MAINNET, WBTC_MOONBEAM, WBTC_OPTIMISM, WBTC_OPTIMISM_GOERLI, WBTC_OPTIMISTIC_KOVAN, WGLMR_MOONBEAM, WMATIC_POLYGON, WMATIC_POLYGON_MUMBAI, WXDAI_GNOSIS, } from '../../../providers/token-provider';\nimport { ChainId, WRAPPED_NATIVE_CURRENCY } from '../../../util';\nimport { parseFeeAmount, unparseFeeAmount } from '../../../util/amounts';\nimport { log } from '../../../util/log';\nimport { metric, MetricLoggerUnit } from '../../../util/metric';\nconst baseTokensByChain = {\n    [ChainId.MAINNET]: [\n        USDC_MAINNET,\n        USDT_MAINNET,\n        WBTC_MAINNET,\n        DAI_MAINNET,\n        WRAPPED_NATIVE_CURRENCY[1],\n        FEI_MAINNET,\n    ],\n    [ChainId.RINKEBY]: [DAI_RINKEBY_1, DAI_RINKEBY_2],\n    [ChainId.OPTIMISM]: [\n        DAI_OPTIMISM,\n        USDC_OPTIMISM,\n        USDT_OPTIMISM,\n        WBTC_OPTIMISM,\n    ],\n    [ChainId.OPTIMISM_GOERLI]: [\n        DAI_OPTIMISM_GOERLI,\n        USDC_OPTIMISM_GOERLI,\n        USDT_OPTIMISM_GOERLI,\n        WBTC_OPTIMISM_GOERLI,\n    ],\n    [ChainId.OPTIMISTIC_KOVAN]: [\n        DAI_OPTIMISTIC_KOVAN,\n        USDC_OPTIMISTIC_KOVAN,\n        WBTC_OPTIMISTIC_KOVAN,\n        USDT_OPTIMISTIC_KOVAN,\n    ],\n    [ChainId.ARBITRUM_ONE]: [\n        DAI_ARBITRUM,\n        USDC_ARBITRUM,\n        WBTC_ARBITRUM,\n        USDT_ARBITRUM,\n    ],\n    [ChainId.ARBITRUM_RINKEBY]: [DAI_ARBITRUM_RINKEBY, USDT_ARBITRUM_RINKEBY],\n    [ChainId.ARBITRUM_GOERLI]: [USDC_ARBITRUM_GOERLI],\n    [ChainId.POLYGON]: [USDC_POLYGON, WMATIC_POLYGON],\n    [ChainId.POLYGON_MUMBAI]: [DAI_POLYGON_MUMBAI, WMATIC_POLYGON_MUMBAI],\n    [ChainId.CELO]: [CUSD_CELO, CEUR_CELO, CELO],\n    [ChainId.CELO_ALFAJORES]: [\n        CUSD_CELO_ALFAJORES,\n        CEUR_CELO_ALFAJORES,\n        CELO_ALFAJORES,\n    ],\n    [ChainId.GNOSIS]: [WBTC_GNOSIS, WXDAI_GNOSIS, USDC_ETHEREUM_GNOSIS],\n    [ChainId.MOONBEAM]: [\n        DAI_MOONBEAM,\n        USDC_MOONBEAM,\n        WBTC_MOONBEAM,\n        WGLMR_MOONBEAM,\n    ],\n    [ChainId.BSC]: [\n        DAI_BSC,\n        USDC_BSC,\n        USDT_BSC,\n    ],\n};\nexport async function getV3CandidatePools({ tokenIn, tokenOut, routeType, routingConfig, subgraphProvider, tokenProvider, poolProvider, blockedTokenListProvider, chainId, }) {\n    var _a, _b, _c, _d, _e;\n    const { blockNumber, v3PoolSelection: { topN, topNDirectSwaps, topNTokenInOut, topNSecondHop, topNWithEachBaseToken, topNWithBaseToken, }, } = routingConfig;\n    const tokenInAddress = tokenIn.address.toLowerCase();\n    const tokenOutAddress = tokenOut.address.toLowerCase();\n    const beforeSubgraphPools = Date.now();\n    const allPoolsRaw = await subgraphProvider.getPools(tokenIn, tokenOut, {\n        blockNumber,\n    });\n    log.info({ samplePools: allPoolsRaw.slice(0, 3) }, 'Got all pools from V3 subgraph provider');\n    const allPools = _.map(allPoolsRaw, (pool) => {\n        return {\n            ...pool,\n            token0: {\n                ...pool.token0,\n                id: pool.token0.id.toLowerCase(),\n            },\n            token1: {\n                ...pool.token1,\n                id: pool.token1.id.toLowerCase(),\n            },\n        };\n    });\n    metric.putMetric('V3SubgraphPoolsLoad', Date.now() - beforeSubgraphPools, MetricLoggerUnit.Milliseconds);\n    // Only consider pools where neither tokens are in the blocked token list.\n    let filteredPools = allPools;\n    if (blockedTokenListProvider) {\n        filteredPools = [];\n        for (const pool of allPools) {\n            const token0InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token0.id);\n            const token1InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token1.id);\n            if (token0InBlocklist || token1InBlocklist) {\n                continue;\n            }\n            filteredPools.push(pool);\n        }\n    }\n    const subgraphPoolsSorted = _(filteredPools)\n        .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n        .value();\n    log.info(`After filtering blocked tokens went from ${allPools.length} to ${subgraphPoolsSorted.length}.`);\n    const poolAddressesSoFar = new Set();\n    const addToAddressSet = (pools) => {\n        _(pools)\n            .map((pool) => pool.id)\n            .forEach((poolAddress) => poolAddressesSoFar.add(poolAddress));\n    };\n    const baseTokens = (_a = baseTokensByChain[chainId]) !== null && _a !== void 0 ? _a : [];\n    const topByBaseWithTokenIn = _(baseTokens)\n        .flatMap((token) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            const tokenAddress = token.address.toLowerCase();\n            return ((subgraphPool.token0.id == tokenAddress &&\n                subgraphPool.token1.id == tokenInAddress) ||\n                (subgraphPool.token1.id == tokenAddress &&\n                    subgraphPool.token0.id == tokenInAddress));\n        })\n            .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n            .slice(0, topNWithEachBaseToken)\n            .value();\n    })\n        .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n        .slice(0, topNWithBaseToken)\n        .value();\n    const topByBaseWithTokenOut = _(baseTokens)\n        .flatMap((token) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            const tokenAddress = token.address.toLowerCase();\n            return ((subgraphPool.token0.id == tokenAddress &&\n                subgraphPool.token1.id == tokenOutAddress) ||\n                (subgraphPool.token1.id == tokenAddress &&\n                    subgraphPool.token0.id == tokenOutAddress));\n        })\n            .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n            .slice(0, topNWithEachBaseToken)\n            .value();\n    })\n        .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n        .slice(0, topNWithBaseToken)\n        .value();\n    let top2DirectSwapPool = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return (!poolAddressesSoFar.has(subgraphPool.id) &&\n            ((subgraphPool.token0.id == tokenInAddress &&\n                subgraphPool.token1.id == tokenOutAddress) ||\n                (subgraphPool.token1.id == tokenInAddress &&\n                    subgraphPool.token0.id == tokenOutAddress)));\n    })\n        .slice(0, topNDirectSwaps)\n        .value();\n    if (top2DirectSwapPool.length == 0 && topNDirectSwaps > 0) {\n        // If we requested direct swap pools but did not find any in the subgraph query.\n        // Optimistically add them into the query regardless. Invalid pools ones will be dropped anyway\n        // when we query the pool on-chain. Ensures that new pools for new pairs can be swapped on immediately.\n        top2DirectSwapPool = _.map([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW, FeeAmount.LOWEST], (feeAmount) => {\n            const { token0, token1, poolAddress } = poolProvider.getPoolAddress(tokenIn, tokenOut, feeAmount);\n            return {\n                id: poolAddress,\n                feeTier: unparseFeeAmount(feeAmount),\n                liquidity: '10000',\n                token0: {\n                    id: token0.address,\n                },\n                token1: {\n                    id: token1.address,\n                },\n                tvlETH: 10000,\n                tvlUSD: 10000,\n            };\n        });\n    }\n    addToAddressSet(top2DirectSwapPool);\n    const wrappedNativeAddress = (_b = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _b === void 0 ? void 0 : _b.address;\n    // Main reason we need this is for gas estimates, only needed if token out is not native.\n    // We don't check the seen address set because if we've already added pools for getting native quotes\n    // theres no need to add more.\n    let top2EthQuoteTokenPool = [];\n    if ((((_c = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _c === void 0 ? void 0 : _c.symbol) ==\n        ((_d = WRAPPED_NATIVE_CURRENCY[ChainId.MAINNET]) === null || _d === void 0 ? void 0 : _d.symbol) &&\n        tokenOut.symbol != 'WETH' &&\n        tokenOut.symbol != 'WETH9' &&\n        tokenOut.symbol != 'ETH') ||\n        (((_e = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _e === void 0 ? void 0 : _e.symbol) == WMATIC_POLYGON.symbol &&\n            tokenOut.symbol != 'MATIC' &&\n            tokenOut.symbol != 'WMATIC')) {\n        top2EthQuoteTokenPool = _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            if (routeType == TradeType.EXACT_INPUT) {\n                return ((subgraphPool.token0.id == wrappedNativeAddress &&\n                    subgraphPool.token1.id == tokenOutAddress) ||\n                    (subgraphPool.token1.id == wrappedNativeAddress &&\n                        subgraphPool.token0.id == tokenOutAddress));\n            }\n            else {\n                return ((subgraphPool.token0.id == wrappedNativeAddress &&\n                    subgraphPool.token1.id == tokenInAddress) ||\n                    (subgraphPool.token1.id == wrappedNativeAddress &&\n                        subgraphPool.token0.id == tokenInAddress));\n            }\n        })\n            .slice(0, 1)\n            .value();\n    }\n    addToAddressSet(top2EthQuoteTokenPool);\n    const topByTVL = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return !poolAddressesSoFar.has(subgraphPool.id);\n    })\n        .slice(0, topN)\n        .value();\n    addToAddressSet(topByTVL);\n    const topByTVLUsingTokenIn = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return (!poolAddressesSoFar.has(subgraphPool.id) &&\n            (subgraphPool.token0.id == tokenInAddress ||\n                subgraphPool.token1.id == tokenInAddress));\n    })\n        .slice(0, topNTokenInOut)\n        .value();\n    addToAddressSet(topByTVLUsingTokenIn);\n    const topByTVLUsingTokenOut = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return (!poolAddressesSoFar.has(subgraphPool.id) &&\n            (subgraphPool.token0.id == tokenOutAddress ||\n                subgraphPool.token1.id == tokenOutAddress));\n    })\n        .slice(0, topNTokenInOut)\n        .value();\n    addToAddressSet(topByTVLUsingTokenOut);\n    const topByTVLUsingTokenInSecondHops = _(topByTVLUsingTokenIn)\n        .map((subgraphPool) => {\n        return tokenInAddress == subgraphPool.token0.id\n            ? subgraphPool.token1.id\n            : subgraphPool.token0.id;\n    })\n        .flatMap((secondHopId) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            return (!poolAddressesSoFar.has(subgraphPool.id) &&\n                (subgraphPool.token0.id == secondHopId ||\n                    subgraphPool.token1.id == secondHopId));\n        })\n            .slice(0, topNSecondHop)\n            .value();\n    })\n        .uniqBy((pool) => pool.id)\n        .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n        .slice(0, topNSecondHop)\n        .value();\n    addToAddressSet(topByTVLUsingTokenInSecondHops);\n    const topByTVLUsingTokenOutSecondHops = _(topByTVLUsingTokenOut)\n        .map((subgraphPool) => {\n        return tokenOutAddress == subgraphPool.token0.id\n            ? subgraphPool.token1.id\n            : subgraphPool.token0.id;\n    })\n        .flatMap((secondHopId) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            return (!poolAddressesSoFar.has(subgraphPool.id) &&\n                (subgraphPool.token0.id == secondHopId ||\n                    subgraphPool.token1.id == secondHopId));\n        })\n            .slice(0, topNSecondHop)\n            .value();\n    })\n        .uniqBy((pool) => pool.id)\n        .sortBy((tokenListPool) => -tokenListPool.tvlUSD)\n        .slice(0, topNSecondHop)\n        .value();\n    addToAddressSet(topByTVLUsingTokenOutSecondHops);\n    const subgraphPools = _([\n        ...topByBaseWithTokenIn,\n        ...topByBaseWithTokenOut,\n        ...top2DirectSwapPool,\n        ...top2EthQuoteTokenPool,\n        ...topByTVL,\n        ...topByTVLUsingTokenIn,\n        ...topByTVLUsingTokenOut,\n        ...topByTVLUsingTokenInSecondHops,\n        ...topByTVLUsingTokenOutSecondHops,\n    ])\n        .compact()\n        .uniqBy((pool) => pool.id)\n        .value();\n    const tokenAddresses = _(subgraphPools)\n        .flatMap((subgraphPool) => [subgraphPool.token0.id, subgraphPool.token1.id])\n        .compact()\n        .uniq()\n        .value();\n    log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} V3 pools we are considering`);\n    const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {\n        blockNumber,\n    });\n    const printV3SubgraphPool = (s) => {\n        var _a, _b, _c, _d;\n        return `${(_b = (_a = tokenAccessor.getTokenByAddress(s.token0.id)) === null || _a === void 0 ? void 0 : _a.symbol) !== null && _b !== void 0 ? _b : s.token0.id}/${(_d = (_c = tokenAccessor.getTokenByAddress(s.token1.id)) === null || _c === void 0 ? void 0 : _c.symbol) !== null && _d !== void 0 ? _d : s.token1.id}/${s.feeTier}`;\n    };\n    log.info({\n        topByBaseWithTokenIn: topByBaseWithTokenIn.map(printV3SubgraphPool),\n        topByBaseWithTokenOut: topByBaseWithTokenOut.map(printV3SubgraphPool),\n        topByTVL: topByTVL.map(printV3SubgraphPool),\n        topByTVLUsingTokenIn: topByTVLUsingTokenIn.map(printV3SubgraphPool),\n        topByTVLUsingTokenOut: topByTVLUsingTokenOut.map(printV3SubgraphPool),\n        topByTVLUsingTokenInSecondHops: topByTVLUsingTokenInSecondHops.map(printV3SubgraphPool),\n        topByTVLUsingTokenOutSecondHops: topByTVLUsingTokenOutSecondHops.map(printV3SubgraphPool),\n        top2DirectSwap: top2DirectSwapPool.map(printV3SubgraphPool),\n        top2EthQuotePool: top2EthQuoteTokenPool.map(printV3SubgraphPool),\n    }, `V3 Candidate Pools`);\n    const tokenPairsRaw = _.map(subgraphPools, (subgraphPool) => {\n        const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n        const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n        let fee;\n        try {\n            fee = parseFeeAmount(subgraphPool.feeTier);\n        }\n        catch (err) {\n            log.info({ subgraphPool }, `Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${subgraphPool.feeTier} because fee tier not supported`);\n            return undefined;\n        }\n        if (!tokenA || !tokenB) {\n            log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${fee} because ${tokenA ? subgraphPool.token1.id : subgraphPool.token0.id} not found by token provider`);\n            return undefined;\n        }\n        return [tokenA, tokenB, fee];\n    });\n    const tokenPairs = _.compact(tokenPairsRaw);\n    const beforePoolsLoad = Date.now();\n    const poolAccessor = await poolProvider.getPools(tokenPairs);\n    metric.putMetric('V3PoolsLoad', Date.now() - beforePoolsLoad, MetricLoggerUnit.Milliseconds);\n    const poolsBySelection = {\n        protocol: Protocol.V3,\n        selections: {\n            topByBaseWithTokenIn,\n            topByBaseWithTokenOut,\n            topByDirectSwapPool: top2DirectSwapPool,\n            topByEthQuoteTokenPool: top2EthQuoteTokenPool,\n            topByTVL,\n            topByTVLUsingTokenIn,\n            topByTVLUsingTokenOut,\n            topByTVLUsingTokenInSecondHops,\n            topByTVLUsingTokenOutSecondHops,\n        },\n    };\n    return { poolAccessor, candidatePools: poolsBySelection, subgraphPools };\n}\nexport async function getV2CandidatePools({ tokenIn, tokenOut, routeType, routingConfig, subgraphProvider, tokenProvider, poolProvider, blockedTokenListProvider, chainId, }) {\n    var _a;\n    const { blockNumber, v2PoolSelection: { topN, topNDirectSwaps, topNTokenInOut, topNSecondHop, topNWithEachBaseToken, topNWithBaseToken, }, } = routingConfig;\n    const tokenInAddress = tokenIn.address.toLowerCase();\n    const tokenOutAddress = tokenOut.address.toLowerCase();\n    const beforeSubgraphPools = Date.now();\n    const allPoolsRaw = await subgraphProvider.getPools(tokenIn, tokenOut, {\n        blockNumber,\n    });\n    const allPools = _.map(allPoolsRaw, (pool) => {\n        return {\n            ...pool,\n            token0: {\n                ...pool.token0,\n                id: pool.token0.id.toLowerCase(),\n            },\n            token1: {\n                ...pool.token1,\n                id: pool.token1.id.toLowerCase(),\n            },\n        };\n    });\n    metric.putMetric('V2SubgraphPoolsLoad', Date.now() - beforeSubgraphPools, MetricLoggerUnit.Milliseconds);\n    // Only consider pools where neither tokens are in the blocked token list.\n    let filteredPools = allPools;\n    if (blockedTokenListProvider) {\n        filteredPools = [];\n        for (const pool of allPools) {\n            const token0InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token0.id);\n            const token1InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token1.id);\n            if (token0InBlocklist || token1InBlocklist) {\n                continue;\n            }\n            filteredPools.push(pool);\n        }\n    }\n    const subgraphPoolsSorted = _(filteredPools)\n        .sortBy((tokenListPool) => -tokenListPool.reserve)\n        .value();\n    log.info(`After filtering blocked tokens went from ${allPools.length} to ${subgraphPoolsSorted.length}.`);\n    const poolAddressesSoFar = new Set();\n    const addToAddressSet = (pools) => {\n        _(pools)\n            .map((pool) => pool.id)\n            .forEach((poolAddress) => poolAddressesSoFar.add(poolAddress));\n    };\n    const baseTokens = (_a = baseTokensByChain[chainId]) !== null && _a !== void 0 ? _a : [];\n    const topByBaseWithTokenIn = _(baseTokens)\n        .flatMap((token) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            const tokenAddress = token.address.toLowerCase();\n            return ((subgraphPool.token0.id == tokenAddress &&\n                subgraphPool.token1.id == tokenInAddress) ||\n                (subgraphPool.token1.id == tokenAddress &&\n                    subgraphPool.token0.id == tokenInAddress));\n        })\n            .sortBy((tokenListPool) => -tokenListPool.reserve)\n            .slice(0, topNWithEachBaseToken)\n            .value();\n    })\n        .sortBy((tokenListPool) => -tokenListPool.reserve)\n        .slice(0, topNWithBaseToken)\n        .value();\n    const topByBaseWithTokenOut = _(baseTokens)\n        .flatMap((token) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            const tokenAddress = token.address.toLowerCase();\n            return ((subgraphPool.token0.id == tokenAddress &&\n                subgraphPool.token1.id == tokenOutAddress) ||\n                (subgraphPool.token1.id == tokenAddress &&\n                    subgraphPool.token0.id == tokenOutAddress));\n        })\n            .sortBy((tokenListPool) => -tokenListPool.reserve)\n            .slice(0, topNWithEachBaseToken)\n            .value();\n    })\n        .sortBy((tokenListPool) => -tokenListPool.reserve)\n        .slice(0, topNWithBaseToken)\n        .value();\n    // Always add the direct swap pool into the mix regardless of if it exists in the subgraph pool list.\n    // Ensures that new pools can be swapped on immediately, and that if a pool was filtered out of the\n    // subgraph query for some reason (e.g. trackedReserveETH was 0), then we still consider it.\n    let topByDirectSwapPool = [];\n    if (topNDirectSwaps != 0) {\n        const { token0, token1, poolAddress } = poolProvider.getPoolAddress(tokenIn, tokenOut);\n        topByDirectSwapPool = [\n            {\n                id: poolAddress,\n                token0: {\n                    id: token0.address,\n                },\n                token1: {\n                    id: token1.address,\n                },\n                supply: 10000,\n                reserve: 10000,\n                reserveUSD: 10000, // Not used. Set to arbitrary number.\n            },\n        ];\n    }\n    addToAddressSet(topByDirectSwapPool);\n    const wethAddress = WRAPPED_NATIVE_CURRENCY[chainId].address;\n    // Main reason we need this is for gas estimates, only needed if token out is not ETH.\n    // We don't check the seen address set because if we've already added pools for getting ETH quotes\n    // theres no need to add more.\n    // Note: we do not need to check other native currencies for the V2 Protocol\n    let topByEthQuoteTokenPool = [];\n    if (tokenOut.symbol != 'WETH' &&\n        tokenOut.symbol != 'WETH9' &&\n        tokenOut.symbol != 'ETH') {\n        topByEthQuoteTokenPool = _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            if (routeType == TradeType.EXACT_INPUT) {\n                return ((subgraphPool.token0.id == wethAddress &&\n                    subgraphPool.token1.id == tokenOutAddress) ||\n                    (subgraphPool.token1.id == wethAddress &&\n                        subgraphPool.token0.id == tokenOutAddress));\n            }\n            else {\n                return ((subgraphPool.token0.id == wethAddress &&\n                    subgraphPool.token1.id == tokenInAddress) ||\n                    (subgraphPool.token1.id == wethAddress &&\n                        subgraphPool.token0.id == tokenInAddress));\n            }\n        })\n            .slice(0, 1)\n            .value();\n    }\n    addToAddressSet(topByEthQuoteTokenPool);\n    const topByTVL = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return !poolAddressesSoFar.has(subgraphPool.id);\n    })\n        .slice(0, topN)\n        .value();\n    addToAddressSet(topByTVL);\n    const topByTVLUsingTokenIn = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return (!poolAddressesSoFar.has(subgraphPool.id) &&\n            (subgraphPool.token0.id == tokenInAddress ||\n                subgraphPool.token1.id == tokenInAddress));\n    })\n        .slice(0, topNTokenInOut)\n        .value();\n    addToAddressSet(topByTVLUsingTokenIn);\n    const topByTVLUsingTokenOut = _(subgraphPoolsSorted)\n        .filter((subgraphPool) => {\n        return (!poolAddressesSoFar.has(subgraphPool.id) &&\n            (subgraphPool.token0.id == tokenOutAddress ||\n                subgraphPool.token1.id == tokenOutAddress));\n    })\n        .slice(0, topNTokenInOut)\n        .value();\n    addToAddressSet(topByTVLUsingTokenOut);\n    const topByTVLUsingTokenInSecondHops = _(topByTVLUsingTokenIn)\n        .map((subgraphPool) => {\n        return tokenInAddress == subgraphPool.token0.id\n            ? subgraphPool.token1.id\n            : subgraphPool.token0.id;\n    })\n        .flatMap((secondHopId) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            return (!poolAddressesSoFar.has(subgraphPool.id) &&\n                (subgraphPool.token0.id == secondHopId ||\n                    subgraphPool.token1.id == secondHopId));\n        })\n            .slice(0, topNSecondHop)\n            .value();\n    })\n        .uniqBy((pool) => pool.id)\n        .sortBy((tokenListPool) => -tokenListPool.reserve)\n        .slice(0, topNSecondHop)\n        .value();\n    addToAddressSet(topByTVLUsingTokenInSecondHops);\n    const topByTVLUsingTokenOutSecondHops = _(topByTVLUsingTokenOut)\n        .map((subgraphPool) => {\n        return tokenOutAddress == subgraphPool.token0.id\n            ? subgraphPool.token1.id\n            : subgraphPool.token0.id;\n    })\n        .flatMap((secondHopId) => {\n        return _(subgraphPoolsSorted)\n            .filter((subgraphPool) => {\n            return (!poolAddressesSoFar.has(subgraphPool.id) &&\n                (subgraphPool.token0.id == secondHopId ||\n                    subgraphPool.token1.id == secondHopId));\n        })\n            .slice(0, topNSecondHop)\n            .value();\n    })\n        .uniqBy((pool) => pool.id)\n        .sortBy((tokenListPool) => -tokenListPool.reserve)\n        .slice(0, topNSecondHop)\n        .value();\n    addToAddressSet(topByTVLUsingTokenOutSecondHops);\n    const subgraphPools = _([\n        ...topByBaseWithTokenIn,\n        ...topByBaseWithTokenOut,\n        ...topByDirectSwapPool,\n        ...topByEthQuoteTokenPool,\n        ...topByTVL,\n        ...topByTVLUsingTokenIn,\n        ...topByTVLUsingTokenOut,\n        ...topByTVLUsingTokenInSecondHops,\n        ...topByTVLUsingTokenOutSecondHops,\n    ])\n        .compact()\n        .uniqBy((pool) => pool.id)\n        .value();\n    const tokenAddresses = _(subgraphPools)\n        .flatMap((subgraphPool) => [subgraphPool.token0.id, subgraphPool.token1.id])\n        .compact()\n        .uniq()\n        .value();\n    log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} V2 pools we are considering`);\n    const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {\n        blockNumber,\n    });\n    const printV2SubgraphPool = (s) => {\n        var _a, _b, _c, _d;\n        return `${(_b = (_a = tokenAccessor.getTokenByAddress(s.token0.id)) === null || _a === void 0 ? void 0 : _a.symbol) !== null && _b !== void 0 ? _b : s.token0.id}/${(_d = (_c = tokenAccessor.getTokenByAddress(s.token1.id)) === null || _c === void 0 ? void 0 : _c.symbol) !== null && _d !== void 0 ? _d : s.token1.id}`;\n    };\n    log.info({\n        topByBaseWithTokenIn: topByBaseWithTokenIn.map(printV2SubgraphPool),\n        topByBaseWithTokenOut: topByBaseWithTokenOut.map(printV2SubgraphPool),\n        topByTVL: topByTVL.map(printV2SubgraphPool),\n        topByTVLUsingTokenIn: topByTVLUsingTokenIn.map(printV2SubgraphPool),\n        topByTVLUsingTokenOut: topByTVLUsingTokenOut.map(printV2SubgraphPool),\n        topByTVLUsingTokenInSecondHops: topByTVLUsingTokenInSecondHops.map(printV2SubgraphPool),\n        topByTVLUsingTokenOutSecondHops: topByTVLUsingTokenOutSecondHops.map(printV2SubgraphPool),\n        top2DirectSwap: topByDirectSwapPool.map(printV2SubgraphPool),\n        top2EthQuotePool: topByEthQuoteTokenPool.map(printV2SubgraphPool),\n    }, `V2 Candidate pools`);\n    const tokenPairsRaw = _.map(subgraphPools, (subgraphPool) => {\n        const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n        const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n        if (!tokenA || !tokenB) {\n            log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}`);\n            return undefined;\n        }\n        return [tokenA, tokenB];\n    });\n    const tokenPairs = _.compact(tokenPairsRaw);\n    const beforePoolsLoad = Date.now();\n    const poolAccessor = await poolProvider.getPools(tokenPairs, { blockNumber });\n    metric.putMetric('V2PoolsLoad', Date.now() - beforePoolsLoad, MetricLoggerUnit.Milliseconds);\n    const poolsBySelection = {\n        protocol: Protocol.V2,\n        selections: {\n            topByBaseWithTokenIn,\n            topByBaseWithTokenOut,\n            topByDirectSwapPool,\n            topByEthQuoteTokenPool: topByEthQuoteTokenPool,\n            topByTVL,\n            topByTVLUsingTokenIn,\n            topByTVLUsingTokenOut,\n            topByTVLUsingTokenInSecondHops,\n            topByTVLUsingTokenOutSecondHops,\n        },\n    };\n    return { poolAccessor, candidatePools: poolsBySelection, subgraphPools };\n}\nexport async function getMixedRouteCandidatePools({ tokenIn, tokenOut, routeType, routingConfig, v3subgraphProvider, v2subgraphProvider, tokenProvider, v3poolProvider, v2poolProvider, blockedTokenListProvider, chainId, }) {\n    const { blockNumber } = routingConfig;\n    const { subgraphPools: V3subgraphPools, candidatePools: V3candidatePools } = await getV3CandidatePools({\n        tokenIn,\n        tokenOut,\n        tokenProvider,\n        blockedTokenListProvider,\n        poolProvider: v3poolProvider,\n        routeType,\n        subgraphProvider: v3subgraphProvider,\n        routingConfig,\n        chainId,\n    });\n    const { subgraphPools: V2subgraphPools, candidatePools: V2candidatePools } = await getV2CandidatePools({\n        tokenIn,\n        tokenOut,\n        tokenProvider,\n        blockedTokenListProvider,\n        poolProvider: v2poolProvider,\n        routeType,\n        subgraphProvider: v2subgraphProvider,\n        routingConfig,\n        chainId,\n    });\n    /**\n     * Main heuristic for pruning mixedRoutes:\n     * - we pick V2 pools with higher liq than respective V3 pools, or if the v3 pool doesn't exist\n     *\n     * This way we can reduce calls to our provider since it's possible to generate a lot of mixed routes\n     */\n    /// We only really care about pools involving the tokenIn or tokenOut explictly,\n    /// since there's no way a long tail token in V2 would be routed through as an intermediary\n    const V2topByTVLPoolIds = new Set([\n        ...V2candidatePools.selections.topByTVLUsingTokenIn,\n        ...V2candidatePools.selections.topByBaseWithTokenIn,\n        /// tokenOut:\n        ...V2candidatePools.selections.topByTVLUsingTokenOut,\n        ...V2candidatePools.selections.topByBaseWithTokenOut,\n        /// Direct swap:\n        ...V2candidatePools.selections.topByDirectSwapPool,\n    ].map((poolId) => poolId.id));\n    const V2topByTVLSortedPools = _(V2subgraphPools)\n        .filter((pool) => V2topByTVLPoolIds.has(pool.id))\n        .sortBy((pool) => -pool.reserveUSD)\n        .value();\n    /// we consider all returned V3 pools for this heuristic to \"fill in the gaps\"\n    const V3sortedPools = _(V3subgraphPools)\n        .sortBy((pool) => -pool.tvlUSD)\n        .value();\n    /// Finding pools with greater reserveUSD on v2 than tvlUSD on v3, or if there is no v3 liquidity\n    const buildV2Pools = [];\n    V2topByTVLSortedPools.forEach((V2subgraphPool) => {\n        const V3subgraphPool = V3sortedPools.find((pool) => (pool.token0.id == V2subgraphPool.token0.id &&\n            pool.token1.id == V2subgraphPool.token1.id) ||\n            (pool.token0.id == V2subgraphPool.token1.id &&\n                pool.token1.id == V2subgraphPool.token0.id));\n        if (V3subgraphPool) {\n            if (V2subgraphPool.reserveUSD > V3subgraphPool.tvlUSD) {\n                log.info({\n                    token0: V2subgraphPool.token0.id,\n                    token1: V2subgraphPool.token1.id,\n                    v2reserveUSD: V2subgraphPool.reserveUSD,\n                    v3tvlUSD: V3subgraphPool.tvlUSD,\n                }, `MixedRoute heuristic, found a V2 pool with higher liquidity than its V3 counterpart`);\n                buildV2Pools.push(V2subgraphPool);\n            }\n        }\n        else {\n            log.info({\n                token0: V2subgraphPool.token0.id,\n                token1: V2subgraphPool.token1.id,\n                v2reserveUSD: V2subgraphPool.reserveUSD,\n            }, `MixedRoute heuristic, found a V2 pool with no V3 counterpart`);\n            buildV2Pools.push(V2subgraphPool);\n        }\n    });\n    log.info(buildV2Pools.length, `Number of V2 candidate pools that fit first heuristic`);\n    const subgraphPools = [...buildV2Pools, ...V3sortedPools];\n    const tokenAddresses = _(subgraphPools)\n        .flatMap((subgraphPool) => [subgraphPool.token0.id, subgraphPool.token1.id])\n        .compact()\n        .uniq()\n        .value();\n    log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} pools we are considering`);\n    const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {\n        blockNumber,\n    });\n    const V3tokenPairsRaw = _.map(V3sortedPools, (subgraphPool) => {\n        const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n        const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n        let fee;\n        try {\n            fee = parseFeeAmount(subgraphPool.feeTier);\n        }\n        catch (err) {\n            log.info({ subgraphPool }, `Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${subgraphPool.feeTier} because fee tier not supported`);\n            return undefined;\n        }\n        if (!tokenA || !tokenB) {\n            log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${fee} because ${tokenA ? subgraphPool.token1.id : subgraphPool.token0.id} not found by token provider`);\n            return undefined;\n        }\n        return [tokenA, tokenB, fee];\n    });\n    const V3tokenPairs = _.compact(V3tokenPairsRaw);\n    const V2tokenPairsRaw = _.map(buildV2Pools, (subgraphPool) => {\n        const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);\n        const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);\n        if (!tokenA || !tokenB) {\n            log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}`);\n            return undefined;\n        }\n        return [tokenA, tokenB];\n    });\n    const V2tokenPairs = _.compact(V2tokenPairsRaw);\n    const [V2poolAccessor, V3poolAccessor] = await Promise.all([\n        v2poolProvider.getPools(V2tokenPairs, {\n            blockNumber,\n        }),\n        v3poolProvider.getPools(V3tokenPairs, {\n            blockNumber,\n        }),\n    ]);\n    /// @dev a bit tricky here since the original V2CandidateSelections object included pools that we may have dropped\n    /// as part of the heuristic. We need to reconstruct a new object with the v3 pools too.\n    const buildPoolsBySelection = (key) => {\n        return [\n            ...buildV2Pools.filter((pool) => V2candidatePools.selections[key].map((p) => p.id).includes(pool.id)),\n            ...V3candidatePools.selections[key],\n        ];\n    };\n    const poolsBySelection = {\n        protocol: Protocol.MIXED,\n        selections: {\n            topByBaseWithTokenIn: buildPoolsBySelection('topByBaseWithTokenIn'),\n            topByBaseWithTokenOut: buildPoolsBySelection('topByBaseWithTokenOut'),\n            topByDirectSwapPool: buildPoolsBySelection('topByDirectSwapPool'),\n            topByEthQuoteTokenPool: buildPoolsBySelection('topByEthQuoteTokenPool'),\n            topByTVL: buildPoolsBySelection('topByTVL'),\n            topByTVLUsingTokenIn: buildPoolsBySelection('topByTVLUsingTokenIn'),\n            topByTVLUsingTokenOut: buildPoolsBySelection('topByTVLUsingTokenOut'),\n            topByTVLUsingTokenInSecondHops: buildPoolsBySelection('topByTVLUsingTokenInSecondHops'),\n            topByTVLUsingTokenOutSecondHops: buildPoolsBySelection('topByTVLUsingTokenOutSecondHops'),\n        },\n    };\n    return {\n        V2poolAccessor,\n        V3poolAccessor,\n        candidatePools: poolsBySelection,\n        subgraphPools,\n    };\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0LWNhbmRpZGF0ZS1wb29scy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9yb3V0ZXJzL2FscGhhLXJvdXRlci9mdW5jdGlvbnMvZ2V0LWNhbmRpZGF0ZS1wb29scy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDL0MsT0FBTyxFQUFTLFNBQVMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM1QyxPQUFPLENBQUMsTUFBTSxRQUFRLENBQUM7QUFPdkIsT0FBTyxFQUNMLElBQUksRUFDSixjQUFjLEVBQ2QsU0FBUyxFQUNULG1CQUFtQixFQUNuQixTQUFTLEVBQ1QsbUJBQW1CLEVBQ25CLFlBQVksRUFDWixvQkFBb0IsRUFDcEIsT0FBTyxFQUNQLFdBQVcsRUFDWCxZQUFZLEVBQ1osWUFBWSxFQUNaLG1CQUFtQixFQUNuQixvQkFBb0IsRUFDcEIsa0JBQWtCLEVBQ2xCLGFBQWEsRUFDYixhQUFhLEVBQ2IsV0FBVyxFQUVYLGFBQWEsRUFDYixvQkFBb0IsRUFDcEIsUUFBUSxFQUNSLG9CQUFvQixFQUNwQixZQUFZLEVBQ1osYUFBYSxFQUNiLGFBQWEsRUFDYixvQkFBb0IsRUFDcEIscUJBQXFCLEVBQ3JCLFlBQVksRUFDWixhQUFhLEVBQ2IscUJBQXFCLEVBQ3JCLFFBQVEsRUFDUixZQUFZLEVBQ1osYUFBYSxFQUNiLG9CQUFvQixFQUNwQixxQkFBcUIsRUFDckIsYUFBYSxFQUNiLFdBQVcsRUFDWCxZQUFZLEVBQ1osYUFBYSxFQUNiLGFBQWEsRUFDYixvQkFBb0IsRUFDcEIscUJBQXFCLEVBQ3JCLGNBQWMsRUFDZCxjQUFjLEVBQ2QscUJBQXFCLEVBQ3JCLFlBQVksR0FDYixNQUFNLG1DQUFtQyxDQUFDO0FBYTNDLE9BQU8sRUFBRSxPQUFPLEVBQUUsdUJB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"]},"metadata":{},"sourceType":"module"}