{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleSumTree = exports.ProofStep = exports.Leaf = exports.Bucket = void 0;\nconst Base_1 = require(\"./Base\");\nclass Bucket {\n  constructor(size, hashed) {\n    this.size = BigInt(size);\n    this.hashed = hashed;\n    // each node in the tree can have a parent, and a left or right sibling\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  }\n}\nexports.Bucket = Bucket;\nclass Leaf {\n  constructor(hashFn, rng, data) {\n    this.hashFn = hashFn;\n    this.rng = rng.map(x => BigInt(x));\n    this.data = data;\n  }\n  getBucket() {\n    let hashed;\n    if (this.data) {\n      hashed = this.hashFn(this.data);\n    } else {\n      hashed = Buffer.alloc(32);\n    }\n    return new Bucket(BigInt(this.rng[1]) - BigInt(this.rng[0]), hashed);\n  }\n}\nexports.Leaf = Leaf;\nclass ProofStep {\n  constructor(bucket, right) {\n    this.bucket = bucket;\n    this.right = right; // whether the bucket hash should be appeded on the right side in this step (default is left\n  }\n}\n\nexports.ProofStep = ProofStep;\nclass MerkleSumTree extends Base_1.Base {\n  constructor(leaves, hashFn) {\n    super();\n    this.leaves = leaves;\n    this.hashFn = hashFn;\n    MerkleSumTree.checkConsecutive(leaves);\n    this.buckets = [];\n    for (const l of leaves) {\n      this.buckets.push(l.getBucket());\n    }\n    let buckets = [];\n    for (const bucket of this.buckets) {\n      buckets.push(bucket);\n    }\n    while (buckets.length !== 1) {\n      const newBuckets = [];\n      while (buckets.length) {\n        if (buckets.length >= 2) {\n          const b1 = buckets.shift();\n          const b2 = buckets.shift();\n          const size = b1.size + b2.size;\n          const hashed = this.hashFn(Buffer.concat([this.sizeToBuffer(b1.size), this.bufferify(b1.hashed), this.sizeToBuffer(b2.size), this.bufferify(b2.hashed)]));\n          const b = new Bucket(size, hashed);\n          b2.parent = b;\n          b1.parent = b2.parent;\n          b1.right = b2;\n          b2.left = b1;\n          newBuckets.push(b);\n        } else {\n          newBuckets.push(buckets.shift());\n        }\n      }\n      buckets = newBuckets;\n    }\n    this.root = buckets[0];\n  }\n  sizeToBuffer(size) {\n    const buf = Buffer.alloc(8);\n    const view = new DataView(buf.buffer);\n    view.setBigInt64(0, BigInt(size), false); // true when little endian\n    return buf;\n  }\n  static checkConsecutive(leaves) {\n    let curr = BigInt(0);\n    for (const leaf of leaves) {\n      if (leaf.rng[0] !== curr) {\n        throw new Error('leaf ranges are invalid');\n      }\n      curr = BigInt(leaf.rng[1]);\n    }\n  }\n  // gets inclusion/exclusion proof of a bucket in the specified index\n  getProof(index) {\n    let curr = this.buckets[Number(index)];\n    const proof = [];\n    while (curr && curr.parent) {\n      const right = !!curr.right;\n      const bucket = curr.right ? curr.right : curr.left;\n      curr = curr.parent;\n      proof.push(new ProofStep(bucket, right));\n    }\n    return proof;\n  }\n  sum(arr) {\n    let total = BigInt(0);\n    for (const value of arr) {\n      total += BigInt(value);\n    }\n    return total;\n  }\n  // validates the suppplied proof for a specified leaf according to the root bucket\n  verifyProof(root, leaf, proof) {\n    const rng = [this.sum(proof.filter(x => !x.right).map(x => x.bucket.size)), BigInt(root.size) - this.sum(proof.filter(x => x.right).map(x => x.bucket.size))];\n    if (!(rng[0] === leaf.rng[0] && rng[1] === leaf.rng[1])) {\n      // supplied steps are not routing to the range specified\n      return false;\n    }\n    let curr = leaf.getBucket();\n    let hashed;\n    for (const step of proof) {\n      if (step.right) {\n        hashed = this.hashFn(Buffer.concat([this.sizeToBuffer(curr.size), this.bufferify(curr.hashed), this.sizeToBuffer(step.bucket.size), this.bufferify(step.bucket.hashed)]));\n      } else {\n        hashed = this.hashFn(Buffer.concat([this.sizeToBuffer(step.bucket.size), this.bufferify(step.bucket.hashed), this.sizeToBuffer(curr.size), this.bufferify(curr.hashed)]));\n      }\n      curr = new Bucket(BigInt(curr.size) + BigInt(step.bucket.size), hashed);\n    }\n    return curr.size === root.size && curr.hashed.toString('hex') === root.hashed.toString('hex');\n  }\n}\nexports.MerkleSumTree = MerkleSumTree;","map":{"version":3,"names":["Object","defineProperty","exports","value","MerkleSumTree","ProofStep","Leaf","Bucket","Base_1","require","constructor","size","hashed","BigInt","parent","left","right","hashFn","rng","data","map","x","getBucket","Buffer","alloc","bucket","Base","leaves","checkConsecutive","buckets","l","push","length","newBuckets","b1","shift","b2","concat","sizeToBuffer","bufferify","b","root","buf","view","DataView","buffer","setBigInt64","curr","leaf","Error","getProof","index","Number","proof","sum","arr","total","verifyProof","filter","step","toString"],"sources":["/home/diep/freelance/interface/node_modules/merkletreejs/dist/MerkleSumTree.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleSumTree = exports.ProofStep = exports.Leaf = exports.Bucket = void 0;\nconst Base_1 = require(\"./Base\");\nclass Bucket {\n    constructor(size, hashed) {\n        this.size = BigInt(size);\n        this.hashed = hashed;\n        // each node in the tree can have a parent, and a left or right sibling\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexports.Bucket = Bucket;\nclass Leaf {\n    constructor(hashFn, rng, data) {\n        this.hashFn = hashFn;\n        this.rng = rng.map(x => BigInt(x));\n        this.data = data;\n    }\n    getBucket() {\n        let hashed;\n        if (this.data) {\n            hashed = this.hashFn(this.data);\n        }\n        else {\n            hashed = Buffer.alloc(32);\n        }\n        return new Bucket(BigInt(this.rng[1]) - BigInt(this.rng[0]), hashed);\n    }\n}\nexports.Leaf = Leaf;\nclass ProofStep {\n    constructor(bucket, right) {\n        this.bucket = bucket;\n        this.right = right; // whether the bucket hash should be appeded on the right side in this step (default is left\n    }\n}\nexports.ProofStep = ProofStep;\nclass MerkleSumTree extends Base_1.Base {\n    constructor(leaves, hashFn) {\n        super();\n        this.leaves = leaves;\n        this.hashFn = hashFn;\n        MerkleSumTree.checkConsecutive(leaves);\n        this.buckets = [];\n        for (const l of leaves) {\n            this.buckets.push(l.getBucket());\n        }\n        let buckets = [];\n        for (const bucket of this.buckets) {\n            buckets.push(bucket);\n        }\n        while (buckets.length !== 1) {\n            const newBuckets = [];\n            while (buckets.length) {\n                if (buckets.length >= 2) {\n                    const b1 = buckets.shift();\n                    const b2 = buckets.shift();\n                    const size = b1.size + b2.size;\n                    const hashed = this.hashFn(Buffer.concat([this.sizeToBuffer(b1.size), this.bufferify(b1.hashed), this.sizeToBuffer(b2.size), this.bufferify(b2.hashed)]));\n                    const b = new Bucket(size, hashed);\n                    b2.parent = b;\n                    b1.parent = b2.parent;\n                    b1.right = b2;\n                    b2.left = b1;\n                    newBuckets.push(b);\n                }\n                else {\n                    newBuckets.push(buckets.shift());\n                }\n            }\n            buckets = newBuckets;\n        }\n        this.root = buckets[0];\n    }\n    sizeToBuffer(size) {\n        const buf = Buffer.alloc(8);\n        const view = new DataView(buf.buffer);\n        view.setBigInt64(0, BigInt(size), false); // true when little endian\n        return buf;\n    }\n    static checkConsecutive(leaves) {\n        let curr = BigInt(0);\n        for (const leaf of leaves) {\n            if (leaf.rng[0] !== curr) {\n                throw new Error('leaf ranges are invalid');\n            }\n            curr = BigInt(leaf.rng[1]);\n        }\n    }\n    // gets inclusion/exclusion proof of a bucket in the specified index\n    getProof(index) {\n        let curr = this.buckets[Number(index)];\n        const proof = [];\n        while (curr && curr.parent) {\n            const right = !!curr.right;\n            const bucket = curr.right ? curr.right : curr.left;\n            curr = curr.parent;\n            proof.push(new ProofStep(bucket, right));\n        }\n        return proof;\n    }\n    sum(arr) {\n        let total = BigInt(0);\n        for (const value of arr) {\n            total += BigInt(value);\n        }\n        return total;\n    }\n    // validates the suppplied proof for a specified leaf according to the root bucket\n    verifyProof(root, leaf, proof) {\n        const rng = [this.sum(proof.filter(x => !x.right).map(x => x.bucket.size)), BigInt(root.size) - this.sum(proof.filter(x => x.right).map(x => x.bucket.size))];\n        if (!(rng[0] === leaf.rng[0] && rng[1] === leaf.rng[1])) {\n            // supplied steps are not routing to the range specified\n            return false;\n        }\n        let curr = leaf.getBucket();\n        let hashed;\n        for (const step of proof) {\n            if (step.right) {\n                hashed = this.hashFn(Buffer.concat([this.sizeToBuffer(curr.size), this.bufferify(curr.hashed), this.sizeToBuffer(step.bucket.size), this.bufferify(step.bucket.hashed)]));\n            }\n            else {\n                hashed = this.hashFn(Buffer.concat([this.sizeToBuffer(step.bucket.size), this.bufferify(step.bucket.hashed), this.sizeToBuffer(curr.size), this.bufferify(curr.hashed)]));\n            }\n            curr = new Bucket(BigInt(curr.size) + BigInt(step.bucket.size), hashed);\n        }\n        return curr.size === root.size && curr.hashed.toString('hex') === root.hashed.toString('hex');\n    }\n}\nexports.MerkleSumTree = MerkleSumTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}