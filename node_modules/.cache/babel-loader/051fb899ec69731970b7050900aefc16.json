{"ast":null,"code":"import { MixedRouteSDK, Protocol, SwapRouter as SwapRouter02, Trade } from '@uniswap/router-sdk';\nimport { TradeType } from '@uniswap/sdk-core';\nimport { SwapRouter as UniveralRouter, UNIVERSAL_ROUTER_ADDRESS } from '@uniswap/universal-router-sdk';\nimport { Route as V2RouteRaw } from '@uniswap/v2-sdk';\nimport { Route as V3RouteRaw } from '@uniswap/v3-sdk';\nimport _ from 'lodash';\nimport { CurrencyAmount, SwapType, SWAP_ROUTER_02_ADDRESSES } from '..';\nexport function buildTrade(tokenInCurrency, tokenOutCurrency, tradeType, routeAmounts) {\n  /// Removed partition because of new mixedRoutes\n  const v3RouteAmounts = _.filter(routeAmounts, routeAmount => routeAmount.protocol === Protocol.V3);\n  const v2RouteAmounts = _.filter(routeAmounts, routeAmount => routeAmount.protocol === Protocol.V2);\n  const mixedRouteAmounts = _.filter(routeAmounts, routeAmount => routeAmount.protocol === Protocol.MIXED);\n  const v3Routes = _.map(v3RouteAmounts, routeAmount => {\n    const {\n      route,\n      amount,\n      quote\n    } = routeAmount;\n    // The route, amount and quote are all in terms of wrapped tokens.\n    // When constructing the Trade object the inputAmount/outputAmount must\n    // use native currencies if specified by the user. This is so that the Trade knows to wrap/unwrap.\n    if (tradeType == TradeType.EXACT_INPUT) {\n      const amountCurrency = CurrencyAmount.fromFractionalAmount(tokenInCurrency, amount.numerator, amount.denominator);\n      const quoteCurrency = CurrencyAmount.fromFractionalAmount(tokenOutCurrency, quote.numerator, quote.denominator);\n      const routeRaw = new V3RouteRaw(route.pools, amountCurrency.currency, quoteCurrency.currency);\n      return {\n        routev3: routeRaw,\n        inputAmount: amountCurrency,\n        outputAmount: quoteCurrency\n      };\n    } else {\n      const quoteCurrency = CurrencyAmount.fromFractionalAmount(tokenInCurrency, quote.numerator, quote.denominator);\n      const amountCurrency = CurrencyAmount.fromFractionalAmount(tokenOutCurrency, amount.numerator, amount.denominator);\n      const routeCurrency = new V3RouteRaw(route.pools, quoteCurrency.currency, amountCurrency.currency);\n      return {\n        routev3: routeCurrency,\n        inputAmount: quoteCurrency,\n        outputAmount: amountCurrency\n      };\n    }\n  });\n  const v2Routes = _.map(v2RouteAmounts, routeAmount => {\n    const {\n      route,\n      amount,\n      quote\n    } = routeAmount;\n    // The route, amount and quote are all in terms of wrapped tokens.\n    // When constructing the Trade object the inputAmount/outputAmount must\n    // use native currencies if specified by the user. This is so that the Trade knows to wrap/unwrap.\n    if (tradeType == TradeType.EXACT_INPUT) {\n      const amountCurrency = CurrencyAmount.fromFractionalAmount(tokenInCurrency, amount.numerator, amount.denominator);\n      const quoteCurrency = CurrencyAmount.fromFractionalAmount(tokenOutCurrency, quote.numerator, quote.denominator);\n      const routeV2SDK = new V2RouteRaw(route.pairs, amountCurrency.currency, quoteCurrency.currency);\n      return {\n        routev2: routeV2SDK,\n        inputAmount: amountCurrency,\n        outputAmount: quoteCurrency\n      };\n    } else {\n      const quoteCurrency = CurrencyAmount.fromFractionalAmount(tokenInCurrency, quote.numerator, quote.denominator);\n      const amountCurrency = CurrencyAmount.fromFractionalAmount(tokenOutCurrency, amount.numerator, amount.denominator);\n      const routeV2SDK = new V2RouteRaw(route.pairs, quoteCurrency.currency, amountCurrency.currency);\n      return {\n        routev2: routeV2SDK,\n        inputAmount: quoteCurrency,\n        outputAmount: amountCurrency\n      };\n    }\n  });\n  const mixedRoutes = _.map(mixedRouteAmounts, routeAmount => {\n    const {\n      route,\n      amount,\n      quote\n    } = routeAmount;\n    if (tradeType != TradeType.EXACT_INPUT) {\n      throw new Error('Mixed routes are only supported for exact input trades');\n    }\n    // The route, amount and quote are all in terms of wrapped tokens.\n    // When constructing the Trade object the inputAmount/outputAmount must\n    // use native currencies if specified by the user. This is so that the Trade knows to wrap/unwrap.\n    const amountCurrency = CurrencyAmount.fromFractionalAmount(tokenInCurrency, amount.numerator, amount.denominator);\n    const quoteCurrency = CurrencyAmount.fromFractionalAmount(tokenOutCurrency, quote.numerator, quote.denominator);\n    const routeRaw = new MixedRouteSDK(route.pools, amountCurrency.currency, quoteCurrency.currency);\n    return {\n      mixedRoute: routeRaw,\n      inputAmount: amountCurrency,\n      outputAmount: quoteCurrency\n    };\n  });\n  const trade = new Trade({\n    v2Routes,\n    v3Routes,\n    mixedRoutes,\n    tradeType\n  });\n  return trade;\n}\nexport function buildSwapMethodParameters(trade, swapConfig, chainId) {\n  if (swapConfig.type == SwapType.UNIVERSAL_ROUTER) {\n    return {\n      ...UniveralRouter.swapERC20CallParameters(trade, swapConfig),\n      to: UNIVERSAL_ROUTER_ADDRESS(chainId)\n    };\n  } else if (swapConfig.type == SwapType.SWAP_ROUTER_02) {\n    const {\n      recipient,\n      slippageTolerance,\n      deadline,\n      inputTokenPermit\n    } = swapConfig;\n    return {\n      ...SwapRouter02.swapCallParameters(trade, {\n        recipient,\n        slippageTolerance,\n        deadlineOrPreviousBlockhash: deadline,\n        inputTokenPermit\n      }),\n      to: SWAP_ROUTER_02_ADDRESSES(chainId)\n    };\n  }\n  throw new Error(`Unsupported swap type ${swapConfig}`);\n}","map":{"version":3,"sources":["../../../src/util/methodParameters.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { MixedRouteSDK, Protocol, SwapRouter as SwapRouter02, Trade, } from '@uniswap/router-sdk';\nimport { TradeType } from '@uniswap/sdk-core';\nimport { SwapRouter as UniveralRouter, UNIVERSAL_ROUTER_ADDRESS, } from '@uniswap/universal-router-sdk';\nimport { Route as V2RouteRaw } from '@uniswap/v2-sdk';\nimport { Route as V3RouteRaw } from '@uniswap/v3-sdk';\nimport _ from 'lodash';\nimport { CurrencyAmount, SwapType, SWAP_ROUTER_02_ADDRESSES, } from '..';\nexport function buildTrade(tokenInCurrency, tokenOutCurrency, tradeType, routeAmounts) {\n    /// Removed partition because of new mixedRoutes\n    const v3RouteAmounts = _.filter(routeAmounts, (routeAmount) => routeAmount.protocol === Protocol.V3);\n    const v2RouteAmounts = _.filter(routeAmounts, (routeAmount) => routeAmount.protocol === Protocol.V2);\n    const mixedRouteAmounts = _.filter(routeAmounts, (routeAmount) => routeAmount.protocol === Protocol.MIXED);\n    const v3Routes = _.map(v3RouteAmounts, (routeAmount) => {\n        const { route, amount, quote } = routeAmount;\n        // The route, amount and quote are all in terms of wrapped tokens.\n        // When constructing the Trade object the inputAmount/outputAmount must\n        // use native currencies if specified by the user. This is so that the Trade knows to wrap/unwrap.\n        if (tradeType == TradeType.EXACT_INPUT) {\n            const amountCurrency = CurrencyAmount.fromFractionalAmount(tokenInCurrency, amount.numerator, amount.denominator);\n            const quoteCurrency = CurrencyAmount.fromFractionalAmount(tokenOutCurrency, quote.numerator, quote.denominator);\n            const routeRaw = new V3RouteRaw(route.pools, amountCurrency.currency, quoteCurrency.currency);\n            return {\n                routev3: routeRaw,\n                inputAmount: amountCurrency,\n                outputAmount: quoteCurrency,\n            };\n        }\n        else {\n            const quoteCurrency = CurrencyAmount.fromFractionalAmount(tokenInCurrency, quote.numerator, quote.denominator);\n            const amountCurrency = CurrencyAmount.fromFractionalAmount(tokenOutCurrency, amount.numerator, amount.denominator);\n            const routeCurrency = new V3RouteRaw(route.pools, quoteCurrency.currency, amountCurrency.currency);\n            return {\n                routev3: routeCurrency,\n                inputAmount: quoteCurrency,\n                outputAmount: amountCurrency,\n            };\n        }\n    });\n    const v2Routes = _.map(v2RouteAmounts, (routeAmount) => {\n        const { route, amount, quote } = routeAmount;\n        // The route, amount and quote are all in terms of wrapped tokens.\n        // When constructing the Trade object the inputAmount/outputAmount must\n        // use native currencies if specified by the user. This is so that the Trade knows to wrap/unwrap.\n        if (tradeType == TradeType.EXACT_INPUT) {\n            const amountCurrency = CurrencyAmount.fromFractionalAmount(tokenInCurrency, amount.numerator, amount.denominator);\n            const quoteCurrency = CurrencyAmount.fromFractionalAmount(tokenOutCurrency, quote.numerator, quote.denominator);\n            const routeV2SDK = new V2RouteRaw(route.pairs, amountCurrency.currency, quoteCurrency.currency);\n            return {\n                routev2: routeV2SDK,\n                inputAmount: amountCurrency,\n                outputAmount: quoteCurrency,\n            };\n        }\n        else {\n            const quoteCurrency = CurrencyAmount.fromFractionalAmount(tokenInCurrency, quote.numerator, quote.denominator);\n            const amountCurrency = CurrencyAmount.fromFractionalAmount(tokenOutCurrency, amount.numerator, amount.denominator);\n            const routeV2SDK = new V2RouteRaw(route.pairs, quoteCurrency.currency, amountCurrency.currency);\n            return {\n                routev2: routeV2SDK,\n                inputAmount: quoteCurrency,\n                outputAmount: amountCurrency,\n            };\n        }\n    });\n    const mixedRoutes = _.map(mixedRouteAmounts, (routeAmount) => {\n        const { route, amount, quote } = routeAmount;\n        if (tradeType != TradeType.EXACT_INPUT) {\n            throw new Error('Mixed routes are only supported for exact input trades');\n        }\n        // The route, amount and quote are all in terms of wrapped tokens.\n        // When constructing the Trade object the inputAmount/outputAmount must\n        // use native currencies if specified by the user. This is so that the Trade knows to wrap/unwrap.\n        const amountCurrency = CurrencyAmount.fromFractionalAmount(tokenInCurrency, amount.numerator, amount.denominator);\n        const quoteCurrency = CurrencyAmount.fromFractionalAmount(tokenOutCurrency, quote.numerator, quote.denominator);\n        const routeRaw = new MixedRouteSDK(route.pools, amountCurrency.currency, quoteCurrency.currency);\n        return {\n            mixedRoute: routeRaw,\n            inputAmount: amountCurrency,\n            outputAmount: quoteCurrency,\n        };\n    });\n    const trade = new Trade({ v2Routes, v3Routes, mixedRoutes, tradeType });\n    return trade;\n}\nexport function buildSwapMethodParameters(trade, swapConfig, chainId) {\n    if (swapConfig.type == SwapType.UNIVERSAL_ROUTER) {\n        return {\n            ...UniveralRouter.swapERC20CallParameters(trade, swapConfig),\n            to: UNIVERSAL_ROUTER_ADDRESS(chainId),\n        };\n    }\n    else if (swapConfig.type == SwapType.SWAP_ROUTER_02) {\n        const { recipient, slippageTolerance, deadline, inputTokenPermit } = swapConfig;\n        return {\n            ...SwapRouter02.swapCallParameters(trade, {\n                recipient,\n                slippageTolerance,\n                deadlineOrPreviousBlockhash: deadline,\n                inputTokenPermit,\n            }),\n            to: SWAP_ROUTER_02_ADDRESSES(chainId),\n        };\n    }\n    throw new Error(`Unsupported swap type ${swapConfig}`);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0aG9kUGFyYW1ldGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlsL21ldGhvZFBhcmFtZXRlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLGFBQWEsRUFDYixRQUFRLEVBQ1IsVUFBVSxJQUFJLFlBQVksRUFDMUIsS0FBSyxHQUNOLE1BQU0scUJBQXFCLENBQUM7QUFDN0IsT0FBTyxFQUFZLFNBQVMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3hELE9BQU8sRUFDTCxVQUFVLElBQUksY0FBYyxFQUM1Qix3QkFBd0IsR0FDekIsTUFBTSwrQkFBK0IsQ0FBQztBQUN2QyxPQUFPLEVBQUUsS0FBSyxJQUFJLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxLQUFLLElBQUksVUFBVSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdEQsT0FBTyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBRXZCLE9BQU8sRUFFTCxjQUFjLEVBS2QsUUFBUSxFQUNSLHdCQUF3QixHQUd6QixNQUFNLElBQUksQ0FBQztBQUVaLE1BQU0sVUFBVSxVQUFVLENBQ3hCLGVBQXlCLEVBQ3pCLGdCQUEwQixFQUMxQixTQUFxQixFQUNyQixZQUFtQztJQUVuQyxnREFBZ0Q7SUFDaEQsTUFBTSxjQUFjLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FDN0IsWUFBWSxFQUNaLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsUUFBUSxLQUFLLFFBQVEsQ0FBQyxFQUFFLENBQ3RELENBQUM7SUFDRixNQUFNLGNBQWMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUM3QixZQUFZLEVBQ1osQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDLEVBQUUsQ0FDdEQsQ0FBQztJQUNGLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FDaEMsWUFB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"]},"metadata":{},"sourceType":"module"}