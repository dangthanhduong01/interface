{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Eip712MerkleTree = void 0;\nvar hash_1 = require(\"@ethersproject/hash\");\nvar utils_1 = require(\"ethers/lib/utils\");\nvar merkletreejs_1 = require(\"merkletreejs\");\nvar defaults_1 = require(\"./defaults\");\nvar utils_2 = require(\"./utils\");\nvar getTree = function (leaves, defaultLeafHash) {\n  return new merkletreejs_1.MerkleTree(leaves.map(utils_2.hexToBuffer), utils_2.bufferKeccak, {\n    complete: true,\n    sort: false,\n    hashLeaves: false,\n    fillDefaultHash: (0, utils_2.hexToBuffer)(defaultLeafHash)\n  });\n};\nvar encodeProof = function (key, proof, signature) {\n  if (signature === void 0) {\n    signature = \"0x\".concat(\"ff\".repeat(64));\n  }\n  return (0, utils_1.hexConcat)([signature, \"0x\".concat(key.toString(16).padStart(6, \"0\")), utils_1.defaultAbiCoder.encode([\"uint256[\".concat(proof.length, \"]\")], [proof])]);\n};\nvar Eip712MerkleTree = /** @class */function () {\n  function Eip712MerkleTree(types, rootType, leafType, elements, depth) {\n    this.types = types;\n    this.rootType = rootType;\n    this.leafType = leafType;\n    this.elements = elements;\n    this.depth = depth;\n    var encoder = hash_1._TypedDataEncoder.from(types);\n    this.encoder = encoder;\n    this.leafHasher = function (leaf) {\n      return encoder.hashStruct(leafType, leaf);\n    };\n    this.defaultNode = defaults_1.DefaultGetter.from(types, leafType);\n    this.defaultLeaf = this.leafHasher(this.defaultNode);\n    this.tree = getTree(this.getCompleteLeaves(), this.defaultLeaf);\n  }\n  Object.defineProperty(Eip712MerkleTree.prototype, \"completedSize\", {\n    get: function () {\n      return Math.pow(2, this.depth);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Returns the array of elements in the tree, padded to the complete size with empty items. */\n  Eip712MerkleTree.prototype.getCompleteElements = function () {\n    var elements = this.elements;\n    return (0, utils_2.fillArray)(__spreadArray([], __read(elements), false), this.completedSize, this.defaultNode);\n  };\n  /** Returns the array of leaf nodes in the tree, padded to the complete size with default hashes. */\n  Eip712MerkleTree.prototype.getCompleteLeaves = function () {\n    var leaves = this.elements.map(this.leafHasher);\n    return (0, utils_2.fillArray)(__spreadArray([], __read(leaves), false), this.completedSize, this.defaultLeaf);\n  };\n  Object.defineProperty(Eip712MerkleTree.prototype, \"root\", {\n    get: function () {\n      return this.tree.getHexRoot();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Eip712MerkleTree.prototype.getProof = function (i) {\n    var leaves = this.getCompleteLeaves();\n    var leaf = leaves[i];\n    var proof = this.tree.getHexProof(leaf, i);\n    var root = this.tree.getHexRoot();\n    return {\n      leaf: leaf,\n      proof: proof,\n      root: root\n    };\n  };\n  Eip712MerkleTree.prototype.getEncodedProofAndSignature = function (i, signature) {\n    var proof = this.getProof(i).proof;\n    return encodeProof(i, proof, signature);\n  };\n  Eip712MerkleTree.prototype.getDataToSign = function () {\n    var layer = this.getCompleteElements();\n    while (layer.length > 2) {\n      layer = (0, utils_2.chunk)(layer, 2);\n    }\n    return layer;\n  };\n  Eip712MerkleTree.prototype.add = function (element) {\n    this.elements.push(element);\n  };\n  Eip712MerkleTree.prototype.getBulkOrderHash = function () {\n    var structHash = this.encoder.hashStruct(\"BulkOrder\", {\n      tree: this.getDataToSign()\n    });\n    var leaves = this.getCompleteLeaves().map(utils_2.hexToBuffer);\n    var rootHash = (0, utils_2.bufferToHex)((0, utils_2.getRoot)(leaves, false));\n    var typeHash = (0, utils_1.keccak256)((0, utils_1.toUtf8Bytes)(this.encoder._types.BulkOrder));\n    var bulkOrderHash = (0, utils_1.keccak256)((0, utils_1.hexConcat)([typeHash, rootHash]));\n    if (bulkOrderHash !== structHash) {\n      throw new Error(\"expected derived bulk order hash to match\");\n    }\n    return structHash;\n  };\n  return Eip712MerkleTree;\n}();\nexports.Eip712MerkleTree = Eip712MerkleTree;","map":{"version":3,"sources":["../../../src/utils/eip712/Eip712MerkleTree.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Eip712MerkleTree = void 0;\nvar hash_1 = require(\"@ethersproject/hash\");\nvar utils_1 = require(\"ethers/lib/utils\");\nvar merkletreejs_1 = require(\"merkletreejs\");\nvar defaults_1 = require(\"./defaults\");\nvar utils_2 = require(\"./utils\");\nvar getTree = function (leaves, defaultLeafHash) {\n    return new merkletreejs_1.MerkleTree(leaves.map(utils_2.hexToBuffer), utils_2.bufferKeccak, {\n        complete: true,\n        sort: false,\n        hashLeaves: false,\n        fillDefaultHash: (0, utils_2.hexToBuffer)(defaultLeafHash),\n    });\n};\nvar encodeProof = function (key, proof, signature) {\n    if (signature === void 0) { signature = \"0x\".concat(\"ff\".repeat(64)); }\n    return (0, utils_1.hexConcat)([\n        signature,\n        \"0x\".concat(key.toString(16).padStart(6, \"0\")),\n        utils_1.defaultAbiCoder.encode([\"uint256[\".concat(proof.length, \"]\")], [proof]),\n    ]);\n};\nvar Eip712MerkleTree = /** @class */ (function () {\n    function Eip712MerkleTree(types, rootType, leafType, elements, depth) {\n        this.types = types;\n        this.rootType = rootType;\n        this.leafType = leafType;\n        this.elements = elements;\n        this.depth = depth;\n        var encoder = hash_1._TypedDataEncoder.from(types);\n        this.encoder = encoder;\n        this.leafHasher = function (leaf) { return encoder.hashStruct(leafType, leaf); };\n        this.defaultNode = defaults_1.DefaultGetter.from(types, leafType);\n        this.defaultLeaf = this.leafHasher(this.defaultNode);\n        this.tree = getTree(this.getCompleteLeaves(), this.defaultLeaf);\n    }\n    Object.defineProperty(Eip712MerkleTree.prototype, \"completedSize\", {\n        get: function () {\n            return Math.pow(2, this.depth);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /** Returns the array of elements in the tree, padded to the complete size with empty items. */\n    Eip712MerkleTree.prototype.getCompleteElements = function () {\n        var elements = this.elements;\n        return (0, utils_2.fillArray)(__spreadArray([], __read(elements), false), this.completedSize, this.defaultNode);\n    };\n    /** Returns the array of leaf nodes in the tree, padded to the complete size with default hashes. */\n    Eip712MerkleTree.prototype.getCompleteLeaves = function () {\n        var leaves = this.elements.map(this.leafHasher);\n        return (0, utils_2.fillArray)(__spreadArray([], __read(leaves), false), this.completedSize, this.defaultLeaf);\n    };\n    Object.defineProperty(Eip712MerkleTree.prototype, \"root\", {\n        get: function () {\n            return this.tree.getHexRoot();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Eip712MerkleTree.prototype.getProof = function (i) {\n        var leaves = this.getCompleteLeaves();\n        var leaf = leaves[i];\n        var proof = this.tree.getHexProof(leaf, i);\n        var root = this.tree.getHexRoot();\n        return { leaf: leaf, proof: proof, root: root };\n    };\n    Eip712MerkleTree.prototype.getEncodedProofAndSignature = function (i, signature) {\n        var proof = this.getProof(i).proof;\n        return encodeProof(i, proof, signature);\n    };\n    Eip712MerkleTree.prototype.getDataToSign = function () {\n        var layer = this.getCompleteElements();\n        while (layer.length > 2) {\n            layer = (0, utils_2.chunk)(layer, 2);\n        }\n        return layer;\n    };\n    Eip712MerkleTree.prototype.add = function (element) {\n        this.elements.push(element);\n    };\n    Eip712MerkleTree.prototype.getBulkOrderHash = function () {\n        var structHash = this.encoder.hashStruct(\"BulkOrder\", {\n            tree: this.getDataToSign(),\n        });\n        var leaves = this.getCompleteLeaves().map(utils_2.hexToBuffer);\n        var rootHash = (0, utils_2.bufferToHex)((0, utils_2.getRoot)(leaves, false));\n        var typeHash = (0, utils_1.keccak256)((0, utils_1.toUtf8Bytes)(this.encoder._types.BulkOrder));\n        var bulkOrderHash = (0, utils_1.keccak256)((0, utils_1.hexConcat)([typeHash, rootHash]));\n        if (bulkOrderHash !== structHash) {\n            throw new Error(\"expected derived bulk order hash to match\");\n        }\n        return structHash;\n    };\n    return Eip712MerkleTree;\n}());\nexports.Eip712MerkleTree = Eip712MerkleTree;\n//# sourceMappingURL=Eip712MerkleTree.js.map"]},"metadata":{},"sourceType":"script"}