{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Base = void 0;\nconst buffer_1 = require(\"buffer\");\nconst crypto_js_1 = __importDefault(require(\"crypto-js\"));\nclass Base {\n  /**\n   * print\n   * @desc Prints out a visual representation of the merkle tree.\n   * @example\n   *```js\n   *tree.print()\n   *```\n   */\n  print() {\n    Base.print(this);\n  }\n  /**\n   * bufferIndexOf\n   * @desc Returns the first index of which given buffer is found in array.\n   * @param {Buffer[]} haystack - Array of buffers.\n   * @param {Buffer} needle - Buffer to find.\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.bufferIndexOf(haystack, needle)\n   *```\n   */\n  bufferIndexOf(array, element) {\n    let isSorted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (isSorted) {\n      return this.binarySearch(array, element, buffer_1.Buffer.compare);\n    }\n    const eqChecker = (buffer1, buffer2) => buffer1.equals(buffer2);\n    return this.linearSearch(array, element, eqChecker);\n  }\n  /**\n   * binarySearch\n   * @desc Returns the first index of which given item is found in array using binary search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} compareFunction\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = MerkleTree.binarySearch(array, element, Buffer.compare)\n   *```\n   */\n  static binarySearch(array, element, compareFunction) {\n    let start = 0;\n    let end = array.length - 1;\n    // Iterate while start not meets end\n    while (start <= end) {\n      // Find the mid index\n      const mid = Math.floor((start + end) / 2);\n      // Check if the mid value is greater than, equal to, or less than search element.\n      const ordering = compareFunction(array[mid], element);\n      // If element is present at mid, start iterating for searching first appearance.\n      if (ordering === 0) {\n        // Linear reverse iteration until the first matching item index is found.\n        for (let i = mid - 1; i >= 0; i--) {\n          if (compareFunction(array[i], element) === 0) continue;\n          return i + 1;\n        }\n        return 0;\n      } /* Else look in left or right half accordingly */else if (ordering < 0) {\n        start = mid + 1;\n      } else {\n        end = mid - 1;\n      }\n    }\n    return -1;\n  }\n  /**\n   * binarySearch\n   * @desc Returns the first index of which given item is found in array using binary search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} compareFunction\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.binarySearch(array, element, Buffer.compare)\n   *```\n   */\n  binarySearch(array, element, compareFunction) {\n    return Base.binarySearch(array, element, compareFunction);\n  }\n  /**\n   * linearSearch\n   * @desc Returns the first index of which given item is found in array using linear search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} eqChecker\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)\n   *```\n   */\n  static linearSearch(array, element, eqChecker) {\n    for (let i = 0; i < array.length; i++) {\n      if (eqChecker(array[i], element)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /**\n   * linearSearch\n   * @desc Returns the first index of which given item is found in array using linear search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} eqChecker\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.linearSearch(array, element, (a, b) => a === b)\n   *```\n   */\n  linearSearch(array, element, eqChecker) {\n    return Base.linearSearch(array, element, eqChecker);\n  }\n  /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer|ArrayBuffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = MerkleTree.bufferify('0x1234')\n   *```\n   */\n  static bufferify(value) {\n    if (!buffer_1.Buffer.isBuffer(value)) {\n      // crypto-js support\n      if (typeof value === 'object' && value.words) {\n        return buffer_1.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), 'hex');\n      } else if (Base.isHexString(value)) {\n        return buffer_1.Buffer.from(value.replace(/^0x/, ''), 'hex');\n      } else if (typeof value === 'string') {\n        return buffer_1.Buffer.from(value);\n      } else if (typeof value === 'bigint') {\n        return buffer_1.Buffer.from(value.toString(16), 'hex');\n      } else if (value instanceof Uint8Array) {\n        return buffer_1.Buffer.from(value.buffer);\n      } else if (typeof value === 'number') {\n        let s = value.toString();\n        if (s.length % 2) {\n          s = `0${s}`;\n        }\n        return buffer_1.Buffer.from(s, 'hex');\n      } else if (ArrayBuffer.isView(value)) {\n        return buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n      }\n    }\n    return value;\n  }\n  bigNumberify(value) {\n    return Base.bigNumberify(value);\n  }\n  static bigNumberify(value) {\n    if (typeof value === 'bigint') {\n      return value;\n    }\n    if (typeof value === 'string') {\n      if (value.startsWith('0x') && Base.isHexString(value)) {\n        return BigInt('0x' + value.replace('0x', '').toString());\n      }\n      return BigInt(value);\n    }\n    if (buffer_1.Buffer.isBuffer(value)) {\n      return BigInt('0x' + value.toString('hex'));\n    }\n    if (value instanceof Uint8Array) {\n      return BigInt(value);\n    }\n    if (typeof value === 'number') {\n      return BigInt(value);\n    }\n    throw new Error('cannot bigNumberify');\n  }\n  /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */\n  static isHexString(v) {\n    return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n  }\n  /**\n   * print\n   * @desc Prints out a visual representation of the given merkle tree.\n   * @param {Object} tree - Merkle tree instance.\n   * @return {String}\n   * @example\n   *```js\n   *MerkleTree.print(tree)\n   *```\n   */\n  static print(tree) {\n    console.log(tree.toString());\n  }\n  /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = tree.bufferToHex(Buffer.from('A'))\n   *```\n   */\n  bufferToHex(value) {\n    let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return Base.bufferToHex(value, withPrefix);\n  }\n  /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n   *```\n   */\n  static bufferToHex(value) {\n    let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return `${withPrefix ? '0x' : ''}${(value || buffer_1.Buffer.alloc(0)).toString('hex')}`;\n  }\n  /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = tree.bufferify('0x1234')\n   *```\n   */\n  bufferify(value) {\n    return Base.bufferify(value);\n  }\n  /**\n   * bufferifyFn\n   * @desc Returns a function that will bufferify the return value.\n   * @param {Function}\n   * @return {Function}\n   *\n   * @example\n   * ```js\n   *const fn = tree.bufferifyFn((value) => sha256(value))\n   *```\n   */\n  bufferifyFn(f) {\n    return value => {\n      const v = f(value);\n      if (buffer_1.Buffer.isBuffer(v)) {\n        return v;\n      }\n      if (this.isHexString(v)) {\n        return buffer_1.Buffer.from(v.replace('0x', ''), 'hex');\n      }\n      if (typeof v === 'string') {\n        return buffer_1.Buffer.from(v);\n      }\n      if (typeof v === 'bigint') {\n        return buffer_1.Buffer.from(value.toString(16), 'hex');\n      }\n      if (ArrayBuffer.isView(v)) {\n        return buffer_1.Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n      }\n      // crypto-js support\n      return buffer_1.Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString('hex'))).toString(crypto_js_1.default.enc.Hex), 'hex');\n    };\n  }\n  /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */\n  isHexString(value) {\n    return Base.isHexString(value);\n  }\n  /**\n   * log2\n   * @desc Returns the log2 of number.\n   * @param {Number} value\n   * @return {Number}\n   */\n  log2(n) {\n    return n === 1 ? 0 : 1 + this.log2(n / 2 | 0);\n  }\n  /**\n   * zip\n   * @desc Returns true if value is a hex string.\n   * @param {String[]|Number[]|Buffer[]} a - first array\n   * @param {String[]|Number[]|Buffer[]} b -  second array\n   * @return {String[][]|Number[][]|Buffer[][]}\n   *\n   * @example\n   * ```js\n   *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n   *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n   *```\n   */\n  zip(a, b) {\n    return a.map((e, i) => [e, b[i]]);\n  }\n  static hexZeroPad(hexStr, length) {\n    return '0x' + hexStr.replace('0x', '').padStart(length, '0');\n  }\n}\nexports.Base = Base;\nexports.default = Base;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Base","buffer_1","require","crypto_js_1","print","bufferIndexOf","array","element","isSorted","binarySearch","Buffer","compare","eqChecker","buffer1","buffer2","equals","linearSearch","compareFunction","start","end","length","mid","Math","floor","ordering","i","bufferify","isBuffer","words","from","toString","default","enc","Hex","isHexString","replace","Uint8Array","buffer","s","ArrayBuffer","isView","byteOffset","byteLength","bigNumberify","startsWith","BigInt","Error","v","test","tree","console","log","bufferToHex","withPrefix","alloc","bufferifyFn","f","parse","log2","n","zip","a","b","map","e","hexZeroPad","hexStr","padStart"],"sources":["/home/diep/freelance/interface/node_modules/merkletreejs/dist/Base.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Base = void 0;\nconst buffer_1 = require(\"buffer\");\nconst crypto_js_1 = __importDefault(require(\"crypto-js\"));\nclass Base {\n    /**\n     * print\n     * @desc Prints out a visual representation of the merkle tree.\n     * @example\n     *```js\n     *tree.print()\n     *```\n     */\n    print() {\n        Base.print(this);\n    }\n    /**\n     * bufferIndexOf\n     * @desc Returns the first index of which given buffer is found in array.\n     * @param {Buffer[]} haystack - Array of buffers.\n     * @param {Buffer} needle - Buffer to find.\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.bufferIndexOf(haystack, needle)\n     *```\n     */\n    bufferIndexOf(array, element, isSorted = false) {\n        if (isSorted) {\n            return this.binarySearch(array, element, buffer_1.Buffer.compare);\n        }\n        const eqChecker = (buffer1, buffer2) => buffer1.equals(buffer2);\n        return this.linearSearch(array, element, eqChecker);\n    }\n    /**\n     * binarySearch\n     * @desc Returns the first index of which given item is found in array using binary search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} compareFunction\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = MerkleTree.binarySearch(array, element, Buffer.compare)\n     *```\n     */\n    static binarySearch(array, element, compareFunction) {\n        let start = 0;\n        let end = array.length - 1;\n        // Iterate while start not meets end\n        while (start <= end) {\n            // Find the mid index\n            const mid = Math.floor((start + end) / 2);\n            // Check if the mid value is greater than, equal to, or less than search element.\n            const ordering = compareFunction(array[mid], element);\n            // If element is present at mid, start iterating for searching first appearance.\n            if (ordering === 0) {\n                // Linear reverse iteration until the first matching item index is found.\n                for (let i = mid - 1; i >= 0; i--) {\n                    if (compareFunction(array[i], element) === 0)\n                        continue;\n                    return i + 1;\n                }\n                return 0;\n            } /* Else look in left or right half accordingly */\n            else if (ordering < 0) {\n                start = mid + 1;\n            }\n            else {\n                end = mid - 1;\n            }\n        }\n        return -1;\n    }\n    /**\n     * binarySearch\n     * @desc Returns the first index of which given item is found in array using binary search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} compareFunction\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.binarySearch(array, element, Buffer.compare)\n     *```\n     */\n    binarySearch(array, element, compareFunction) {\n        return Base.binarySearch(array, element, compareFunction);\n    }\n    /**\n     * linearSearch\n     * @desc Returns the first index of which given item is found in array using linear search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} eqChecker\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)\n     *```\n     */\n    static linearSearch(array, element, eqChecker) {\n        for (let i = 0; i < array.length; i++) {\n            if (eqChecker(array[i], element)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * linearSearch\n     * @desc Returns the first index of which given item is found in array using linear search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} eqChecker\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.linearSearch(array, element, (a, b) => a === b)\n     *```\n     */\n    linearSearch(array, element, eqChecker) {\n        return Base.linearSearch(array, element, eqChecker);\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer|ArrayBuffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = MerkleTree.bufferify('0x1234')\n     *```\n     */\n    static bufferify(value) {\n        if (!buffer_1.Buffer.isBuffer(value)) {\n            // crypto-js support\n            if (typeof value === 'object' && value.words) {\n                return buffer_1.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), 'hex');\n            }\n            else if (Base.isHexString(value)) {\n                return buffer_1.Buffer.from(value.replace(/^0x/, ''), 'hex');\n            }\n            else if (typeof value === 'string') {\n                return buffer_1.Buffer.from(value);\n            }\n            else if (typeof value === 'bigint') {\n                return buffer_1.Buffer.from(value.toString(16), 'hex');\n            }\n            else if (value instanceof Uint8Array) {\n                return buffer_1.Buffer.from(value.buffer);\n            }\n            else if (typeof value === 'number') {\n                let s = value.toString();\n                if (s.length % 2) {\n                    s = `0${s}`;\n                }\n                return buffer_1.Buffer.from(s, 'hex');\n            }\n            else if (ArrayBuffer.isView(value)) {\n                return buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n            }\n        }\n        return value;\n    }\n    bigNumberify(value) {\n        return Base.bigNumberify(value);\n    }\n    static bigNumberify(value) {\n        if (typeof value === 'bigint') {\n            return value;\n        }\n        if (typeof value === 'string') {\n            if (value.startsWith('0x') && Base.isHexString(value)) {\n                return BigInt('0x' + value.replace('0x', '').toString());\n            }\n            return BigInt(value);\n        }\n        if (buffer_1.Buffer.isBuffer(value)) {\n            return BigInt('0x' + value.toString('hex'));\n        }\n        if (value instanceof Uint8Array) {\n            return BigInt(value);\n        }\n        if (typeof value === 'number') {\n            return BigInt(value);\n        }\n        throw new Error('cannot bigNumberify');\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n    static isHexString(v) {\n        return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n    }\n    /**\n     * print\n     * @desc Prints out a visual representation of the given merkle tree.\n     * @param {Object} tree - Merkle tree instance.\n     * @return {String}\n     * @example\n     *```js\n     *MerkleTree.print(tree)\n     *```\n     */\n    static print(tree) {\n        console.log(tree.toString());\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = tree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n    bufferToHex(value, withPrefix = true) {\n        return Base.bufferToHex(value, withPrefix);\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n    static bufferToHex(value, withPrefix = true) {\n        return `${withPrefix ? '0x' : ''}${(value || buffer_1.Buffer.alloc(0)).toString('hex')}`;\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = tree.bufferify('0x1234')\n     *```\n     */\n    bufferify(value) {\n        return Base.bufferify(value);\n    }\n    /**\n     * bufferifyFn\n     * @desc Returns a function that will bufferify the return value.\n     * @param {Function}\n     * @return {Function}\n     *\n     * @example\n     * ```js\n     *const fn = tree.bufferifyFn((value) => sha256(value))\n     *```\n     */\n    bufferifyFn(f) {\n        return (value) => {\n            const v = f(value);\n            if (buffer_1.Buffer.isBuffer(v)) {\n                return v;\n            }\n            if (this.isHexString(v)) {\n                return buffer_1.Buffer.from(v.replace('0x', ''), 'hex');\n            }\n            if (typeof v === 'string') {\n                return buffer_1.Buffer.from(v);\n            }\n            if (typeof v === 'bigint') {\n                return buffer_1.Buffer.from(value.toString(16), 'hex');\n            }\n            if (ArrayBuffer.isView(v)) {\n                return buffer_1.Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n            }\n            // crypto-js support\n            return buffer_1.Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString('hex'))).toString(crypto_js_1.default.enc.Hex), 'hex');\n        };\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n    isHexString(value) {\n        return Base.isHexString(value);\n    }\n    /**\n     * log2\n     * @desc Returns the log2 of number.\n     * @param {Number} value\n     * @return {Number}\n     */\n    log2(n) {\n        return n === 1 ? 0 : 1 + this.log2((n / 2) | 0);\n    }\n    /**\n     * zip\n     * @desc Returns true if value is a hex string.\n     * @param {String[]|Number[]|Buffer[]} a - first array\n     * @param {String[]|Number[]|Buffer[]} b -  second array\n     * @return {String[][]|Number[][]|Buffer[][]}\n     *\n     * @example\n     * ```js\n     *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n     *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n     *```\n     */\n    zip(a, b) {\n        return a.map((e, i) => [e, b[i]]);\n    }\n    static hexZeroPad(hexStr, length) {\n        return '0x' + hexStr.replace('0x', '').padStart(length, '0');\n    }\n}\nexports.Base = Base;\nexports.default = Base;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}