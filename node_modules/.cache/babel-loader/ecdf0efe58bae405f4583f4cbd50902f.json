{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$(),\n  _s5 = $RefreshSig$(),\n  _s6 = $RefreshSig$(),\n  _s7 = $RefreshSig$(),\n  _s8 = $RefreshSig$(),\n  _s9 = $RefreshSig$();\nimport { Token } from '@uniswap/sdk-core';\nimport { useWeb3React } from '@web3-react/core';\nimport { getChainInfo } from 'constants/chainInfo';\nimport { SupportedChainId } from 'constants/chains';\nimport { DEFAULT_INACTIVE_LIST_URLS, DEFAULT_LIST_OF_LISTS } from 'constants/lists';\nimport { useCurrencyFromMap, useTokenFromMapOrNetwork } from 'lib/hooks/useCurrency';\nimport { getTokenFilter } from 'lib/hooks/useTokenList/filtering';\nimport { useMemo } from 'react';\nimport { isL2ChainId } from 'utils/chains';\nimport { useAllLists, useCombinedActiveList, useCombinedTokenMapFromUrls } from '../state/lists/hooks';\nimport { WrappedTokenInfo } from '../state/lists/wrappedTokenInfo';\nimport { useUserAddedTokens, useUserAddedTokensOnChain } from '../state/user/hooks';\nimport { useUnsupportedTokenList } from './../state/lists/hooks';\n\n// reduce token map into standard address <-> Token mapping, optionally include user added tokens\nfunction useTokensFromMap(tokenMap) {\n  _s();\n  const {\n    chainId\n  } = useWeb3React();\n  return useMemo(() => {\n    var _tokenMap$chainId;\n    if (!chainId) return {};\n\n    // reduce to just tokens\n    return Object.keys((_tokenMap$chainId = tokenMap[chainId]) !== null && _tokenMap$chainId !== void 0 ? _tokenMap$chainId : {}).reduce((newMap, address) => {\n      newMap[address] = tokenMap[chainId][address].token;\n      return newMap;\n    }, {});\n  }, [chainId, tokenMap]);\n}\n_s(useTokensFromMap, \"ARXJQdl1Tr2ytTu0YufD558EwWE=\", false, function () {\n  return [useWeb3React];\n});\nexport function useAllTokensMultichain() {\n  _s2();\n  return useCombinedTokenMapFromUrls(DEFAULT_LIST_OF_LISTS);\n}\n\n// Returns all tokens from the default list + user added tokens\n_s2(useAllTokensMultichain, \"b/pIzZGMUJ1xUlEE8i/7rUykADY=\", false, function () {\n  return [useCombinedTokenMapFromUrls];\n});\nexport function useDefaultActiveTokens() {\n  _s3();\n  const defaultListTokens = useCombinedActiveList();\n  const tokensFromMap = useTokensFromMap(defaultListTokens);\n  const userAddedTokens = useUserAddedTokens();\n  return useMemo(() => {\n    return userAddedTokens\n    // reduce into all ALL_TOKENS filtered by the current chain\n    .reduce((tokenMap, token) => {\n      tokenMap[token.address] = token;\n      return tokenMap;\n    },\n    // must make a copy because reduce modifies the map, and we do not\n    // want to make a copy in every iteration\n    {\n      ...tokensFromMap\n    });\n  }, [tokensFromMap, userAddedTokens]);\n}\n_s3(useDefaultActiveTokens, \"Ddrke9Y64ibJfj2ReD3SB3WIw8w=\", false, function () {\n  return [useCombinedActiveList, useTokensFromMap, useUserAddedTokens];\n});\nexport function useUnsupportedTokens() {\n  _s4();\n  const {\n    chainId\n  } = useWeb3React();\n  const listsByUrl = useAllLists();\n  const unsupportedTokensMap = useUnsupportedTokenList();\n  const unsupportedTokens = useTokensFromMap(unsupportedTokensMap);\n\n  // checks the default L2 lists to see if `bridgeInfo` has an L1 address value that is unsupported\n  const l2InferredBlockedTokens = useMemo(() => {\n    if (!chainId || !isL2ChainId(chainId)) {\n      return {};\n    }\n    if (!listsByUrl) {\n      return {};\n    }\n    const listUrl = getChainInfo(chainId).defaultListUrl;\n    const {\n      current: list\n    } = listsByUrl[listUrl];\n    if (!list) {\n      return {};\n    }\n    const unsupportedSet = new Set(Object.keys(unsupportedTokens));\n    return list.tokens.reduce((acc, tokenInfo) => {\n      var _tokenInfo$extensions;\n      const bridgeInfo = (_tokenInfo$extensions = tokenInfo.extensions) === null || _tokenInfo$extensions === void 0 ? void 0 : _tokenInfo$extensions.bridgeInfo;\n      if (bridgeInfo && bridgeInfo[SupportedChainId.MAINNET] && bridgeInfo[SupportedChainId.MAINNET].tokenAddress && unsupportedSet.has(bridgeInfo[SupportedChainId.MAINNET].tokenAddress)) {\n        const address = bridgeInfo[SupportedChainId.MAINNET].tokenAddress;\n        // don't rely on decimals--it's possible that a token could be bridged w/ different decimals on the L2\n        return {\n          ...acc,\n          [address]: new Token(SupportedChainId.MAINNET, address, tokenInfo.decimals)\n        };\n      }\n      return acc;\n    }, {});\n  }, [chainId, listsByUrl, unsupportedTokens]);\n  return {\n    ...unsupportedTokens,\n    ...l2InferredBlockedTokens\n  };\n}\n_s4(useUnsupportedTokens, \"J6OC3F6FCjp7aJFOot7RCKMGUAk=\", false, function () {\n  return [useWeb3React, useAllLists, useUnsupportedTokenList, useTokensFromMap];\n});\nexport function useSearchInactiveTokenLists(search) {\n  _s5();\n  let minResults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  const lists = useAllLists();\n  const inactiveUrls = DEFAULT_INACTIVE_LIST_URLS;\n  const {\n    chainId\n  } = useWeb3React();\n  const activeTokens = useDefaultActiveTokens();\n  return useMemo(() => {\n    if (!search || search.trim().length === 0) return [];\n    const tokenFilter = getTokenFilter(search);\n    const result = [];\n    const addressSet = {};\n    for (const url of inactiveUrls) {\n      var _lists$url;\n      const list = (_lists$url = lists[url]) === null || _lists$url === void 0 ? void 0 : _lists$url.current;\n      if (!list) continue;\n      for (const tokenInfo of list.tokens) {\n        if (tokenInfo.chainId === chainId && tokenFilter(tokenInfo)) {\n          try {\n            const wrapped = new WrappedTokenInfo(tokenInfo, list);\n            if (!(wrapped.address in activeTokens) && !addressSet[wrapped.address]) {\n              addressSet[wrapped.address] = true;\n              result.push(wrapped);\n              if (result.length >= minResults) return result;\n            }\n          } catch {\n            continue;\n          }\n        }\n      }\n    }\n    return result;\n  }, [activeTokens, chainId, inactiveUrls, lists, minResults, search]);\n}\n\n// Check if currency is included in custom list from user storage\n_s5(useSearchInactiveTokenLists, \"NrEirHl6TNJhatRElea/yVerorI=\", false, function () {\n  return [useAllLists, useWeb3React, useDefaultActiveTokens];\n});\nexport function useIsUserAddedToken(currency) {\n  _s6();\n  const userAddedTokens = useUserAddedTokens();\n  if (!currency) {\n    return false;\n  }\n  return !!userAddedTokens.find(token => currency.equals(token));\n}\n\n// Check if currency on specific chain is included in custom list from user storage\n_s6(useIsUserAddedToken, \"/J12HuilTfT8HPlUWn/aslQP0JY=\", false, function () {\n  return [useUserAddedTokens];\n});\nexport function useIsUserAddedTokenOnChain(address, chain) {\n  _s7();\n  const userAddedTokens = useUserAddedTokensOnChain(chain);\n  if (!address || !chain) {\n    return false;\n  }\n  return !!userAddedTokens.find(token => token.address === address);\n}\n\n// undefined if invalid or does not exist\n// null if loading or null was passed\n// otherwise returns the token\n_s7(useIsUserAddedTokenOnChain, \"ph+eyhh5ZDf0iQnt/kLukIRLCro=\", false, function () {\n  return [useUserAddedTokensOnChain];\n});\nexport function useToken(tokenAddress) {\n  _s8();\n  const tokens = useDefaultActiveTokens();\n  return useTokenFromMapOrNetwork(tokens, tokenAddress);\n}\n_s8(useToken, \"MBGlEE6eeQMGymWon5d5mrGcYIk=\", false, function () {\n  return [useDefaultActiveTokens, useTokenFromMapOrNetwork];\n});\nexport function useCurrency(currencyId) {\n  _s9();\n  const tokens = useDefaultActiveTokens();\n  return useCurrencyFromMap(tokens, currencyId);\n}\n_s9(useCurrency, \"5uXHds57aF6PuMd6w4FeierpNi8=\", false, function () {\n  return [useDefaultActiveTokens, useCurrencyFromMap];\n});","map":{"version":3,"names":["Token","useWeb3React","getChainInfo","SupportedChainId","DEFAULT_INACTIVE_LIST_URLS","DEFAULT_LIST_OF_LISTS","useCurrencyFromMap","useTokenFromMapOrNetwork","getTokenFilter","useMemo","isL2ChainId","useAllLists","useCombinedActiveList","useCombinedTokenMapFromUrls","WrappedTokenInfo","useUserAddedTokens","useUserAddedTokensOnChain","useUnsupportedTokenList","useTokensFromMap","tokenMap","chainId","Object","keys","reduce","newMap","address","token","useAllTokensMultichain","useDefaultActiveTokens","defaultListTokens","tokensFromMap","userAddedTokens","useUnsupportedTokens","listsByUrl","unsupportedTokensMap","unsupportedTokens","l2InferredBlockedTokens","listUrl","defaultListUrl","current","list","unsupportedSet","Set","tokens","acc","tokenInfo","bridgeInfo","extensions","MAINNET","tokenAddress","has","decimals","useSearchInactiveTokenLists","search","minResults","lists","inactiveUrls","activeTokens","trim","length","tokenFilter","result","addressSet","url","wrapped","push","useIsUserAddedToken","currency","find","equals","useIsUserAddedTokenOnChain","chain","useToken","useCurrency","currencyId"],"sources":["/home/diep/freelance/interface/src/hooks/Tokens.ts"],"sourcesContent":["import { Currency, Token } from '@uniswap/sdk-core'\nimport { useWeb3React } from '@web3-react/core'\nimport { getChainInfo } from 'constants/chainInfo'\nimport { SupportedChainId } from 'constants/chains'\nimport { DEFAULT_INACTIVE_LIST_URLS, DEFAULT_LIST_OF_LISTS } from 'constants/lists'\nimport { useCurrencyFromMap, useTokenFromMapOrNetwork } from 'lib/hooks/useCurrency'\nimport { getTokenFilter } from 'lib/hooks/useTokenList/filtering'\nimport { useMemo } from 'react'\nimport { isL2ChainId } from 'utils/chains'\n\nimport { useAllLists, useCombinedActiveList, useCombinedTokenMapFromUrls } from '../state/lists/hooks'\nimport { WrappedTokenInfo } from '../state/lists/wrappedTokenInfo'\nimport { useUserAddedTokens, useUserAddedTokensOnChain } from '../state/user/hooks'\nimport { TokenAddressMap, useUnsupportedTokenList } from './../state/lists/hooks'\n\n// reduce token map into standard address <-> Token mapping, optionally include user added tokens\nfunction useTokensFromMap(tokenMap: TokenAddressMap): { [address: string]: Token } {\n  const { chainId } = useWeb3React()\n  return useMemo(() => {\n    if (!chainId) return {}\n\n    // reduce to just tokens\n    return Object.keys(tokenMap[chainId] ?? {}).reduce<{ [address: string]: Token }>((newMap, address) => {\n      newMap[address] = tokenMap[chainId][address].token\n      return newMap\n    }, {})\n  }, [chainId, tokenMap])\n}\n\nexport function useAllTokensMultichain(): TokenAddressMap {\n  return useCombinedTokenMapFromUrls(DEFAULT_LIST_OF_LISTS)\n}\n\n// Returns all tokens from the default list + user added tokens\nexport function useDefaultActiveTokens(): { [address: string]: Token } {\n  const defaultListTokens = useCombinedActiveList()\n  const tokensFromMap = useTokensFromMap(defaultListTokens)\n  const userAddedTokens = useUserAddedTokens()\n  return useMemo(() => {\n    return (\n      userAddedTokens\n        // reduce into all ALL_TOKENS filtered by the current chain\n        .reduce<{ [address: string]: Token }>(\n          (tokenMap, token) => {\n            tokenMap[token.address] = token\n            return tokenMap\n          },\n          // must make a copy because reduce modifies the map, and we do not\n          // want to make a copy in every iteration\n          { ...tokensFromMap }\n        )\n    )\n  }, [tokensFromMap, userAddedTokens])\n}\n\ntype BridgeInfo = Record<\n  SupportedChainId,\n  {\n    tokenAddress: string\n    originBridgeAddress: string\n    destBridgeAddress: string\n  }\n>\n\nexport function useUnsupportedTokens(): { [address: string]: Token } {\n  const { chainId } = useWeb3React()\n  const listsByUrl = useAllLists()\n  const unsupportedTokensMap = useUnsupportedTokenList()\n  const unsupportedTokens = useTokensFromMap(unsupportedTokensMap)\n\n  // checks the default L2 lists to see if `bridgeInfo` has an L1 address value that is unsupported\n  const l2InferredBlockedTokens: typeof unsupportedTokens = useMemo(() => {\n    if (!chainId || !isL2ChainId(chainId)) {\n      return {}\n    }\n\n    if (!listsByUrl) {\n      return {}\n    }\n\n    const listUrl = getChainInfo(chainId).defaultListUrl\n\n    const { current: list } = listsByUrl[listUrl]\n    if (!list) {\n      return {}\n    }\n\n    const unsupportedSet = new Set(Object.keys(unsupportedTokens))\n\n    return list.tokens.reduce((acc, tokenInfo) => {\n      const bridgeInfo = tokenInfo.extensions?.bridgeInfo as unknown as BridgeInfo\n      if (\n        bridgeInfo &&\n        bridgeInfo[SupportedChainId.MAINNET] &&\n        bridgeInfo[SupportedChainId.MAINNET].tokenAddress &&\n        unsupportedSet.has(bridgeInfo[SupportedChainId.MAINNET].tokenAddress)\n      ) {\n        const address = bridgeInfo[SupportedChainId.MAINNET].tokenAddress\n        // don't rely on decimals--it's possible that a token could be bridged w/ different decimals on the L2\n        return { ...acc, [address]: new Token(SupportedChainId.MAINNET, address, tokenInfo.decimals) }\n      }\n      return acc\n    }, {})\n  }, [chainId, listsByUrl, unsupportedTokens])\n\n  return { ...unsupportedTokens, ...l2InferredBlockedTokens }\n}\n\nexport function useSearchInactiveTokenLists(search: string | undefined, minResults = 10): WrappedTokenInfo[] {\n  const lists = useAllLists()\n  const inactiveUrls = DEFAULT_INACTIVE_LIST_URLS\n  const { chainId } = useWeb3React()\n  const activeTokens = useDefaultActiveTokens()\n  return useMemo(() => {\n    if (!search || search.trim().length === 0) return []\n    const tokenFilter = getTokenFilter(search)\n    const result: WrappedTokenInfo[] = []\n    const addressSet: { [address: string]: true } = {}\n    for (const url of inactiveUrls) {\n      const list = lists[url]?.current\n      if (!list) continue\n      for (const tokenInfo of list.tokens) {\n        if (tokenInfo.chainId === chainId && tokenFilter(tokenInfo)) {\n          try {\n            const wrapped: WrappedTokenInfo = new WrappedTokenInfo(tokenInfo, list)\n            if (!(wrapped.address in activeTokens) && !addressSet[wrapped.address]) {\n              addressSet[wrapped.address] = true\n              result.push(wrapped)\n              if (result.length >= minResults) return result\n            }\n          } catch {\n            continue\n          }\n        }\n      }\n    }\n    return result\n  }, [activeTokens, chainId, inactiveUrls, lists, minResults, search])\n}\n\n// Check if currency is included in custom list from user storage\nexport function useIsUserAddedToken(currency: Currency | undefined | null): boolean {\n  const userAddedTokens = useUserAddedTokens()\n\n  if (!currency) {\n    return false\n  }\n\n  return !!userAddedTokens.find((token) => currency.equals(token))\n}\n\n// Check if currency on specific chain is included in custom list from user storage\nexport function useIsUserAddedTokenOnChain(\n  address: string | undefined | null,\n  chain: number | undefined | null\n): boolean {\n  const userAddedTokens = useUserAddedTokensOnChain(chain)\n\n  if (!address || !chain) {\n    return false\n  }\n\n  return !!userAddedTokens.find((token) => token.address === address)\n}\n\n// undefined if invalid or does not exist\n// null if loading or null was passed\n// otherwise returns the token\nexport function useToken(tokenAddress?: string | null): Token | null | undefined {\n  const tokens = useDefaultActiveTokens()\n  return useTokenFromMapOrNetwork(tokens, tokenAddress)\n}\n\nexport function useCurrency(currencyId?: string | null): Currency | null | undefined {\n  const tokens = useDefaultActiveTokens()\n  return useCurrencyFromMap(tokens, currencyId)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}