{"ast":null,"code":"/**\n * Recursively traverses an object to update an existing nested key.\n * Note: The provided key path must include existing properties,\n * the function will not create objects while traversing.\n *\n * @param obj An object to update\n * @param value The value to update the nested key with\n * @param keyPath The path to the key to update ex. fizz.buzz.foo\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setNestedKey(obj, keyPath, value) {\n  // Ex. foo.bar.zoop will extract foo and bar.zoop\n  const match = keyPath.match(/([a-z_]+)\\.(.*)/i);\n  // The match will be null when there's no more recursing to do, i.e., when we've reached the right level of the object\n  if (match === null) {\n    obj[keyPath] = value;\n  } else {\n    // `match[1]` is the initial segment of the path, and `match[2]` is the remainder of the path\n    const innerObj = obj[match[1]];\n    setNestedKey(innerObj, match[2], value);\n  }\n}\n\n/**\n * Enforces inclusion of a given integration with specified options in an integration array originally determined by the\n * user, by either including the given default instance or by patching an existing user instance with the given options.\n *\n * Ideally this would happen when integrations are set up, but there isn't currently a mechanism there for merging\n * options from a default integration instance with those from a user-provided instance of the same integration, only\n * for allowing the user to override a default instance entirely. (TODO: Fix that.)\n *\n * @param defaultIntegrationInstance An instance of the integration with the correct options already set\n * @param userIntegrations Integrations defined by the user.\n * @param forcedOptions Options with which to patch an existing user-derived instance on the integration.\n * @returns A final integrations array.\n */\nfunction addOrUpdateIntegration(defaultIntegrationInstance, userIntegrations) {\n  let forcedOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return Array.isArray(userIntegrations) ? addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions) : addOrUpdateIntegrationInFunction(defaultIntegrationInstance,\n  // Somehow TS can't figure out that not being an array makes this necessarily a function\n  userIntegrations, forcedOptions);\n}\nfunction addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions) {\n  const userInstance = userIntegrations.find(integration => integration.name === defaultIntegrationInstance.name);\n  if (userInstance) {\n    for (const [keyPath, value] of Object.entries(forcedOptions)) {\n      setNestedKey(userInstance, keyPath, value);\n    }\n    return userIntegrations;\n  }\n  return [...userIntegrations, defaultIntegrationInstance];\n}\nfunction addOrUpdateIntegrationInFunction(defaultIntegrationInstance, userIntegrationsFunc, forcedOptions) {\n  const wrapper = defaultIntegrations => {\n    const userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);\n\n    // There are instances where we want the user to be able to prevent an integration from appearing at all, which they\n    // would do by providing a function which filters out the integration in question. If that's happened in one of\n    // those cases, don't add our default back in.\n    if (defaultIntegrationInstance.allowExclusionByUser) {\n      const userFinalInstance = userFinalIntegrations.find(integration => integration.name === defaultIntegrationInstance.name);\n      if (!userFinalInstance) {\n        return userFinalIntegrations;\n      }\n    }\n    return addOrUpdateIntegrationInArray(defaultIntegrationInstance, userFinalIntegrations, forcedOptions);\n  };\n  return wrapper;\n}\nexport { addOrUpdateIntegration };","map":{"version":3,"sources":["../../src/userIntegrations.ts"],"names":[],"mappings":"AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,YAAA,CAAA,GAAA,EAAA,OAAA,EAAA,KAAA,EAAA;EACA;EACA,MAAA,KAAA,GAAA,OAAA,CAAA,KAAA,CAAA,kBAAA,CAAA;EACA;EACA,IAAA,KAAA,KAAA,IAAA,EAAA;IACA,GAAA,CAAA,OAAA,CAAA,GAAA,KAAA;EACA,CAAA,MAAA;IACA;IACA,MAAA,QAAA,GAAA,GAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;IACA,YAAA,CAAA,QAAA,EAAA,KAAA,CAAA,CAAA,CAAA,EAAA,KAAA,CAAA;EACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,sBAAA,CACA,0BAAA,EACA,gBAAA,EAEA;EAAA,IADA,aAAA,uEAAA,CAAA,CAAA;EAEA,OACA,KAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,GACA,6BAAA,CAAA,0BAAA,EAAA,gBAAA,EAAA,aAAA,CAAA,GACA,gCAAA,CACA,0BAAA;EACA;EACA,gBAAA,EACA,aAAA,CACA;AAEA;AAEA,SAAA,6BAAA,CACA,0BAAA,EACA,gBAAA,EACA,aAAA,EACA;EACA,MAAA,YAAA,GAAA,gBAAA,CAAA,IAAA,CAAA,WAAA,IAAA,WAAA,CAAA,IAAA,KAAA,0BAAA,CAAA,IAAA,CAAA;EAEA,IAAA,YAAA,EAAA;IACA,KAAA,MAAA,CAAA,OAAA,EAAA,KAAA,CAAA,IAAA,MAAA,CAAA,OAAA,CAAA,aAAA,CAAA,EAAA;MACA,YAAA,CAAA,YAAA,EAAA,OAAA,EAAA,KAAA,CAAA;IACA;IAEA,OAAA,gBAAA;EACA;EAEA,OAAA,CAAA,GAAA,gBAAA,EAAA,0BAAA,CAAA;AACA;AAEA,SAAA,gCAAA,CACA,0BAAA,EACA,oBAAA,EACA,aAAA,EACA;EACA,MAAA,OAAA,GAAA,mBAAA,IAAA;IACA,MAAA,qBAAA,GAAA,oBAAA,CAAA,mBAAA,CAAA;;IAEA;IACA;IACA;IACA,IAAA,0BAAA,CAAA,oBAAA,EAAA;MACA,MAAA,iBAAA,GAAA,qBAAA,CAAA,IAAA,CACA,WAAA,IAAA,WAAA,CAAA,IAAA,KAAA,0BAAA,CAAA,IAAA,CACA;MACA,IAAA,CAAA,iBAAA,EAAA;QACA,OAAA,qBAAA;MACA;IACA;IAEA,OAAA,6BAAA,CAAA,0BAAA,EAAA,qBAAA,EAAA,aAAA,CAAA;EACA,CAAA;EAEA,OAAA,OAAA;AACA","sourcesContent":["import type { Integration } from '@sentry/types';\n\nexport type UserIntegrationsFunction = (integrations: Integration[]) => Integration[];\nexport type UserIntegrations = Integration[] | UserIntegrationsFunction;\nexport type IntegrationWithExclusionOption = Integration & {\n  /**\n   * Allow the user to exclude this integration by not returning it from a function provided as the `integrations` option\n   * in `Sentry.init()`. Meant to be used with default integrations, the idea being that if a user has actively filtered\n   * an integration out, we should be able to respect that choice if we wish.\n   */\n  allowExclusionByUser?: boolean;\n};\n\ntype ForcedIntegrationOptions = {\n  [keyPath: string]: unknown;\n};\n\n/**\n * Recursively traverses an object to update an existing nested key.\n * Note: The provided key path must include existing properties,\n * the function will not create objects while traversing.\n *\n * @param obj An object to update\n * @param value The value to update the nested key with\n * @param keyPath The path to the key to update ex. fizz.buzz.foo\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setNestedKey(obj: Record<string, any>, keyPath: string, value: unknown): void {\n  // Ex. foo.bar.zoop will extract foo and bar.zoop\n  const match = keyPath.match(/([a-z_]+)\\.(.*)/i);\n  // The match will be null when there's no more recursing to do, i.e., when we've reached the right level of the object\n  if (match === null) {\n    obj[keyPath] = value;\n  } else {\n    // `match[1]` is the initial segment of the path, and `match[2]` is the remainder of the path\n    const innerObj = obj[match[1]];\n    setNestedKey(innerObj, match[2], value);\n  }\n}\n\n/**\n * Enforces inclusion of a given integration with specified options in an integration array originally determined by the\n * user, by either including the given default instance or by patching an existing user instance with the given options.\n *\n * Ideally this would happen when integrations are set up, but there isn't currently a mechanism there for merging\n * options from a default integration instance with those from a user-provided instance of the same integration, only\n * for allowing the user to override a default instance entirely. (TODO: Fix that.)\n *\n * @param defaultIntegrationInstance An instance of the integration with the correct options already set\n * @param userIntegrations Integrations defined by the user.\n * @param forcedOptions Options with which to patch an existing user-derived instance on the integration.\n * @returns A final integrations array.\n */\nexport function addOrUpdateIntegration<T extends UserIntegrations>(\n  defaultIntegrationInstance: Integration,\n  userIntegrations: T,\n  forcedOptions: ForcedIntegrationOptions = {},\n): T {\n  return (\n    Array.isArray(userIntegrations)\n      ? addOrUpdateIntegrationInArray(defaultIntegrationInstance, userIntegrations, forcedOptions)\n      : addOrUpdateIntegrationInFunction(\n          defaultIntegrationInstance,\n          // Somehow TS can't figure out that not being an array makes this necessarily a function\n          userIntegrations as UserIntegrationsFunction,\n          forcedOptions,\n        )\n  ) as T;\n}\n\nfunction addOrUpdateIntegrationInArray(\n  defaultIntegrationInstance: Integration,\n  userIntegrations: Integration[],\n  forcedOptions: ForcedIntegrationOptions,\n): Integration[] {\n  const userInstance = userIntegrations.find(integration => integration.name === defaultIntegrationInstance.name);\n\n  if (userInstance) {\n    for (const [keyPath, value] of Object.entries(forcedOptions)) {\n      setNestedKey(userInstance, keyPath, value);\n    }\n\n    return userIntegrations;\n  }\n\n  return [...userIntegrations, defaultIntegrationInstance];\n}\n\nfunction addOrUpdateIntegrationInFunction(\n  defaultIntegrationInstance: IntegrationWithExclusionOption,\n  userIntegrationsFunc: UserIntegrationsFunction,\n  forcedOptions: ForcedIntegrationOptions,\n): UserIntegrationsFunction {\n  const wrapper: UserIntegrationsFunction = defaultIntegrations => {\n    const userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);\n\n    // There are instances where we want the user to be able to prevent an integration from appearing at all, which they\n    // would do by providing a function which filters out the integration in question. If that's happened in one of\n    // those cases, don't add our default back in.\n    if (defaultIntegrationInstance.allowExclusionByUser) {\n      const userFinalInstance = userFinalIntegrations.find(\n        integration => integration.name === defaultIntegrationInstance.name,\n      );\n      if (!userFinalInstance) {\n        return userFinalIntegrations;\n      }\n    }\n\n    return addOrUpdateIntegrationInArray(defaultIntegrationInstance, userFinalIntegrations, forcedOptions);\n  };\n\n  return wrapper;\n}\n"]},"metadata":{},"sourceType":"module"}