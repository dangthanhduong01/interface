{"ast":null,"code":"import { TradeType } from '@uniswap/sdk-core';\nimport _ from 'lodash';\nimport { TokenValidationResult } from '../../../providers';\nimport { log, metric, MetricLoggerUnit, routeToString } from '../../../util';\nimport { V3RouteWithValidQuote } from '../entities';\nimport { computeAllV3Routes } from '../functions/compute-all-routes';\nimport { getV3CandidatePools } from '../functions/get-candidate-pools';\nimport { BaseQuoter } from './base-quoter';\nexport class V3Quoter extends BaseQuoter {\n  constructor(v3SubgraphProvider, v3PoolProvider, onChainQuoteProvider, tokenProvider, chainId, blockedTokenListProvider, tokenValidatorProvider) {\n    super(tokenProvider, chainId, blockedTokenListProvider, tokenValidatorProvider);\n    this.v3SubgraphProvider = v3SubgraphProvider;\n    this.v3PoolProvider = v3PoolProvider;\n    this.onChainQuoteProvider = onChainQuoteProvider;\n  }\n  async getRoutes(tokenIn, tokenOut, tradeType, routingConfig) {\n    // Fetch all the pools that we will consider routing via. There are thousands\n    // of pools, so we filter them to a set of candidate pools that we expect will\n    // result in good prices.\n    const {\n      poolAccessor,\n      candidatePools\n    } = await getV3CandidatePools({\n      tokenIn,\n      tokenOut,\n      tokenProvider: this.tokenProvider,\n      blockedTokenListProvider: this.blockedTokenListProvider,\n      poolProvider: this.v3PoolProvider,\n      routeType: tradeType,\n      subgraphProvider: this.v3SubgraphProvider,\n      routingConfig,\n      chainId: this.chainId\n    });\n    const poolsRaw = poolAccessor.getAllPools();\n    // Drop any pools that contain fee on transfer tokens (not supported by v3) or have issues with being transferred.\n    const pools = await this.applyTokenValidatorToPools(poolsRaw, (token, tokenValidation) => {\n      // If there is no available validation result we assume the token is fine.\n      if (!tokenValidation) {\n        return false;\n      }\n      // Only filters out *intermediate* pools that involve tokens that we detect\n      // cant be transferred. This prevents us trying to route through tokens that may\n      // not be transferrable, but allows users to still swap those tokens if they\n      // specify.\n      //\n      if (tokenValidation == TokenValidationResult.STF && (token.equals(tokenIn) || token.equals(tokenOut))) {\n        return false;\n      }\n      return tokenValidation == TokenValidationResult.FOT || tokenValidation == TokenValidationResult.STF;\n    });\n    // Given all our candidate pools, compute all the possible ways to route from tokenIn to tokenOut.\n    const {\n      maxSwapsPerPath\n    } = routingConfig;\n    const routes = computeAllV3Routes(tokenIn, tokenOut, pools, maxSwapsPerPath);\n    return {\n      routes,\n      candidatePools\n    };\n  }\n  async getQuotes(routes, amounts, percents, quoteToken, tradeType, routingConfig, candidatePools, gasModel) {\n    log.info('Starting to get V3 quotes');\n    if (gasModel === undefined) {\n      throw new Error('GasModel for V3RouteWithValidQuote is required to getQuotes');\n    }\n    if (routes.length == 0) {\n      return {\n        routesWithValidQuotes: [],\n        candidatePools\n      };\n    }\n    // For all our routes, and all the fractional amounts, fetch quotes on-chain.\n    const quoteFn = tradeType == TradeType.EXACT_INPUT ? this.onChainQuoteProvider.getQuotesManyExactIn.bind(this.onChainQuoteProvider) : this.onChainQuoteProvider.getQuotesManyExactOut.bind(this.onChainQuoteProvider);\n    const beforeQuotes = Date.now();\n    log.info(`Getting quotes for V3 for ${routes.length} routes with ${amounts.length} amounts per route.`);\n    const {\n      routesWithQuotes\n    } = await quoteFn(amounts, routes, {\n      blockNumber: routingConfig.blockNumber\n    });\n    metric.putMetric('V3QuotesLoad', Date.now() - beforeQuotes, MetricLoggerUnit.Milliseconds);\n    metric.putMetric('V3QuotesFetched', _(routesWithQuotes).map(_ref => {\n      let [, quotes] = _ref;\n      return quotes.length;\n    }).sum(), MetricLoggerUnit.Count);\n    const routesWithValidQuotes = [];\n    for (const routeWithQuote of routesWithQuotes) {\n      const [route, quotes] = routeWithQuote;\n      for (let i = 0; i < quotes.length; i++) {\n        const percent = percents[i];\n        const amountQuote = quotes[i];\n        const {\n          quote,\n          amount,\n          sqrtPriceX96AfterList,\n          initializedTicksCrossedList,\n          gasEstimate\n        } = amountQuote;\n        if (!quote || !sqrtPriceX96AfterList || !initializedTicksCrossedList || !gasEstimate) {\n          log.debug({\n            route: routeToString(route),\n            amountQuote\n          }, 'Dropping a null V3 quote for route.');\n          continue;\n        }\n        const routeWithValidQuote = new V3RouteWithValidQuote({\n          route,\n          rawQuote: quote,\n          amount,\n          percent,\n          sqrtPriceX96AfterList,\n          initializedTicksCrossedList,\n          quoterGasEstimate: gasEstimate,\n          gasModel,\n          quoteToken,\n          tradeType,\n          v3PoolProvider: this.v3PoolProvider\n        });\n        routesWithValidQuotes.push(routeWithValidQuote);\n      }\n    }\n    return {\n      routesWithValidQuotes,\n      candidatePools\n    };\n  }\n}","map":{"version":3,"sources":["../../../../../src/routers/alpha-router/quoters/v3-quoter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { TradeType } from '@uniswap/sdk-core';\nimport _ from 'lodash';\nimport { TokenValidationResult } from '../../../providers';\nimport { log, metric, MetricLoggerUnit, routeToString } from '../../../util';\nimport { V3RouteWithValidQuote } from '../entities';\nimport { computeAllV3Routes } from '../functions/compute-all-routes';\nimport { getV3CandidatePools } from '../functions/get-candidate-pools';\nimport { BaseQuoter } from './base-quoter';\nexport class V3Quoter extends BaseQuoter {\n    constructor(v3SubgraphProvider, v3PoolProvider, onChainQuoteProvider, tokenProvider, chainId, blockedTokenListProvider, tokenValidatorProvider) {\n        super(tokenProvider, chainId, blockedTokenListProvider, tokenValidatorProvider);\n        this.v3SubgraphProvider = v3SubgraphProvider;\n        this.v3PoolProvider = v3PoolProvider;\n        this.onChainQuoteProvider = onChainQuoteProvider;\n    }\n    async getRoutes(tokenIn, tokenOut, tradeType, routingConfig) {\n        // Fetch all the pools that we will consider routing via. There are thousands\n        // of pools, so we filter them to a set of candidate pools that we expect will\n        // result in good prices.\n        const { poolAccessor, candidatePools } = await getV3CandidatePools({\n            tokenIn,\n            tokenOut,\n            tokenProvider: this.tokenProvider,\n            blockedTokenListProvider: this.blockedTokenListProvider,\n            poolProvider: this.v3PoolProvider,\n            routeType: tradeType,\n            subgraphProvider: this.v3SubgraphProvider,\n            routingConfig,\n            chainId: this.chainId,\n        });\n        const poolsRaw = poolAccessor.getAllPools();\n        // Drop any pools that contain fee on transfer tokens (not supported by v3) or have issues with being transferred.\n        const pools = await this.applyTokenValidatorToPools(poolsRaw, (token, tokenValidation) => {\n            // If there is no available validation result we assume the token is fine.\n            if (!tokenValidation) {\n                return false;\n            }\n            // Only filters out *intermediate* pools that involve tokens that we detect\n            // cant be transferred. This prevents us trying to route through tokens that may\n            // not be transferrable, but allows users to still swap those tokens if they\n            // specify.\n            //\n            if (tokenValidation == TokenValidationResult.STF &&\n                (token.equals(tokenIn) || token.equals(tokenOut))) {\n                return false;\n            }\n            return (tokenValidation == TokenValidationResult.FOT ||\n                tokenValidation == TokenValidationResult.STF);\n        });\n        // Given all our candidate pools, compute all the possible ways to route from tokenIn to tokenOut.\n        const { maxSwapsPerPath } = routingConfig;\n        const routes = computeAllV3Routes(tokenIn, tokenOut, pools, maxSwapsPerPath);\n        return {\n            routes,\n            candidatePools,\n        };\n    }\n    async getQuotes(routes, amounts, percents, quoteToken, tradeType, routingConfig, candidatePools, gasModel) {\n        log.info('Starting to get V3 quotes');\n        if (gasModel === undefined) {\n            throw new Error('GasModel for V3RouteWithValidQuote is required to getQuotes');\n        }\n        if (routes.length == 0) {\n            return { routesWithValidQuotes: [], candidatePools };\n        }\n        // For all our routes, and all the fractional amounts, fetch quotes on-chain.\n        const quoteFn = tradeType == TradeType.EXACT_INPUT\n            ? this.onChainQuoteProvider.getQuotesManyExactIn.bind(this.onChainQuoteProvider)\n            : this.onChainQuoteProvider.getQuotesManyExactOut.bind(this.onChainQuoteProvider);\n        const beforeQuotes = Date.now();\n        log.info(`Getting quotes for V3 for ${routes.length} routes with ${amounts.length} amounts per route.`);\n        const { routesWithQuotes } = await quoteFn(amounts, routes, {\n            blockNumber: routingConfig.blockNumber,\n        });\n        metric.putMetric('V3QuotesLoad', Date.now() - beforeQuotes, MetricLoggerUnit.Milliseconds);\n        metric.putMetric('V3QuotesFetched', _(routesWithQuotes)\n            .map(([, quotes]) => quotes.length)\n            .sum(), MetricLoggerUnit.Count);\n        const routesWithValidQuotes = [];\n        for (const routeWithQuote of routesWithQuotes) {\n            const [route, quotes] = routeWithQuote;\n            for (let i = 0; i < quotes.length; i++) {\n                const percent = percents[i];\n                const amountQuote = quotes[i];\n                const { quote, amount, sqrtPriceX96AfterList, initializedTicksCrossedList, gasEstimate, } = amountQuote;\n                if (!quote ||\n                    !sqrtPriceX96AfterList ||\n                    !initializedTicksCrossedList ||\n                    !gasEstimate) {\n                    log.debug({\n                        route: routeToString(route),\n                        amountQuote,\n                    }, 'Dropping a null V3 quote for route.');\n                    continue;\n                }\n                const routeWithValidQuote = new V3RouteWithValidQuote({\n                    route,\n                    rawQuote: quote,\n                    amount,\n                    percent,\n                    sqrtPriceX96AfterList,\n                    initializedTicksCrossedList,\n                    quoterGasEstimate: gasEstimate,\n                    gasModel,\n                    quoteToken,\n                    tradeType,\n                    v3PoolProvider: this.v3PoolProvider,\n                });\n                routesWithValidQuotes.push(routeWithValidQuote);\n            }\n        }\n        return {\n            routesWithValidQuotes,\n            candidatePools\n        };\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidjMtcXVvdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL3JvdXRlcnMvYWxwaGEtcm91dGVyL3F1b3RlcnMvdjMtcXVvdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBbUIsU0FBUyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDL0QsT0FBTyxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBRXZCLE9BQU8sRUFPTCxxQkFBcUIsRUFDdEIsTUFBTSxvQkFBb0IsQ0FBQztBQUM1QixPQUFPLEVBQTJCLEdBQUcsRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsYUFBYSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBR3RHLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUNwRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNyRSxPQUFPLEVBQXFDLG1CQUFtQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFHMUcsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUkzQyxNQUFNLE9BQU8sUUFBUyxTQUFRLFVBQW1CO0lBSy9DLFlBQ0Usa0JBQXVDLEVBQ3ZDLGNBQStCLEVBQy9CLG9CQUEyQyxFQUMzQyxhQUE2QixFQUM3QixPQUFnQixFQUNoQix3QkFBNkMsRUFDN0Msc0JBQWdEO1FBRWhELEtBQUssQ0FBQyxhQUFhLEVBQUUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLHNCQUFzQixDQUFDLENBQUM7UUFDaEYsSUFBSSxDQUFDLGtCQUFrQixHQUFHLGtCQUFrQixDQUFDO1FBQzdDLElBQUksQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxvQkFBb0IsQ0FBQztJQUNuRCxDQUFDO0lBRVMsS0FBSyxDQUFDLFNBQVMsQ0FDdkIsT0FBYyxFQUNkLFFBQWUsRUFDZixTQUFvQixFQUNwQixhQUFnQztR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"]},"metadata":{},"sourceType":"module"}