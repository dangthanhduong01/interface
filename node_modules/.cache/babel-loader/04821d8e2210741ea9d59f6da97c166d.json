{"ast":null,"code":"import { isThenable } from '@sentry/utils';\nimport { getCurrentHub } from '../hub.js';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n *\n * Note that if you have not enabled tracing extensions via `addTracingExtensions`, this function\n * will not generate spans, and the `span` returned from the callback may be undefined.\n *\n * This function is meant to be used internally and may break at any time. Use at your own risk.\n *\n * @internal\n * @private\n */\nfunction trace(context, callback) {\n  let onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n  const ctx = {\n    ...context\n  };\n  // If a name is set and a description is not, set the description to the name.\n  if (ctx.name !== undefined && ctx.description === undefined) {\n    ctx.description = ctx.name;\n  }\n  const hub = getCurrentHub();\n  const scope = hub.getScope();\n  const parentSpan = scope.getSpan();\n  const activeSpan = parentSpan ? parentSpan.startChild(ctx) : hub.startTransaction(ctx);\n  scope.setSpan(activeSpan);\n  function finishAndSetSpan() {\n    activeSpan && activeSpan.finish();\n    hub.getScope().setSpan(parentSpan);\n  }\n  let maybePromiseResult;\n  try {\n    maybePromiseResult = callback(activeSpan);\n  } catch (e) {\n    activeSpan && activeSpan.setStatus('internal_error');\n    onError(e);\n    finishAndSetSpan();\n    throw e;\n  }\n  if (isThenable(maybePromiseResult)) {\n    Promise.resolve(maybePromiseResult).then(() => {\n      finishAndSetSpan();\n    }, e => {\n      activeSpan && activeSpan.setStatus('internal_error');\n      onError(e);\n      finishAndSetSpan();\n    });\n  } else {\n    finishAndSetSpan();\n  }\n  return maybePromiseResult;\n}\nexport { trace };","map":{"version":3,"sources":["../../../src/tracing/trace.ts"],"names":[],"mappings":";;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,KAAA,CACA,OAAA,EACA,QAAA,EAGA;EAAA,IADA,OAAA,uEAAA,MAAA,CAAA,CAAA;EAEA,MAAA,GAAA,GAAA;IAAA,GAAA;EAAA,CAAA;EACA;EACA,IAAA,GAAA,CAAA,IAAA,KAAA,SAAA,IAAA,GAAA,CAAA,WAAA,KAAA,SAAA,EAAA;IACA,GAAA,CAAA,WAAA,GAAA,GAAA,CAAA,IAAA;EACA;EAEA,MAAA,GAAA,GAAA,aAAA,EAAA;EACA,MAAA,KAAA,GAAA,GAAA,CAAA,QAAA,EAAA;EAEA,MAAA,UAAA,GAAA,KAAA,CAAA,OAAA,EAAA;EACA,MAAA,UAAA,GAAA,UAAA,GAAA,UAAA,CAAA,UAAA,CAAA,GAAA,CAAA,GAAA,GAAA,CAAA,gBAAA,CAAA,GAAA,CAAA;EACA,KAAA,CAAA,OAAA,CAAA,UAAA,CAAA;EAEA,SAAA,gBAAA,GAAA;IACA,UAAA,IAAA,UAAA,CAAA,MAAA,EAAA;IACA,GAAA,CAAA,QAAA,EAAA,CAAA,OAAA,CAAA,UAAA,CAAA;EACA;EAEA,IAAA,kBAAA;EACA,IAAA;IACA,kBAAA,GAAA,QAAA,CAAA,UAAA,CAAA;EACA,CAAA,CAAA,OAAA,CAAA,EAAA;IACA,UAAA,IAAA,UAAA,CAAA,SAAA,CAAA,gBAAA,CAAA;IACA,OAAA,CAAA,CAAA,CAAA;IACA,gBAAA,EAAA;IACA,MAAA,CAAA;EACA;EAEA,IAAA,UAAA,CAAA,kBAAA,CAAA,EAAA;IACA,OAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA,IAAA,CACA,MAAA;MACA,gBAAA,EAAA;IACA,CAAA,EACA,CAAA,IAAA;MACA,UAAA,IAAA,UAAA,CAAA,SAAA,CAAA,gBAAA,CAAA;MACA,OAAA,CAAA,CAAA,CAAA;MACA,gBAAA,EAAA;IACA,CAAA,CACA;EACA,CAAA,MAAA;IACA,gBAAA,EAAA;EACA;EAEA,OAAA,kBAAA;AACA","sourcesContent":["import type { TransactionContext } from '@sentry/types';\nimport { isThenable } from '@sentry/utils';\n\nimport { getCurrentHub } from '../hub';\nimport type { Span } from './span';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n *\n * Note that if you have not enabled tracing extensions via `addTracingExtensions`, this function\n * will not generate spans, and the `span` returned from the callback may be undefined.\n *\n * This function is meant to be used internally and may break at any time. Use at your own risk.\n *\n * @internal\n * @private\n */\nexport function trace<T>(\n  context: TransactionContext,\n  callback: (span?: Span) => T,\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  onError: (error: unknown) => void = () => {},\n): T {\n  const ctx = { ...context };\n  // If a name is set and a description is not, set the description to the name.\n  if (ctx.name !== undefined && ctx.description === undefined) {\n    ctx.description = ctx.name;\n  }\n\n  const hub = getCurrentHub();\n  const scope = hub.getScope();\n\n  const parentSpan = scope.getSpan();\n  const activeSpan = parentSpan ? parentSpan.startChild(ctx) : hub.startTransaction(ctx);\n  scope.setSpan(activeSpan);\n\n  function finishAndSetSpan(): void {\n    activeSpan && activeSpan.finish();\n    hub.getScope().setSpan(parentSpan);\n  }\n\n  let maybePromiseResult: T;\n  try {\n    maybePromiseResult = callback(activeSpan);\n  } catch (e) {\n    activeSpan && activeSpan.setStatus('internal_error');\n    onError(e);\n    finishAndSetSpan();\n    throw e;\n  }\n\n  if (isThenable(maybePromiseResult)) {\n    Promise.resolve(maybePromiseResult).then(\n      () => {\n        finishAndSetSpan();\n      },\n      e => {\n        activeSpan && activeSpan.setStatus('internal_error');\n        onError(e);\n        finishAndSetSpan();\n      },\n    );\n  } else {\n    finishAndSetSpan();\n  }\n\n  return maybePromiseResult;\n}\n"]},"metadata":{},"sourceType":"module"}