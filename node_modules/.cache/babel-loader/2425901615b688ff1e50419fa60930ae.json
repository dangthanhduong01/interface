{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { filterStringAtom, filterTimeAtom, sortAscendingAtom, sortMethodAtom, TokenSortMethod } from 'components/Tokens/state';\nimport gql from 'graphql-tag';\nimport { useAtomValue } from 'jotai/utils';\nimport { useMemo } from 'react';\nimport { useTopTokens100Query, useTopTokensSparklineQuery } from './__generated__/types-and-hooks';\nimport { CHAIN_NAME_TO_CHAIN_ID, isPricePoint, PollingInterval, toHistoryDuration, unwrapToken, usePollQueryWhileMounted } from './util';\ngql`\n  query TopTokens100($duration: HistoryDuration!, $chain: Chain!) {\n    topTokens(pageSize: 100, page: 1, chain: $chain, orderBy: VOLUME) {\n      id\n      name\n      chain\n      address\n      symbol\n      standard\n      market(currency: USD) {\n        id\n        totalValueLocked {\n          id\n          value\n          currency\n        }\n        price {\n          id\n          value\n          currency\n        }\n        pricePercentChange(duration: $duration) {\n          id\n          currency\n          value\n        }\n        volume(duration: $duration) {\n          id\n          value\n          currency\n        }\n      }\n      project {\n        id\n        logoUrl\n      }\n    }\n  }\n`;\n\n// We separately query sparkline data so that the large download time does not block Token Explore rendering\ngql`\n  query TopTokensSparkline($duration: HistoryDuration!, $chain: Chain!) {\n    topTokens(pageSize: 100, page: 1, chain: $chain, orderBy: VOLUME) {\n      id\n      address\n      chain\n      market(currency: USD) {\n        id\n        priceHistory(duration: $duration) {\n          id\n          timestamp\n          value\n        }\n      }\n    }\n  }\n`;\nfunction useSortedTokens(tokens) {\n  _s();\n  const sortMethod = useAtomValue(sortMethodAtom);\n  const sortAscending = useAtomValue(sortAscendingAtom);\n  return useMemo(() => {\n    if (!tokens) return undefined;\n    let tokenArray = Array.from(tokens);\n    switch (sortMethod) {\n      case TokenSortMethod.PRICE:\n        tokenArray = tokenArray.sort((a, b) => {\n          var _b$market$price$value, _b$market, _b$market$price, _a$market$price$value, _a$market, _a$market$price;\n          return ((_b$market$price$value = b === null || b === void 0 ? void 0 : (_b$market = b.market) === null || _b$market === void 0 ? void 0 : (_b$market$price = _b$market.price) === null || _b$market$price === void 0 ? void 0 : _b$market$price.value) !== null && _b$market$price$value !== void 0 ? _b$market$price$value : 0) - ((_a$market$price$value = a === null || a === void 0 ? void 0 : (_a$market = a.market) === null || _a$market === void 0 ? void 0 : (_a$market$price = _a$market.price) === null || _a$market$price === void 0 ? void 0 : _a$market$price.value) !== null && _a$market$price$value !== void 0 ? _a$market$price$value : 0);\n        });\n        break;\n      case TokenSortMethod.PERCENT_CHANGE:\n        tokenArray = tokenArray.sort((a, b) => {\n          var _b$market$pricePercen, _b$market2, _b$market2$pricePerce, _a$market$pricePercen, _a$market2, _a$market2$pricePerce;\n          return ((_b$market$pricePercen = b === null || b === void 0 ? void 0 : (_b$market2 = b.market) === null || _b$market2 === void 0 ? void 0 : (_b$market2$pricePerce = _b$market2.pricePercentChange) === null || _b$market2$pricePerce === void 0 ? void 0 : _b$market2$pricePerce.value) !== null && _b$market$pricePercen !== void 0 ? _b$market$pricePercen : 0) - ((_a$market$pricePercen = a === null || a === void 0 ? void 0 : (_a$market2 = a.market) === null || _a$market2 === void 0 ? void 0 : (_a$market2$pricePerce = _a$market2.pricePercentChange) === null || _a$market2$pricePerce === void 0 ? void 0 : _a$market2$pricePerce.value) !== null && _a$market$pricePercen !== void 0 ? _a$market$pricePercen : 0);\n        });\n        break;\n      case TokenSortMethod.TOTAL_VALUE_LOCKED:\n        tokenArray = tokenArray.sort((a, b) => {\n          var _b$market$totalValueL, _b$market3, _b$market3$totalValue, _a$market$totalValueL, _a$market3, _a$market3$totalValue;\n          return ((_b$market$totalValueL = b === null || b === void 0 ? void 0 : (_b$market3 = b.market) === null || _b$market3 === void 0 ? void 0 : (_b$market3$totalValue = _b$market3.totalValueLocked) === null || _b$market3$totalValue === void 0 ? void 0 : _b$market3$totalValue.value) !== null && _b$market$totalValueL !== void 0 ? _b$market$totalValueL : 0) - ((_a$market$totalValueL = a === null || a === void 0 ? void 0 : (_a$market3 = a.market) === null || _a$market3 === void 0 ? void 0 : (_a$market3$totalValue = _a$market3.totalValueLocked) === null || _a$market3$totalValue === void 0 ? void 0 : _a$market3$totalValue.value) !== null && _a$market$totalValueL !== void 0 ? _a$market$totalValueL : 0);\n        });\n        break;\n      case TokenSortMethod.VOLUME:\n        tokenArray = tokenArray.sort((a, b) => {\n          var _b$market$volume$valu, _b$market4, _b$market4$volume, _a$market$volume$valu, _a$market4, _a$market4$volume;\n          return ((_b$market$volume$valu = b === null || b === void 0 ? void 0 : (_b$market4 = b.market) === null || _b$market4 === void 0 ? void 0 : (_b$market4$volume = _b$market4.volume) === null || _b$market4$volume === void 0 ? void 0 : _b$market4$volume.value) !== null && _b$market$volume$valu !== void 0 ? _b$market$volume$valu : 0) - ((_a$market$volume$valu = a === null || a === void 0 ? void 0 : (_a$market4 = a.market) === null || _a$market4 === void 0 ? void 0 : (_a$market4$volume = _a$market4.volume) === null || _a$market4$volume === void 0 ? void 0 : _a$market4$volume.value) !== null && _a$market$volume$valu !== void 0 ? _a$market$volume$valu : 0);\n        });\n        break;\n    }\n    return sortAscending ? tokenArray.reverse() : tokenArray;\n  }, [tokens, sortMethod, sortAscending]);\n}\n_s(useSortedTokens, \"BkaqJpRjsaINhaxesa9Xi404Dwg=\", false, function () {\n  return [useAtomValue, useAtomValue];\n});\nfunction useFilteredTokens(tokens) {\n  _s2();\n  const filterString = useAtomValue(filterStringAtom);\n  const lowercaseFilterString = useMemo(() => filterString.toLowerCase(), [filterString]);\n  return useMemo(() => {\n    if (!tokens) return undefined;\n    let returnTokens = tokens;\n    if (lowercaseFilterString) {\n      var _returnTokens;\n      returnTokens = (_returnTokens = returnTokens) === null || _returnTokens === void 0 ? void 0 : _returnTokens.filter(token => {\n        var _token$address, _token$name, _token$symbol;\n        const addressIncludesFilterString = token === null || token === void 0 ? void 0 : (_token$address = token.address) === null || _token$address === void 0 ? void 0 : _token$address.toLowerCase().includes(lowercaseFilterString);\n        const nameIncludesFilterString = token === null || token === void 0 ? void 0 : (_token$name = token.name) === null || _token$name === void 0 ? void 0 : _token$name.toLowerCase().includes(lowercaseFilterString);\n        const symbolIncludesFilterString = token === null || token === void 0 ? void 0 : (_token$symbol = token.symbol) === null || _token$symbol === void 0 ? void 0 : _token$symbol.toLowerCase().includes(lowercaseFilterString);\n        return nameIncludesFilterString || symbolIncludesFilterString || addressIncludesFilterString;\n      });\n    }\n    return returnTokens;\n  }, [tokens, lowercaseFilterString]);\n}\n\n// Number of items to render in each fetch in infinite scroll.\n_s2(useFilteredTokens, \"n+zAzfCMGXS9ksESTnO2KIuyfhQ=\", false, function () {\n  return [useAtomValue];\n});\nexport const PAGE_SIZE = 20;\nexport function useTopTokens(chain) {\n  _s3();\n  const chainId = CHAIN_NAME_TO_CHAIN_ID[chain];\n  const duration = toHistoryDuration(useAtomValue(filterTimeAtom));\n  const {\n    data: sparklineQuery\n  } = usePollQueryWhileMounted(useTopTokensSparklineQuery({\n    variables: {\n      duration,\n      chain\n    }\n  }), PollingInterval.Slow);\n  const sparklines = useMemo(() => {\n    var _sparklineQuery$topTo;\n    const unwrappedTokens = sparklineQuery === null || sparklineQuery === void 0 ? void 0 : (_sparklineQuery$topTo = sparklineQuery.topTokens) === null || _sparklineQuery$topTo === void 0 ? void 0 : _sparklineQuery$topTo.map(topToken => unwrapToken(chainId, topToken));\n    const map = {};\n    unwrappedTokens === null || unwrappedTokens === void 0 ? void 0 : unwrappedTokens.forEach(current => {\n      var _current$market, _current$market$price;\n      return (current === null || current === void 0 ? void 0 : current.address) && (map[current.address] = current === null || current === void 0 ? void 0 : (_current$market = current.market) === null || _current$market === void 0 ? void 0 : (_current$market$price = _current$market.priceHistory) === null || _current$market$price === void 0 ? void 0 : _current$market$price.filter(isPricePoint));\n    });\n    return map;\n  }, [chainId, sparklineQuery === null || sparklineQuery === void 0 ? void 0 : sparklineQuery.topTokens]);\n  const {\n    data,\n    loading: loadingTokens\n  } = usePollQueryWhileMounted(useTopTokens100Query({\n    variables: {\n      duration,\n      chain\n    }\n  }), PollingInterval.Fast);\n  const unwrappedTokens = useMemo(() => {\n    var _data$topTokens;\n    return data === null || data === void 0 ? void 0 : (_data$topTokens = data.topTokens) === null || _data$topTokens === void 0 ? void 0 : _data$topTokens.map(token => unwrapToken(chainId, token));\n  }, [chainId, data]);\n  const sortedTokens = useSortedTokens(unwrappedTokens);\n  const tokenSortRank = useMemo(() => {\n    var _sortedTokens$reduce;\n    return (_sortedTokens$reduce = sortedTokens === null || sortedTokens === void 0 ? void 0 : sortedTokens.reduce((acc, cur, i) => {\n      if (!cur.address) return acc;\n      return {\n        ...acc,\n        [cur.address]: i + 1\n      };\n    }, {})) !== null && _sortedTokens$reduce !== void 0 ? _sortedTokens$reduce : {};\n  }, [sortedTokens]);\n  const filteredTokens = useFilteredTokens(sortedTokens);\n  return useMemo(() => ({\n    tokens: filteredTokens,\n    tokenSortRank,\n    loadingTokens,\n    sparklines\n  }), [filteredTokens, tokenSortRank, loadingTokens, sparklines]);\n}\n_s3(useTopTokens, \"OL3zW6ICs9ADTsnte3e7jubkBHI=\", false, function () {\n  return [useAtomValue, usePollQueryWhileMounted, useTopTokensSparklineQuery, usePollQueryWhileMounted, useTopTokens100Query, useSortedTokens, useFilteredTokens];\n});","map":{"version":3,"names":["filterStringAtom","filterTimeAtom","sortAscendingAtom","sortMethodAtom","TokenSortMethod","gql","useAtomValue","useMemo","useTopTokens100Query","useTopTokensSparklineQuery","CHAIN_NAME_TO_CHAIN_ID","isPricePoint","PollingInterval","toHistoryDuration","unwrapToken","usePollQueryWhileMounted","useSortedTokens","tokens","sortMethod","sortAscending","undefined","tokenArray","Array","from","PRICE","sort","a","b","market","price","value","PERCENT_CHANGE","pricePercentChange","TOTAL_VALUE_LOCKED","totalValueLocked","VOLUME","volume","reverse","useFilteredTokens","filterString","lowercaseFilterString","toLowerCase","returnTokens","filter","token","addressIncludesFilterString","address","includes","nameIncludesFilterString","name","symbolIncludesFilterString","symbol","PAGE_SIZE","useTopTokens","chain","chainId","duration","data","sparklineQuery","variables","Slow","sparklines","unwrappedTokens","topTokens","map","topToken","forEach","current","priceHistory","loading","loadingTokens","Fast","sortedTokens","tokenSortRank","reduce","acc","cur","i","filteredTokens"],"sources":["/home/diep/freelance/interface/src/graphql/data/TopTokens.ts"],"sourcesContent":["import {\n  filterStringAtom,\n  filterTimeAtom,\n  sortAscendingAtom,\n  sortMethodAtom,\n  TokenSortMethod,\n} from 'components/Tokens/state'\nimport gql from 'graphql-tag'\nimport { useAtomValue } from 'jotai/utils'\nimport { useMemo } from 'react'\n\nimport {\n  Chain,\n  TopTokens100Query,\n  useTopTokens100Query,\n  useTopTokensSparklineQuery,\n} from './__generated__/types-and-hooks'\nimport {\n  CHAIN_NAME_TO_CHAIN_ID,\n  isPricePoint,\n  PollingInterval,\n  PricePoint,\n  toHistoryDuration,\n  unwrapToken,\n  usePollQueryWhileMounted,\n} from './util'\n\ngql`\n  query TopTokens100($duration: HistoryDuration!, $chain: Chain!) {\n    topTokens(pageSize: 100, page: 1, chain: $chain, orderBy: VOLUME) {\n      id\n      name\n      chain\n      address\n      symbol\n      standard\n      market(currency: USD) {\n        id\n        totalValueLocked {\n          id\n          value\n          currency\n        }\n        price {\n          id\n          value\n          currency\n        }\n        pricePercentChange(duration: $duration) {\n          id\n          currency\n          value\n        }\n        volume(duration: $duration) {\n          id\n          value\n          currency\n        }\n      }\n      project {\n        id\n        logoUrl\n      }\n    }\n  }\n`\n\n// We separately query sparkline data so that the large download time does not block Token Explore rendering\ngql`\n  query TopTokensSparkline($duration: HistoryDuration!, $chain: Chain!) {\n    topTokens(pageSize: 100, page: 1, chain: $chain, orderBy: VOLUME) {\n      id\n      address\n      chain\n      market(currency: USD) {\n        id\n        priceHistory(duration: $duration) {\n          id\n          timestamp\n          value\n        }\n      }\n    }\n  }\n`\n\nfunction useSortedTokens(tokens: TopTokens100Query['topTokens']) {\n  const sortMethod = useAtomValue(sortMethodAtom)\n  const sortAscending = useAtomValue(sortAscendingAtom)\n\n  return useMemo(() => {\n    if (!tokens) return undefined\n    let tokenArray = Array.from(tokens)\n    switch (sortMethod) {\n      case TokenSortMethod.PRICE:\n        tokenArray = tokenArray.sort((a, b) => (b?.market?.price?.value ?? 0) - (a?.market?.price?.value ?? 0))\n        break\n      case TokenSortMethod.PERCENT_CHANGE:\n        tokenArray = tokenArray.sort(\n          (a, b) => (b?.market?.pricePercentChange?.value ?? 0) - (a?.market?.pricePercentChange?.value ?? 0)\n        )\n        break\n      case TokenSortMethod.TOTAL_VALUE_LOCKED:\n        tokenArray = tokenArray.sort(\n          (a, b) => (b?.market?.totalValueLocked?.value ?? 0) - (a?.market?.totalValueLocked?.value ?? 0)\n        )\n        break\n      case TokenSortMethod.VOLUME:\n        tokenArray = tokenArray.sort((a, b) => (b?.market?.volume?.value ?? 0) - (a?.market?.volume?.value ?? 0))\n        break\n    }\n\n    return sortAscending ? tokenArray.reverse() : tokenArray\n  }, [tokens, sortMethod, sortAscending])\n}\n\nfunction useFilteredTokens(tokens: TopTokens100Query['topTokens']) {\n  const filterString = useAtomValue(filterStringAtom)\n\n  const lowercaseFilterString = useMemo(() => filterString.toLowerCase(), [filterString])\n\n  return useMemo(() => {\n    if (!tokens) return undefined\n    let returnTokens = tokens\n    if (lowercaseFilterString) {\n      returnTokens = returnTokens?.filter((token) => {\n        const addressIncludesFilterString = token?.address?.toLowerCase().includes(lowercaseFilterString)\n        const nameIncludesFilterString = token?.name?.toLowerCase().includes(lowercaseFilterString)\n        const symbolIncludesFilterString = token?.symbol?.toLowerCase().includes(lowercaseFilterString)\n        return nameIncludesFilterString || symbolIncludesFilterString || addressIncludesFilterString\n      })\n    }\n    return returnTokens\n  }, [tokens, lowercaseFilterString])\n}\n\n// Number of items to render in each fetch in infinite scroll.\nexport const PAGE_SIZE = 20\nexport type SparklineMap = { [key: string]: PricePoint[] | undefined }\nexport type TopToken = NonNullable<NonNullable<TopTokens100Query>['topTokens']>[number]\n\ninterface UseTopTokensReturnValue {\n  tokens: TopToken[] | undefined\n  tokenSortRank: Record<string, number>\n  loadingTokens: boolean\n  sparklines: SparklineMap\n}\n\nexport function useTopTokens(chain: Chain): UseTopTokensReturnValue {\n  const chainId = CHAIN_NAME_TO_CHAIN_ID[chain]\n  const duration = toHistoryDuration(useAtomValue(filterTimeAtom))\n\n  const { data: sparklineQuery } = usePollQueryWhileMounted(\n    useTopTokensSparklineQuery({\n      variables: { duration, chain },\n    }),\n    PollingInterval.Slow\n  )\n\n  const sparklines = useMemo(() => {\n    const unwrappedTokens = sparklineQuery?.topTokens?.map((topToken) => unwrapToken(chainId, topToken))\n    const map: SparklineMap = {}\n    unwrappedTokens?.forEach(\n      (current) => current?.address && (map[current.address] = current?.market?.priceHistory?.filter(isPricePoint))\n    )\n    return map\n  }, [chainId, sparklineQuery?.topTokens])\n\n  const { data, loading: loadingTokens } = usePollQueryWhileMounted(\n    useTopTokens100Query({\n      variables: { duration, chain },\n    }),\n    PollingInterval.Fast\n  )\n\n  const unwrappedTokens = useMemo(() => data?.topTokens?.map((token) => unwrapToken(chainId, token)), [chainId, data])\n  const sortedTokens = useSortedTokens(unwrappedTokens)\n  const tokenSortRank = useMemo(\n    () =>\n      sortedTokens?.reduce((acc, cur, i) => {\n        if (!cur.address) return acc\n        return {\n          ...acc,\n          [cur.address]: i + 1,\n        }\n      }, {}) ?? {},\n    [sortedTokens]\n  )\n  const filteredTokens = useFilteredTokens(sortedTokens)\n  return useMemo(\n    () => ({ tokens: filteredTokens, tokenSortRank, loadingTokens, sparklines }),\n    [filteredTokens, tokenSortRank, loadingTokens, sparklines]\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}