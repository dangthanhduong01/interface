{"ast":null,"code":"import { getCurrentHub } from '@sentry/core';\nimport { logger } from '@sentry/utils';\nimport { PROFILING_EVENT_CACHE } from './cache.js';\nimport { createProfilingEventEnvelope } from './utils.js';\n\n/**\n * Performs lookup in the event cache and sends the profile to Sentry.\n * If the profiled transaction event is found, we use the profiled transaction event and profile\n * to construct a profile type envelope and send it to Sentry.\n */\nfunction sendProfile(profileId, profile) {\n  const event = PROFILING_EVENT_CACHE.get(profileId);\n  if (!event) {\n    // We could not find a corresponding transaction event for this profile.\n    // Opt to do nothing for now, but in the future we should implement a simple retry mechanism.\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log(\"[Profiling] Couldn't find a transaction event for this profile, dropping it.\");\n    }\n    return;\n  }\n  event.sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n  if (event.sdkProcessingMetadata && !event.sdkProcessingMetadata['profile']) {\n    event.sdkProcessingMetadata['profile'] = profile;\n  }\n\n  // Client, Dsn and Transport are all required to be able to send the profiling event to Sentry.\n  // If either of them is not available, we remove the profile from the transaction event.\n  // and forward it to the next event processor.\n  const hub = getCurrentHub();\n  const client = hub.getClient();\n  if (!client) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] getClient did not return a Client, removing profile from event and forwarding to next event processors.');\n    }\n    return;\n  }\n  const dsn = client.getDsn();\n  if (!dsn) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] getDsn did not return a Dsn, removing profile from event and forwarding to next event processors.');\n    }\n    return;\n  }\n  const transport = client.getTransport();\n  if (!transport) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] getTransport did not return a Transport, removing profile from event and forwarding to next event processors.');\n    }\n    return;\n  }\n\n  // If all required components are available, we construct a profiling event envelope and send it to Sentry.\n  if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n    logger.log('[Profiling] Preparing envelope and sending a profiling event');\n  }\n  const envelope = createProfilingEventEnvelope(event, dsn);\n\n  // Evict event from the cache - we want to prevent the LRU cache from prioritizing already sent events over new ones.\n  PROFILING_EVENT_CACHE.delete(profileId);\n  if (!envelope) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] Failed to construct envelope');\n    }\n    return;\n  }\n  if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n    logger.log('[Profiling] Envelope constructed, sending it');\n  }\n\n  // Wrap in try/catch because send will throw in case of a network error.\n  transport.send(envelope).then(null, reason => {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Profiling] Error while sending event:', reason);\n  });\n}\nexport { sendProfile };","map":{"version":3,"sources":["../../../../src/profiling/sendProfile.ts"],"names":[],"mappings":";;;;;AAOA;AACA;AACA;AACA;AACA;AACA,SAAA,WAAA,CAAA,SAAA,EAAA,OAAA,EAAA;EACA,MAAA,KAAA,GAAA,qBAAA,CAAA,GAAA,CAAA,SAAA,CAAA;EAEA,IAAA,CAAA,KAAA,EAAA;IACA;IACA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CAAA,8EAAA,CAAA;IACA;IACA;EACA;EAEA,KAAA,CAAA,qBAAA,GAAA,KAAA,CAAA,qBAAA,IAAA,CAAA,CAAA;EACA,IAAA,KAAA,CAAA,qBAAA,IAAA,CAAA,KAAA,CAAA,qBAAA,CAAA,SAAA,CAAA,EAAA;IACA,KAAA,CAAA,qBAAA,CAAA,SAAA,CAAA,GAAA,OAAA;EACA;;EAEA;EACA;EACA;EACA,MAAA,GAAA,GAAA,aAAA,EAAA;EACA,MAAA,MAAA,GAAA,GAAA,CAAA,SAAA,EAAA;EAEA,IAAA,CAAA,MAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CACA,qHAAA,CACA;IACA;IACA;EACA;EAEA,MAAA,GAAA,GAAA,MAAA,CAAA,MAAA,EAAA;EACA,IAAA,CAAA,GAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CACA,+GAAA,CACA;IACA;IACA;EACA;EAEA,MAAA,SAAA,GAAA,MAAA,CAAA,YAAA,EAAA;EACA,IAAA,CAAA,SAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CACA,2HAAA,CACA;IACA;IACA;EACA;;EAEA;EACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;IACA,MAAA,CAAA,GAAA,CAAA,8DAAA,CAAA;EACA;EACA,MAAA,QAAA,GAAA,4BAAA,CAAA,KAAA,EAAA,GAAA,CAAA;;EAEA;EACA,qBAAA,CAAA,MAAA,CAAA,SAAA,CAAA;EAEA,IAAA,CAAA,QAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CAAA,0CAAA,CAAA;IACA;IACA;EACA;EAEA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;IACA,MAAA,CAAA,GAAA,CAAA,8CAAA,CAAA;EACA;;EAEA;EACA,SAAA,CAAA,IAAA,CAAA,QAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAA,MAAA,IAAA;IACA,CAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,KAAA,MAAA,CAAA,GAAA,CAAA,wCAAA,EAAA,MAAA,CAAA;EACA,CAAA,CAAA;AACA","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { logger } from '@sentry/utils';\n\nimport { PROFILING_EVENT_CACHE } from './cache';\nimport type { ProcessedJSSelfProfile } from './jsSelfProfiling';\nimport type { ProfiledEvent } from './utils';\nimport { createProfilingEventEnvelope } from './utils';\n/**\n * Performs lookup in the event cache and sends the profile to Sentry.\n * If the profiled transaction event is found, we use the profiled transaction event and profile\n * to construct a profile type envelope and send it to Sentry.\n */\nexport function sendProfile(profileId: string, profile: ProcessedJSSelfProfile): void {\n  const event = PROFILING_EVENT_CACHE.get(profileId);\n\n  if (!event) {\n    // We could not find a corresponding transaction event for this profile.\n    // Opt to do nothing for now, but in the future we should implement a simple retry mechanism.\n    if (__DEBUG_BUILD__) {\n      logger.log(\"[Profiling] Couldn't find a transaction event for this profile, dropping it.\");\n    }\n    return;\n  }\n\n  event.sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n  if (event.sdkProcessingMetadata && !event.sdkProcessingMetadata['profile']) {\n    event.sdkProcessingMetadata['profile'] = profile;\n  }\n\n  // Client, Dsn and Transport are all required to be able to send the profiling event to Sentry.\n  // If either of them is not available, we remove the profile from the transaction event.\n  // and forward it to the next event processor.\n  const hub = getCurrentHub();\n  const client = hub.getClient();\n\n  if (!client) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        '[Profiling] getClient did not return a Client, removing profile from event and forwarding to next event processors.',\n      );\n    }\n    return;\n  }\n\n  const dsn = client.getDsn();\n  if (!dsn) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        '[Profiling] getDsn did not return a Dsn, removing profile from event and forwarding to next event processors.',\n      );\n    }\n    return;\n  }\n\n  const transport = client.getTransport();\n  if (!transport) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        '[Profiling] getTransport did not return a Transport, removing profile from event and forwarding to next event processors.',\n      );\n    }\n    return;\n  }\n\n  // If all required components are available, we construct a profiling event envelope and send it to Sentry.\n  if (__DEBUG_BUILD__) {\n    logger.log('[Profiling] Preparing envelope and sending a profiling event');\n  }\n  const envelope = createProfilingEventEnvelope(event as ProfiledEvent, dsn);\n\n  // Evict event from the cache - we want to prevent the LRU cache from prioritizing already sent events over new ones.\n  PROFILING_EVENT_CACHE.delete(profileId);\n\n  if (!envelope) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Failed to construct envelope');\n    }\n    return;\n  }\n\n  if (__DEBUG_BUILD__) {\n    logger.log('[Profiling] Envelope constructed, sending it');\n  }\n\n  // Wrap in try/catch because send will throw in case of a network error.\n  transport.send(envelope).then(null, reason => {\n    __DEBUG_BUILD__ && logger.log('[Profiling] Error while sending event:', reason);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}