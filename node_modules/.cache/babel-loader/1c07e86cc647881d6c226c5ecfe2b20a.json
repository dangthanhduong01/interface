{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { signTypedData } from '@uniswap/conedison/provider/signing';\nimport { AllowanceTransfer, MaxAllowanceTransferAmount, PERMIT2_ADDRESS } from '@uniswap/permit2-sdk';\nimport { CurrencyAmount } from '@uniswap/sdk-core';\nimport { useWeb3React } from '@web3-react/core';\nimport PERMIT2_ABI from 'abis/permit2.json';\nimport { useContract } from 'hooks/useContract';\nimport { useSingleCallResult } from 'lib/hooks/multicall';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nconst PERMIT_EXPIRATION = 2592000000;\nconst PERMIT_SIG_EXPIRATION = 1800000;\nfunction toDeadline(expiration) {\n  return Math.floor((Date.now() + expiration) / 1000);\n}\nexport function usePermitAllowance(token, owner, spender) {\n  _s();\n  const contract = useContract(PERMIT2_ADDRESS, PERMIT2_ABI);\n  const inputs = useMemo(() => [owner, token === null || token === void 0 ? void 0 : token.address, spender], [owner, spender, token === null || token === void 0 ? void 0 : token.address]);\n\n  // If there is no allowance yet, re-check next observed block.\n  // This guarantees that the permitAllowance is synced upon submission and updated upon being synced.\n  const [blocksPerFetch, setBlocksPerFetch] = useState();\n  const result = useSingleCallResult(contract, 'allowance', inputs, {\n    blocksPerFetch\n  }).result;\n  const rawAmount = result === null || result === void 0 ? void 0 : result.amount.toString(); // convert to a string before using in a hook, to avoid spurious rerenders\n  const allowance = useMemo(() => token && rawAmount ? CurrencyAmount.fromRawAmount(token, rawAmount) : undefined, [token, rawAmount]);\n  useEffect(() => setBlocksPerFetch((allowance === null || allowance === void 0 ? void 0 : allowance.equalTo(0)) ? 1 : undefined), [allowance]);\n  return useMemo(() => ({\n    permitAllowance: allowance,\n    expiration: result === null || result === void 0 ? void 0 : result.expiration,\n    nonce: result === null || result === void 0 ? void 0 : result.nonce\n  }), [allowance, result === null || result === void 0 ? void 0 : result.expiration, result === null || result === void 0 ? void 0 : result.nonce]);\n}\n_s(usePermitAllowance, \"50gnPRNShmnY90EvDcfS+ik95EM=\", false, function () {\n  return [useContract, useSingleCallResult];\n});\nexport function useUpdatePermitAllowance(token, spender, nonce, onPermitSignature) {\n  _s2();\n  const {\n    account,\n    chainId,\n    provider\n  } = useWeb3React();\n  return useCallback(async () => {\n    try {\n      if (!chainId) throw new Error('missing chainId');\n      if (!provider) throw new Error('missing provider');\n      if (!token) throw new Error('missing token');\n      if (!spender) throw new Error('missing spender');\n      if (nonce === undefined) throw new Error('missing nonce');\n      const permit = {\n        details: {\n          token: token.address,\n          amount: MaxAllowanceTransferAmount,\n          expiration: toDeadline(PERMIT_EXPIRATION),\n          nonce\n        },\n        spender,\n        sigDeadline: toDeadline(PERMIT_SIG_EXPIRATION)\n      };\n      const {\n        domain,\n        types,\n        values\n      } = AllowanceTransfer.getPermitData(permit, PERMIT2_ADDRESS, chainId);\n      // Use conedison's signTypedData for better x-wallet compatibility.\n      const signature = await signTypedData(provider.getSigner(account), domain, types, values);\n      onPermitSignature === null || onPermitSignature === void 0 ? void 0 : onPermitSignature({\n        ...permit,\n        signature\n      });\n      return;\n    } catch (e) {\n      var _token$symbol;\n      const symbol = (_token$symbol = token === null || token === void 0 ? void 0 : token.symbol) !== null && _token$symbol !== void 0 ? _token$symbol : 'Token';\n      throw new Error(`${symbol} permit allowance failed: ${e instanceof Error ? e.message : e}`);\n    }\n  }, [account, chainId, nonce, onPermitSignature, provider, spender, token]);\n}\n_s2(useUpdatePermitAllowance, \"Er43l/h37JfIIXMK+0pJt5mfuPM=\", false, function () {\n  return [useWeb3React];\n});","map":{"version":3,"names":["signTypedData","AllowanceTransfer","MaxAllowanceTransferAmount","PERMIT2_ADDRESS","CurrencyAmount","useWeb3React","PERMIT2_ABI","useContract","useSingleCallResult","useCallback","useEffect","useMemo","useState","PERMIT_EXPIRATION","PERMIT_SIG_EXPIRATION","toDeadline","expiration","Math","floor","Date","now","usePermitAllowance","token","owner","spender","contract","inputs","address","blocksPerFetch","setBlocksPerFetch","result","rawAmount","amount","toString","allowance","fromRawAmount","undefined","equalTo","permitAllowance","nonce","useUpdatePermitAllowance","onPermitSignature","account","chainId","provider","Error","permit","details","sigDeadline","domain","types","values","getPermitData","signature","getSigner","e","symbol","message"],"sources":["/home/diep/freelance/interface/src/hooks/usePermitAllowance.ts"],"sourcesContent":["import { signTypedData } from '@uniswap/conedison/provider/signing'\nimport { AllowanceTransfer, MaxAllowanceTransferAmount, PERMIT2_ADDRESS, PermitSingle } from '@uniswap/permit2-sdk'\nimport { CurrencyAmount, Token } from '@uniswap/sdk-core'\nimport { useWeb3React } from '@web3-react/core'\nimport PERMIT2_ABI from 'abis/permit2.json'\nimport { Permit2 } from 'abis/types'\nimport { useContract } from 'hooks/useContract'\nimport { useSingleCallResult } from 'lib/hooks/multicall'\nimport ms from 'ms.macro'\nimport { useCallback, useEffect, useMemo, useState } from 'react'\n\nconst PERMIT_EXPIRATION = ms`30d`\nconst PERMIT_SIG_EXPIRATION = ms`30m`\n\nfunction toDeadline(expiration: number): number {\n  return Math.floor((Date.now() + expiration) / 1000)\n}\n\nexport function usePermitAllowance(token?: Token, owner?: string, spender?: string) {\n  const contract = useContract<Permit2>(PERMIT2_ADDRESS, PERMIT2_ABI)\n  const inputs = useMemo(() => [owner, token?.address, spender], [owner, spender, token?.address])\n\n  // If there is no allowance yet, re-check next observed block.\n  // This guarantees that the permitAllowance is synced upon submission and updated upon being synced.\n  const [blocksPerFetch, setBlocksPerFetch] = useState<1>()\n  const result = useSingleCallResult(contract, 'allowance', inputs, {\n    blocksPerFetch,\n  }).result as Awaited<ReturnType<Permit2['allowance']>> | undefined\n\n  const rawAmount = result?.amount.toString() // convert to a string before using in a hook, to avoid spurious rerenders\n  const allowance = useMemo(\n    () => (token && rawAmount ? CurrencyAmount.fromRawAmount(token, rawAmount) : undefined),\n    [token, rawAmount]\n  )\n  useEffect(() => setBlocksPerFetch(allowance?.equalTo(0) ? 1 : undefined), [allowance])\n\n  return useMemo(\n    () => ({ permitAllowance: allowance, expiration: result?.expiration, nonce: result?.nonce }),\n    [allowance, result?.expiration, result?.nonce]\n  )\n}\n\ninterface Permit extends PermitSingle {\n  sigDeadline: number\n}\n\nexport interface PermitSignature extends Permit {\n  signature: string\n}\n\nexport function useUpdatePermitAllowance(\n  token: Token | undefined,\n  spender: string | undefined,\n  nonce: number | undefined,\n  onPermitSignature: (signature: PermitSignature) => void\n) {\n  const { account, chainId, provider } = useWeb3React()\n\n  return useCallback(async () => {\n    try {\n      if (!chainId) throw new Error('missing chainId')\n      if (!provider) throw new Error('missing provider')\n      if (!token) throw new Error('missing token')\n      if (!spender) throw new Error('missing spender')\n      if (nonce === undefined) throw new Error('missing nonce')\n\n      const permit: Permit = {\n        details: {\n          token: token.address,\n          amount: MaxAllowanceTransferAmount,\n          expiration: toDeadline(PERMIT_EXPIRATION),\n          nonce,\n        },\n        spender,\n        sigDeadline: toDeadline(PERMIT_SIG_EXPIRATION),\n      }\n\n      const { domain, types, values } = AllowanceTransfer.getPermitData(permit, PERMIT2_ADDRESS, chainId)\n      // Use conedison's signTypedData for better x-wallet compatibility.\n      const signature = await signTypedData(provider.getSigner(account), domain, types, values)\n      onPermitSignature?.({ ...permit, signature })\n      return\n    } catch (e: unknown) {\n      const symbol = token?.symbol ?? 'Token'\n      throw new Error(`${symbol} permit allowance failed: ${e instanceof Error ? e.message : e}`)\n    }\n  }, [account, chainId, nonce, onPermitSignature, provider, spender, token])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}