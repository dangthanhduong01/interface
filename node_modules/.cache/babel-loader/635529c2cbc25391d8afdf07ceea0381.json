{"ast":null,"code":"import { addInstrumentationHandler, logger } from '@sentry/utils';\nimport { getActiveTransaction } from './utils.js';\nlet errorsInstrumented = false;\n\n/**\n * Configures global error listeners\n */\nfunction registerErrorInstrumentation() {\n  if (errorsInstrumented) {\n    return;\n  }\n  errorsInstrumented = true;\n  addInstrumentationHandler('error', errorCallback);\n  addInstrumentationHandler('unhandledrejection', errorCallback);\n}\n\n/**\n * If an error or unhandled promise occurs, we mark the active transaction as failed\n */\nfunction errorCallback() {\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const status = 'internal_error';\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Transaction: ${status} -> Global error occured`);\n    activeTransaction.setStatus(status);\n  }\n}\n\n// The function name will be lost when bundling but we need to be able to identify this listener later to maintain the\n// node.js default exit behaviour\nerrorCallback.tag = 'sentry_tracingErrorCallback';\nexport { registerErrorInstrumentation };","map":{"version":3,"sources":["../../../src/tracing/errors.ts"],"names":[],"mappings":";;AAKA,IAAA,kBAAA,GAAA,KAAA;;AAEA;AACA;AACA;AACA,SAAA,4BAAA,GAAA;EACA,IAAA,kBAAA,EAAA;IACA;EACA;EAEA,kBAAA,GAAA,IAAA;EACA,yBAAA,CAAA,OAAA,EAAA,aAAA,CAAA;EACA,yBAAA,CAAA,oBAAA,EAAA,aAAA,CAAA;AACA;;AAEA;AACA;AACA;AACA,SAAA,aAAA,GAAA;EACA,MAAA,iBAAA,GAAA,oBAAA,EAAA;EACA,IAAA,iBAAA,EAAA;IACA,MAAA,MAAA,GAAA,gBAAA;IACA,CAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,KAAA,MAAA,CAAA,GAAA,CAAA,0BAAA,MAAA,0BAAA,CAAA;IACA,iBAAA,CAAA,SAAA,CAAA,MAAA,CAAA;EACA;AACA;;AAEA;AACA;AACA,aAAA,CAAA,GAAA,GAAA,6BAAA","sourcesContent":["import { addInstrumentationHandler, logger } from '@sentry/utils';\n\nimport type { SpanStatusType } from './span';\nimport { getActiveTransaction } from './utils';\n\nlet errorsInstrumented = false;\n\n/**\n * Configures global error listeners\n */\nexport function registerErrorInstrumentation(): void {\n  if (errorsInstrumented) {\n    return;\n  }\n\n  errorsInstrumented = true;\n  addInstrumentationHandler('error', errorCallback);\n  addInstrumentationHandler('unhandledrejection', errorCallback);\n}\n\n/**\n * If an error or unhandled promise occurs, we mark the active transaction as failed\n */\nfunction errorCallback(): void {\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const status: SpanStatusType = 'internal_error';\n    __DEBUG_BUILD__ && logger.log(`[Tracing] Transaction: ${status} -> Global error occured`);\n    activeTransaction.setStatus(status);\n  }\n}\n\n// The function name will be lost when bundling but we need to be able to identify this listener later to maintain the\n// node.js default exit behaviour\nerrorCallback.tag = 'sentry_tracingErrorCallback';\n"]},"metadata":{},"sourceType":"module"}