{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleTree = void 0;\nconst buffer_1 = require(\"buffer\");\nconst buffer_reverse_1 = __importDefault(require(\"buffer-reverse\"));\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nconst treeify_1 = __importDefault(require(\"treeify\"));\nconst Base_1 = __importDefault(require(\"./Base\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nclass MerkleTree extends Base_1.default {\n  /**\n   * @desc Constructs a Merkle Tree.\n   * All nodes and leaves are stored as Buffers.\n   * Lonely leaf nodes are promoted to the next level up without being hashed again.\n   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @example\n   *```js\n   *const MerkleTree = require('merkletreejs')\n   *const crypto = require('crypto')\n   *\n   *function sha256(data) {\n   *  // returns Buffer\n   *  return crypto.createHash('sha256').update(data).digest()\n   *}\n   *\n   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n   *\n   *const tree = new MerkleTree(leaves, sha256)\n   *```\n   */\n  constructor(leaves) {\n    let hashFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256_1.default;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.duplicateOdd = false;\n    this.concatenator = buffer_1.Buffer.concat;\n    this.hashLeaves = false;\n    this.isBitcoinTree = false;\n    this.leaves = [];\n    this.layers = [];\n    this.sortLeaves = false;\n    this.sortPairs = false;\n    this.sort = false;\n    this.fillDefaultHash = null;\n    this.complete = false;\n    if (options.complete) {\n      if (options.isBitcoinTree) {\n        throw new Error('option \"complete\" is incompatible with \"isBitcoinTree\"');\n      }\n      if (options.duplicateOdd) {\n        throw new Error('option \"complete\" is incompatible with \"duplicateOdd\"');\n      }\n    }\n    this.isBitcoinTree = !!options.isBitcoinTree;\n    this.hashLeaves = !!options.hashLeaves;\n    this.sortLeaves = !!options.sortLeaves;\n    this.sortPairs = !!options.sortPairs;\n    this.complete = !!options.complete;\n    if (options.fillDefaultHash) {\n      if (typeof options.fillDefaultHash === 'function') {\n        this.fillDefaultHash = options.fillDefaultHash;\n      } else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n        this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n      } else {\n        throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n      }\n    }\n    this.sort = !!options.sort;\n    if (this.sort) {\n      this.sortLeaves = true;\n      this.sortPairs = true;\n    }\n    this.duplicateOdd = !!options.duplicateOdd;\n    if (options.concatenator) {\n      this.concatenator = options.concatenator;\n    }\n    this.hashFn = this.bufferifyFn(hashFn);\n    this.processLeaves(leaves);\n  }\n  getOptions() {\n    var _a, _b;\n    return {\n      complete: this.complete,\n      isBitcoinTree: this.isBitcoinTree,\n      hashLeaves: this.hashLeaves,\n      sortLeaves: this.sortLeaves,\n      sortPairs: this.sortPairs,\n      sort: this.sort,\n      fillDefaultHash: (_b = (_a = this.fillDefaultHash) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null,\n      duplicateOdd: this.duplicateOdd\n    };\n  }\n  processLeaves(leaves) {\n    if (this.hashLeaves) {\n      leaves = leaves.map(this.hashFn);\n    }\n    this.leaves = leaves.map(this.bufferify);\n    if (this.sortLeaves) {\n      this.leaves = this.leaves.sort(buffer_1.Buffer.compare);\n    }\n    if (this.fillDefaultHash) {\n      for (let i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n        if (i >= this.leaves.length) {\n          this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n        }\n      }\n    }\n    this.createHashes(this.leaves);\n  }\n  createHashes(nodes) {\n    this.layers = [nodes];\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n      this.layers.push([]);\n      const layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length)) ? 2 * nodes.length - Math.pow(2, Math.ceil(Math.log2(nodes.length))) : nodes.length;\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          this.layers[layerIndex].push(...nodes.slice(layerLimit));\n          break;\n        } else if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            const data = nodes[nodes.length - 1];\n            let hash = data;\n            // is bitcoin tree\n            if (this.isBitcoinTree) {\n              // Bitcoin method of duplicating the odd ending nodes\n              hash = this.hashFn(this.concatenator([buffer_reverse_1.default(data), buffer_reverse_1.default(data)]));\n              hash = buffer_reverse_1.default(this.hashFn(hash));\n              this.layers[layerIndex].push(hash);\n              continue;\n            } else {\n              if (this.duplicateOdd) {\n                // continue with creating layer\n              } else {\n                // push copy of hash and continue iteration\n                this.layers[layerIndex].push(nodes[i]);\n                continue;\n              }\n            }\n          }\n        }\n        const left = nodes[i];\n        const right = i + 1 === nodes.length ? left : nodes[i + 1];\n        let combined = null;\n        if (this.isBitcoinTree) {\n          combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n        } else {\n          combined = [left, right];\n        }\n        if (this.sortPairs) {\n          combined.sort(buffer_1.Buffer.compare);\n        }\n        let hash = this.hashFn(this.concatenator(combined));\n        // double hash if bitcoin tree\n        if (this.isBitcoinTree) {\n          hash = buffer_reverse_1.default(this.hashFn(hash));\n        }\n        this.layers[layerIndex].push(hash);\n      }\n      nodes = this.layers[layerIndex];\n    }\n  }\n  /**\n   * addLeaf\n   * @desc Adds a leaf to the tree and re-calculates layers.\n   * @param {String|Buffer} - Leaf\n   * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaf(newLeaf)\n   *```\n   */\n  addLeaf(leaf) {\n    let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (shouldHash) {\n      leaf = this.hashFn(leaf);\n    }\n    this.processLeaves(this.leaves.concat(leaf));\n  }\n  /**\n   * addLeaves\n   * @desc Adds multiple leaves to the tree and re-calculates layers.\n   * @param {String[]|Buffer[]} - Array of leaves\n   * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaves(newLeaves)\n   *```\n   */\n  addLeaves(leaves) {\n    let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (shouldHash) {\n      leaves = leaves.map(this.hashFn);\n    }\n    this.processLeaves(this.leaves.concat(leaves));\n  }\n  /**\n   * getLeaves\n   * @desc Returns array of leaves of Merkle Tree.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *```\n   */\n  getLeaves(values) {\n    if (Array.isArray(values)) {\n      if (this.hashLeaves) {\n        values = values.map(this.hashFn);\n        if (this.sortLeaves) {\n          values = values.sort(buffer_1.Buffer.compare);\n        }\n      }\n      return this.leaves.filter(leaf => this.bufferIndexOf(values, leaf, this.sortLeaves) !== -1);\n    }\n    return this.leaves;\n  }\n  /**\n   * getLeaf\n   * @desc Returns the leaf at the given index.\n   * @param {Number} - Index number\n   * @return {Buffer}\n   * @example\n   *```js\n   *const leaf = tree.getLeaf(1)\n   *```\n   */\n  getLeaf(index) {\n    if (index < 0 || index > this.leaves.length - 1) {\n      return buffer_1.Buffer.from([]);\n    }\n    return this.leaves[index];\n  }\n  /**\n   * getLeafIndex\n   * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n   * @param {String|Buffer} - Target leaf\n   * @return {number}\n   * @example\n   *```js\n   *const leaf = Buffer.from('abc')\n   *const index = tree.getLeafIndex(leaf)\n   *```\n   */\n  getLeafIndex(target) {\n    target = this.bufferify(target);\n    const leaves = this.getLeaves();\n    for (let i = 0; i < leaves.length; i++) {\n      const leaf = leaves[i];\n      if (leaf.equals(target)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /**\n   * getLeafCount\n   * @desc Returns the total number of leaves.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLeafCount()\n   *```\n   */\n  getLeafCount() {\n    return this.leaves.length;\n  }\n  /**\n   * getHexLeaves\n   * @desc Returns array of leaves of Merkle Tree as hex strings.\n   * @return {String[]}\n   * @example\n   *```js\n   *const leaves = tree.getHexLeaves()\n   *```\n   */\n  getHexLeaves() {\n    return this.leaves.map(leaf => this.bufferToHex(leaf));\n  }\n  /**\n   * marshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a JSON string.\n   * @param {String[]|Buffer[]} - Merkle tree leaves\n   * @return {String} - List of leaves as JSON string\n   * @example\n   *```js\n   *const jsonStr = MerkleTree.marshalLeaves(leaves)\n   *```\n   */\n  static marshalLeaves(leaves) {\n    return JSON.stringify(leaves.map(leaf => MerkleTree.bufferToHex(leaf)), null, 2);\n  }\n  /**\n   * unmarshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a Buffers.\n   * @param {String|Object} - JSON stringified leaves\n   * @return {Buffer[]} - Unmarshalled list of leaves\n   * @example\n   *```js\n   *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n   *```\n   */\n  static unmarshalLeaves(jsonStr) {\n    let parsed = null;\n    if (typeof jsonStr === 'string') {\n      parsed = JSON.parse(jsonStr);\n    } else if (jsonStr instanceof Object) {\n      parsed = jsonStr;\n    } else {\n      throw new Error('Expected type of string or object');\n    }\n    if (!parsed) {\n      return [];\n    }\n    if (!Array.isArray(parsed)) {\n      throw new Error('Expected JSON string to be array');\n    }\n    return parsed.map(MerkleTree.bufferify);\n  }\n  /**\n   * getLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const layers = tree.getLayers()\n   *```\n   */\n  getLayers() {\n    return this.layers;\n  }\n  /**\n   * getHexLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n   * @return {String[]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayers()\n   *```\n   */\n  getHexLayers() {\n    return this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.push(item.map(layer => this.bufferToHex(layer)));\n      } else {\n        acc.push(item);\n      }\n      return acc;\n    }, []);\n  }\n  /**\n   * getLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const layers = tree.getLayersFlat()\n   *```\n   */\n  getLayersFlat() {\n    const layers = this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.unshift(...item);\n      } else {\n        acc.unshift(item);\n      }\n      return acc;\n    }, []);\n    layers.unshift(buffer_1.Buffer.from([0]));\n    return layers;\n  }\n  /**\n   * getHexLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n   * @return {String[]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayersFlat()\n   *```\n   */\n  getHexLayersFlat() {\n    return this.getLayersFlat().map(layer => this.bufferToHex(layer));\n  }\n  /**\n   * getLayerCount\n   * @desc Returns the total number of layers.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLayerCount()\n   *```\n   */\n  getLayerCount() {\n    return this.getLayers().length;\n  }\n  /**\n   * getRoot\n   * @desc Returns the Merkle root hash as a Buffer.\n   * @return {Buffer}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *```\n   */\n  getRoot() {\n    if (this.layers.length === 0) {\n      return buffer_1.Buffer.from([]);\n    }\n    return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);\n  }\n  /**\n   * getHexRoot\n   * @desc Returns the Merkle root hash as a hex string.\n   * @return {String}\n   * @example\n   *```js\n   *const root = tree.getHexRoot()\n   *```\n   */\n  getHexRoot() {\n    return this.bufferToHex(this.getRoot());\n  }\n  /**\n   * getProof\n   * @desc Returns the proof for a target leaf.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer.\n   * @example\n   * ```js\n   *const proof = tree.getProof(leaves[2])\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proof = tree.getProof(leaves[2], 2)\n   *```\n   */\n  getProof(leaf, index) {\n    if (typeof leaf === 'undefined') {\n      throw new Error('leaf is required');\n    }\n    leaf = this.bufferify(leaf);\n    const proof = [];\n    if (!Number.isInteger(index)) {\n      index = -1;\n      for (let i = 0; i < this.leaves.length; i++) {\n        if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {\n          index = i;\n        }\n      }\n    }\n    if (index <= -1) {\n      return [];\n    }\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1\n      // Proof Generation for Bitcoin Trees\n      ? index\n      // Proof Generation for Non-Bitcoin Trees\n      : index + 1;\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? 'left' : 'right',\n          data: layer[pairIndex]\n        });\n      }\n      // set index to parent index\n      index = index / 2 | 0;\n    }\n    return proof;\n  }\n  /**\n   * getHexProof\n   * @desc Returns the proof for a target leaf as hex strings.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {String[]} - Proof array as hex strings.\n   * @example\n   * ```js\n   *const proof = tree.getHexProof(leaves[2])\n   *```\n   */\n  getHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => this.bufferToHex(item.data));\n  }\n  /**\n   * getProofs\n   * @desc Returns the proofs for all leaves.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer for all leaves.\n   * @example\n   * ```js\n   *const proofs = tree.getProofs()\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proofs = tree.getProofs()\n   *```\n   */\n  getProofs() {\n    const proof = [];\n    const proofs = [];\n    this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);\n    return proofs;\n  }\n  /**\n   * getProofsDFS\n   * @desc Get all proofs through single traverse\n   * @param {Number} currentLayer - Current layer index in traverse.\n   * @param {Number} index - Current tarvese node index in traverse.\n   * @param {Object[]} proof - Proof chain for single leaf.\n   * @param {Object[]} proofs - Proofs for all leaves\n   * @example\n   * ```js\n   *const layers = tree.getLayers()\n   *const index = 0;\n   *let proof = [];\n   *let proofs = [];\n   *const proof = tree.getProofsDFS(layers, index, proof, proofs)\n   *```\n   */\n  getProofsDFS(currentLayer, index, proof, proofs) {\n    const isRightNode = index % 2;\n    if (currentLayer === -1) {\n      if (!isRightNode) proofs.push([...proof].reverse());\n      return;\n    }\n    if (index >= this.layers[currentLayer].length) return;\n    const layer = this.layers[currentLayer];\n    const pairIndex = isRightNode ? index - 1 : index + 1;\n    let pushed = false;\n    if (pairIndex < layer.length) {\n      pushed = true;\n      proof.push({\n        position: isRightNode ? 'left' : 'right',\n        data: layer[pairIndex]\n      });\n    }\n    const leftchildIndex = index * 2;\n    const rightchildIndex = index * 2 + 1;\n    this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);\n    this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);\n    if (pushed) proof.splice(proof.length - 1, 1);\n  }\n  /**\n   * getHexProofs\n   * @desc Returns the proofs for all leaves as hex strings.\n   * @return {String[]} - Proofs array as hex strings.\n   * @example\n   * ```js\n   *const proofs = tree.getHexProofs()\n   *```\n   */\n  getHexProofs() {\n    return this.getProofs().map(item => this.bufferToHex(item.data));\n  }\n  /**\n  * getPositionalHexProof\n  * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n  * @param {Buffer} leaf - Target leaf\n  * @param {Number} [index] - Target leaf index in leaves array.\n  * Use if there are leaves containing duplicate data in order to distinguish it.\n  * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n  * @example\n  * ```js\n  *const proof = tree.getPositionalHexProof(leaves[2])\n  *```\n  */\n  getPositionalHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => {\n      return [item.position === 'left' ? 0 : 1, this.bufferToHex(item.data)];\n    });\n  }\n  /**\n   * marshalProof\n   * @desc Returns proof array as JSON string.\n   * @param {String[]|Object[]} proof - Merkle tree proof array\n   * @return {String} - Proof array as JSON string.\n   * @example\n   * ```js\n   *const jsonStr = MerkleTree.marshalProof(proof)\n   *```\n   */\n  static marshalProof(proof) {\n    const json = proof.map(item => {\n      if (typeof item === 'string') {\n        return item;\n      }\n      if (buffer_1.Buffer.isBuffer(item)) {\n        return MerkleTree.bufferToHex(item);\n      }\n      return {\n        position: item.position,\n        data: MerkleTree.bufferToHex(item.data)\n      };\n    });\n    return JSON.stringify(json, null, 2);\n  }\n  /**\n   * unmarshalProof\n   * @desc Returns the proof for a target leaf as a list of Buffers.\n   * @param {String|Object} - Merkle tree leaves\n   * @return {String|Object} - Marshalled proof\n   * @example\n   * ```js\n   *const proof = MerkleTree.unmarshalProof(jsonStr)\n   *```\n   */\n  static unmarshalProof(jsonStr) {\n    let parsed = null;\n    if (typeof jsonStr === 'string') {\n      parsed = JSON.parse(jsonStr);\n    } else if (jsonStr instanceof Object) {\n      parsed = jsonStr;\n    } else {\n      throw new Error('Expected type of string or object');\n    }\n    if (!parsed) {\n      return [];\n    }\n    if (!Array.isArray(parsed)) {\n      throw new Error('Expected JSON string to be array');\n    }\n    return parsed.map(item => {\n      if (typeof item === 'string') {\n        return MerkleTree.bufferify(item);\n      } else if (item instanceof Object) {\n        return {\n          position: item.position,\n          data: MerkleTree.bufferify(item.data)\n        };\n      } else {\n        throw new Error('Expected item to be of type string or object');\n      }\n    });\n  }\n  static marshalTree(tree) {\n    const root = tree.getHexRoot();\n    const leaves = tree.leaves.map(leaf => MerkleTree.bufferToHex(leaf));\n    const layers = tree.getHexLayers();\n    const options = tree.getOptions();\n    return JSON.stringify({\n      options,\n      root,\n      layers,\n      leaves\n    }, null, 2);\n  }\n  static unmarshalTree(jsonStr) {\n    let hashFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256_1.default;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let parsed = null;\n    if (typeof jsonStr === 'string') {\n      parsed = JSON.parse(jsonStr);\n    } else if (jsonStr instanceof Object) {\n      parsed = jsonStr;\n    } else {\n      throw new Error('Expected type of string or object');\n    }\n    if (!parsed) {\n      throw new Error('could not parse json');\n    }\n    options = Object.assign({}, parsed.options || {}, options);\n    return new MerkleTree(parsed.leaves, hashFn, options);\n  }\n  /**\n   * getProofIndices\n   * @desc Returns the proof indices for given tree indices.\n   * @param {Number[]} treeIndices - Tree indices\n   * @param {Number} depth - Tree depth; number of layers.\n   * @return {Number[]} - Proof indices\n   * @example\n   * ```js\n   *const proofIndices = tree.getProofIndices([2,5,6], 4)\n   *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n   *```\n   */\n  getProofIndices(treeIndices, depth) {\n    const leafCount = Math.pow(2, depth);\n    let maximalIndices = new Set();\n    for (const index of treeIndices) {\n      let x = leafCount + index;\n      while (x > 1) {\n        maximalIndices.add(x ^ 1);\n        x = x / 2 | 0;\n      }\n    }\n    const a = treeIndices.map(index => leafCount + index);\n    const b = Array.from(maximalIndices).sort((a, b) => a - b).reverse();\n    maximalIndices = a.concat(b);\n    const redundantIndices = new Set();\n    const proof = [];\n    for (let index of maximalIndices) {\n      if (!redundantIndices.has(index)) {\n        proof.push(index);\n        while (index > 1) {\n          redundantIndices.add(index);\n          if (!redundantIndices.has(index ^ 1)) break;\n          index = index / 2 | 0;\n        }\n      }\n    }\n    return proof.filter(index => {\n      return !treeIndices.includes(index - leafCount);\n    });\n  }\n  getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n    const depth = Math.ceil(Math.log2(leavesCount));\n    const unevenLayers = [];\n    for (let index = 0; index < depth; index++) {\n      const unevenLayer = leavesCount % 2 !== 0;\n      if (unevenLayer) {\n        unevenLayers.push({\n          index,\n          leavesCount\n        });\n      }\n      leavesCount = Math.ceil(leavesCount / 2);\n    }\n    const proofIndices = [];\n    let layerNodes = sortedLeafIndices;\n    for (let layerIndex = 0; layerIndex < depth; layerIndex++) {\n      const siblingIndices = layerNodes.map(index => {\n        if (index % 2 === 0) {\n          return index + 1;\n        }\n        return index - 1;\n      });\n      let proofNodeIndices = siblingIndices.filter(index => !layerNodes.includes(index));\n      const unevenLayer = unevenLayers.find(_ref => {\n        let {\n          index\n        } = _ref;\n        return index === layerIndex;\n      });\n      if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n        proofNodeIndices = proofNodeIndices.slice(0, -1);\n      }\n      proofIndices.push(proofNodeIndices);\n      layerNodes = [...new Set(layerNodes.map(index => {\n        if (index % 2 === 0) {\n          return index / 2;\n        }\n        if (index % 2 === 0) {\n          return (index + 1) / 2;\n        }\n        return (index - 1) / 2;\n      }))];\n    }\n    return proofIndices;\n  }\n  /**\n   * getMultiProof\n   * @desc Returns the multiproof for given tree indices.\n   * @param {Number[]} indices - Tree indices.\n   * @return {Buffer[]} - Multiproofs\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *```\n   */\n  getMultiProof(tree, indices) {\n    if (!this.complete) {\n      console.warn('Warning: For correct multiProofs it\\'s strongly recommended to set complete: true');\n    }\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayersFlat();\n    }\n    const isUneven = this.isUnevenTree();\n    if (isUneven) {\n      if (indices.every(Number.isInteger)) {\n        return this.getMultiProofForUnevenTree(indices);\n      }\n    }\n    if (!indices.every(Number.isInteger)) {\n      let els = indices;\n      if (this.sortPairs) {\n        els = els.sort(buffer_1.Buffer.compare);\n      }\n      let ids = els.map(el => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n      if (!ids.every(idx => idx !== -1)) {\n        throw new Error('Element does not exist in Merkle tree');\n      }\n      const hashes = [];\n      const proof = [];\n      let nextIds = [];\n      for (let i = 0; i < this.layers.length; i++) {\n        const layer = this.layers[i];\n        for (let j = 0; j < ids.length; j++) {\n          const idx = ids[j];\n          const pairElement = this.getPairNode(layer, idx);\n          hashes.push(layer[idx]);\n          if (pairElement) {\n            proof.push(pairElement);\n          }\n          nextIds.push(idx / 2 | 0);\n        }\n        ids = nextIds.filter((value, i, self) => self.indexOf(value) === i);\n        nextIds = [];\n      }\n      return proof.filter(value => !hashes.includes(value));\n    }\n    return this.getProofIndices(indices, Math.log2(tree.length / 2 | 0)).map(index => tree[index]);\n  }\n  getMultiProofForUnevenTree(tree, indices) {\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayers();\n    }\n    let proofHashes = [];\n    let currentLayerIndices = indices;\n    for (const treeLayer of tree) {\n      const siblings = [];\n      for (const index of currentLayerIndices) {\n        if (index % 2 === 0) {\n          const idx = index + 1;\n          if (!currentLayerIndices.includes(idx)) {\n            if (treeLayer[idx]) {\n              siblings.push(treeLayer[idx]);\n              continue;\n            }\n          }\n        }\n        const idx = index - 1;\n        if (!currentLayerIndices.includes(idx)) {\n          if (treeLayer[idx]) {\n            siblings.push(treeLayer[idx]);\n            continue;\n          }\n        }\n      }\n      proofHashes = proofHashes.concat(siblings);\n      const uniqueIndices = new Set();\n      for (const index of currentLayerIndices) {\n        if (index % 2 === 0) {\n          uniqueIndices.add(index / 2);\n          continue;\n        }\n        if (index % 2 === 0) {\n          uniqueIndices.add((index + 1) / 2);\n          continue;\n        }\n        uniqueIndices.add((index - 1) / 2);\n      }\n      currentLayerIndices = Array.from(uniqueIndices);\n    }\n    return proofHashes;\n  }\n  /**\n   * getHexMultiProof\n   * @desc Returns the multiproof for given tree indices as hex strings.\n   * @param {Number[]} indices - Tree indices.\n   * @return {String[]} - Multiproofs as hex strings.\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getHexMultiProof(indices)\n   *```\n   */\n  getHexMultiProof(tree, indices) {\n    return this.getMultiProof(tree, indices).map(x => this.bufferToHex(x));\n  }\n  /**\n   * getProofFlags\n   * @desc Returns list of booleans where proofs should be used instead of hashing.\n   * Proof flags are used in the Solidity multiproof verifiers.\n   * @param {Number[]|Buffer[]} leaves\n   * @param {Buffer[]} proofs\n   * @return {Boolean[]} - Boolean flags\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *const proofFlags = tree.getProofFlags(leaves, proof)\n   *```\n   */\n  getProofFlags(leaves, proofs) {\n    if (!Array.isArray(leaves) || leaves.length <= 0) {\n      throw new Error('Invalid Inputs!');\n    }\n    let ids;\n    if (leaves.every(Number.isInteger)) {\n      ids = [...leaves].sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n    } else {\n      ids = leaves.map(el => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n    }\n    if (!ids.every(idx => idx !== -1)) {\n      throw new Error('Element does not exist in Merkle tree');\n    }\n    const _proofs = proofs.map(item => this.bufferify(item));\n    const tested = [];\n    const flags = [];\n    for (let index = 0; index < this.layers.length; index++) {\n      const layer = this.layers[index];\n      ids = ids.reduce((ids, idx) => {\n        const skipped = tested.includes(layer[idx]);\n        if (!skipped) {\n          const pairElement = this.getPairNode(layer, idx);\n          const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n          pairElement && flags.push(!proofUsed);\n          tested.push(layer[idx]);\n          tested.push(pairElement);\n        }\n        ids.push(idx / 2 | 0);\n        return ids;\n      }, []);\n    }\n    return flags;\n  }\n  /**\n   * verify\n   * @desc Returns true if the proof path (array of hashes) can connect the target node\n   * to the Merkle root.\n   * @param {Object[]} proof - Array of proof objects that should connect\n   * target node to Merkle root.\n   * @param {Buffer} targetNode - Target node Buffer\n   * @param {Buffer} root - Merkle root Buffer\n   * @return {Boolean}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *const proof = tree.getProof(leaves[2])\n   *const verified = tree.verify(proof, leaves[2], root)\n   *```\n   */\n  verify(proof, targetNode, root) {\n    let hash = this.bufferify(targetNode);\n    root = this.bufferify(root);\n    if (!Array.isArray(proof) || !targetNode || !root) {\n      return false;\n    }\n    for (let i = 0; i < proof.length; i++) {\n      const node = proof[i];\n      let data = null;\n      let isLeftNode = null;\n      // case for when proof is hex values only\n      if (typeof node === 'string') {\n        data = this.bufferify(node);\n        isLeftNode = true;\n      } else if (Array.isArray(node)) {\n        isLeftNode = node[0] === 0;\n        data = this.bufferify(node[1]);\n      } else if (buffer_1.Buffer.isBuffer(node)) {\n        data = node;\n        isLeftNode = true;\n      } else if (node instanceof Object) {\n        data = this.bufferify(node.data);\n        isLeftNode = node.position === 'left';\n      } else {\n        throw new Error('Expected node to be of type string or object');\n      }\n      const buffers = [];\n      if (this.isBitcoinTree) {\n        buffers.push(buffer_reverse_1.default(hash));\n        buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n        hash = this.hashFn(this.concatenator(buffers));\n        hash = buffer_reverse_1.default(this.hashFn(hash));\n      } else {\n        if (this.sortPairs) {\n          if (buffer_1.Buffer.compare(hash, data) === -1) {\n            buffers.push(hash, data);\n            hash = this.hashFn(this.concatenator(buffers));\n          } else {\n            buffers.push(data, hash);\n            hash = this.hashFn(this.concatenator(buffers));\n          }\n        } else {\n          buffers.push(hash);\n          buffers[isLeftNode ? 'unshift' : 'push'](data);\n          hash = this.hashFn(this.concatenator(buffers));\n        }\n      }\n    }\n    return buffer_1.Buffer.compare(hash, root) === 0;\n  }\n  /**\n   * verifyMultiProof\n   * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n   * @param {Buffer} root - Merkle tree root\n   * @param {Number[]} proofIndices - Leave indices for proof\n   * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n   * @param {Number} leavesCount - Count of original leaves\n   * @param {Buffer[]} proof - Multiproofs given indices\n   * @return {Boolean}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *const root = tree.getRoot()\n   *const treeFlat = tree.getLayersFlat()\n   *const leavesCount = leaves.length\n   *const proofIndices = [2, 5, 6]\n   *const proofLeaves = proofIndices.map(i => leaves[i])\n   *const proof = tree.getMultiProof(treeFlat, indices)\n   *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n   *```\n   */\n  verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n    const isUneven = this.isUnevenTree();\n    if (isUneven) {\n      // TODO: combine these functions and simplify\n      return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n    }\n    const depth = Math.ceil(Math.log2(leavesCount));\n    root = this.bufferify(root);\n    proofLeaves = proofLeaves.map(leaf => this.bufferify(leaf));\n    proof = proof.map(leaf => this.bufferify(leaf));\n    const tree = {};\n    for (const [index, leaf] of this.zip(proofIndices, proofLeaves)) {\n      tree[Math.pow(2, depth) + index] = leaf;\n    }\n    for (const [index, proofitem] of this.zip(this.getProofIndices(proofIndices, depth), proof)) {\n      tree[index] = proofitem;\n    }\n    let indexqueue = Object.keys(tree).map(value => +value).sort((a, b) => a - b);\n    indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n    let i = 0;\n    while (i < indexqueue.length) {\n      const index = indexqueue[i];\n      if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {\n        let pair = [tree[index - index % 2], tree[index - index % 2 + 1]];\n        if (this.sortPairs) {\n          pair = pair.sort(buffer_1.Buffer.compare);\n        }\n        const hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];\n        tree[index / 2 | 0] = hash;\n        indexqueue.push(index / 2 | 0);\n      }\n      i += 1;\n    }\n    return !proofIndices.length || {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);\n  }\n  verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n    root = this.bufferify(root);\n    leaves = leaves.map(this.bufferify);\n    proofs = proofs.map(this.bufferify);\n    const leavesLen = leaves.length;\n    const totalHashes = proofFlag.length;\n    const hashes = [];\n    let leafPos = 0;\n    let hashPos = 0;\n    let proofPos = 0;\n    for (let i = 0; i < totalHashes; i++) {\n      const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];\n      const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n      const buffers = [bufA, bufB].sort(buffer_1.Buffer.compare);\n      hashes[i] = this.hashFn(this.concatenator(buffers));\n    }\n    return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;\n  }\n  verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n    root = this.bufferify(root);\n    leaves = leaves.map(leaf => this.bufferify(leaf));\n    proof = proof.map(leaf => this.bufferify(leaf));\n    const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n    return root.equals(computedRoot);\n  }\n  /**\n   * getDepth\n   * @desc Returns the tree depth (number of layers)\n   * @return {Number}\n   * @example\n   *```js\n   *const depth = tree.getDepth()\n   *```\n   */\n  getDepth() {\n    return this.getLayers().length - 1;\n  }\n  /**\n   * getLayersAsObject\n   * @desc Returns the layers as nested objects instead of an array.\n   * @example\n   *```js\n   *const layersObj = tree.getLayersAsObject()\n   *```\n   */\n  getLayersAsObject() {\n    const layers = this.getLayers().map(layer => layer.map(value => this.bufferToHex(value, false)));\n    const objs = [];\n    for (let i = 0; i < layers.length; i++) {\n      const arr = [];\n      for (let j = 0; j < layers[i].length; j++) {\n        const obj = {\n          [layers[i][j]]: null\n        };\n        if (objs.length) {\n          obj[layers[i][j]] = {};\n          const a = objs.shift();\n          const akey = Object.keys(a)[0];\n          obj[layers[i][j]][akey] = a[akey];\n          if (objs.length) {\n            const b = objs.shift();\n            const bkey = Object.keys(b)[0];\n            obj[layers[i][j]][bkey] = b[bkey];\n          }\n        }\n        arr.push(obj);\n      }\n      objs.push(...arr);\n    }\n    return objs[0];\n  }\n  /**\n   * verify\n   * @desc Returns true if the proof path (array of hashes) can connect the target node\n   * to the Merkle root.\n   * @param {Object[]} proof - Array of proof objects that should connect\n   * target node to Merkle root.\n   * @param {Buffer} targetNode - Target node Buffer\n   * @param {Buffer} root - Merkle root Buffer\n   * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @return {Boolean}\n   * @example\n   *```js\n   *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n   *```\n   */\n  static verify(proof, targetNode, root) {\n    let hashFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sha256_1.default;\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    const tree = new MerkleTree([], hashFn, options);\n    return tree.verify(proof, targetNode, root);\n  }\n  /**\n   * getMultiProof\n   * @desc Returns the multiproof for given tree indices.\n   * @param {Buffer[]} tree - Tree as a flat array.\n   * @param {Number[]} indices - Tree indices.\n   * @return {Buffer[]} - Multiproofs\n   *\n   *@example\n   * ```js\n   *const flatTree = tree.getLayersFlat()\n   *const indices = [2, 5, 6]\n   *const proof = MerkleTree.getMultiProof(flatTree, indices)\n   *```\n   */\n  static getMultiProof(tree, indices) {\n    const t = new MerkleTree([]);\n    return t.getMultiProof(tree, indices);\n  }\n  /**\n   * resetTree\n   * @desc Resets the tree by clearing the leaves and layers.\n   * @example\n   *```js\n   *tree.resetTree()\n   *```\n   */\n  resetTree() {\n    this.leaves = [];\n    this.layers = [];\n  }\n  /**\n   * getPairNode\n   * @desc Returns the node at the index for given layer.\n   * @param {Buffer[]} layer - Tree layer\n   * @param {Number} index - Index at layer.\n   * @return {Buffer} - Node\n   *\n   *@example\n   * ```js\n   *const node = tree.getPairNode(layer, index)\n   *```\n   */\n  getPairNode(layer, idx) {\n    const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n    if (pairIdx < layer.length) {\n      return layer[pairIdx];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * toTreeString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @return {String}\n   * @example\n   *```js\n   *console.log(tree.toTreeString())\n   *```\n   */\n  toTreeString() {\n    const obj = this.getLayersAsObject();\n    return treeify_1.default.asTree(obj, true);\n  }\n  /**\n   * toString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @example\n   *```js\n   *console.log(tree.toString())\n   *```\n   */\n  toString() {\n    return this.toTreeString();\n  }\n  isUnevenTree(treeLayers) {\n    const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();\n    return !this.isPowOf2(depth);\n  }\n  isPowOf2(v) {\n    return v && !(v & v - 1);\n  }\n  calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n    const leafTuples = this.zip(leafIndices, leafHashes).sort((_ref2, _ref3) => {\n      let [indexA] = _ref2;\n      let [indexB] = _ref3;\n      return indexA - indexB;\n    });\n    const leafTupleIndices = leafTuples.map(_ref4 => {\n      let [index] = _ref4;\n      return index;\n    });\n    const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n    let nextSliceStart = 0;\n    const proofTuplesByLayers = [];\n    for (let i = 0; i < proofIndices.length; i++) {\n      const indices = proofIndices[i];\n      const sliceStart = nextSliceStart;\n      nextSliceStart += indices.length;\n      proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n    }\n    const tree = [leafTuples];\n    for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n      const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort((_ref5, _ref6) => {\n        let [indexA] = _ref5;\n        let [indexB] = _ref6;\n        return indexA - indexB;\n      }).map(_ref7 => {\n        let [, hash] = _ref7;\n        return hash;\n      });\n      const s = tree[layerIndex].map(_ref8 => {\n        let [layerIndex] = _ref8;\n        return layerIndex;\n      });\n      const parentIndices = [...new Set(s.map(index => {\n        if (index % 2 === 0) {\n          return index / 2;\n        }\n        if (index % 2 === 0) {\n          return (index + 1) / 2;\n        }\n        return (index - 1) / 2;\n      }))];\n      const parentLayer = [];\n      for (let i = 0; i < parentIndices.length; i++) {\n        const parentNodeTreeIndex = parentIndices[i];\n        const bufA = currentLayer[i * 2];\n        const bufB = currentLayer[i * 2 + 1];\n        const hash = bufB ? this.hashFn(this.concatenator([bufA, bufB])) : bufA;\n        parentLayer.push([parentNodeTreeIndex, hash]);\n      }\n      tree.push(parentLayer);\n    }\n    return tree[tree.length - 1][0][1];\n  }\n}\nexports.MerkleTree = MerkleTree;\nif (typeof window !== 'undefined') {\n  ;\n  window.MerkleTree = MerkleTree;\n}\nexports.default = MerkleTree;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MerkleTree","buffer_1","require","buffer_reverse_1","sha256_1","treeify_1","Base_1","default","constructor","leaves","hashFn","options","duplicateOdd","concatenator","Buffer","concat","hashLeaves","isBitcoinTree","layers","sortLeaves","sortPairs","sort","fillDefaultHash","complete","Error","isBuffer","idx","bufferifyFn","processLeaves","getOptions","_a","_b","toString","map","bufferify","compare","i","Math","pow","ceil","log2","length","push","createHashes","nodes","layerIndex","layerLimit","Number","isInteger","slice","data","hash","left","right","combined","addLeaf","leaf","shouldHash","addLeaves","getLeaves","values","Array","isArray","filter","bufferIndexOf","getLeaf","index","from","getLeafIndex","target","equals","getLeafCount","getHexLeaves","bufferToHex","marshalLeaves","JSON","stringify","unmarshalLeaves","jsonStr","parsed","parse","getLayers","getHexLayers","reduce","acc","item","layer","getLayersFlat","unshift","getHexLayersFlat","getLayerCount","getRoot","getHexRoot","getProof","proof","isRightNode","pairIndex","position","getHexProof","getProofs","proofs","getProofsDFS","currentLayer","reverse","pushed","leftchildIndex","rightchildIndex","splice","getHexProofs","getPositionalHexProof","marshalProof","json","unmarshalProof","marshalTree","tree","root","unmarshalTree","assign","getProofIndices","treeIndices","depth","leafCount","maximalIndices","Set","x","add","a","b","redundantIndices","has","includes","getProofIndicesForUnevenTree","sortedLeafIndices","leavesCount","unevenLayers","unevenLayer","proofIndices","layerNodes","siblingIndices","proofNodeIndices","find","getMultiProof","indices","console","warn","isUneven","isUnevenTree","every","getMultiProofForUnevenTree","els","ids","el","hashes","nextIds","j","pairElement","getPairNode","self","indexOf","proofHashes","currentLayerIndices","treeLayer","siblings","uniqueIndices","getHexMultiProof","getProofFlags","_proofs","tested","flags","skipped","proofUsed","verify","targetNode","node","isLeftNode","buffers","verifyMultiProof","proofLeaves","verifyMultiProofForUnevenTree","zip","proofitem","indexqueue","keys","hasOwnProperty","call","pair","verifyMultiProofWithFlags","proofFlag","leavesLen","totalHashes","leafPos","hashPos","proofPos","bufA","bufB","computedRoot","calculateRootForUnevenTree","getDepth","getLayersAsObject","objs","arr","obj","shift","akey","bkey","t","resetTree","pairIdx","toTreeString","asTree","treeLayers","isPowOf2","v","leafIndices","leafHashes","totalLeavesCount","leafTuples","indexA","indexB","leafTupleIndices","nextSliceStart","proofTuplesByLayers","sliceStart","s","parentIndices","parentLayer","parentNodeTreeIndex","window"],"sources":["/home/diep/freelance/interface/node_modules/merkletreejs/dist/MerkleTree.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleTree = void 0;\nconst buffer_1 = require(\"buffer\");\nconst buffer_reverse_1 = __importDefault(require(\"buffer-reverse\"));\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nconst treeify_1 = __importDefault(require(\"treeify\"));\nconst Base_1 = __importDefault(require(\"./Base\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nclass MerkleTree extends Base_1.default {\n    /**\n     * @desc Constructs a Merkle Tree.\n     * All nodes and leaves are stored as Buffers.\n     * Lonely leaf nodes are promoted to the next level up without being hashed again.\n     * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n     * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @example\n     *```js\n     *const MerkleTree = require('merkletreejs')\n     *const crypto = require('crypto')\n     *\n     *function sha256(data) {\n     *  // returns Buffer\n     *  return crypto.createHash('sha256').update(data).digest()\n     *}\n     *\n     *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n     *\n     *const tree = new MerkleTree(leaves, sha256)\n     *```\n     */\n    constructor(leaves, hashFn = sha256_1.default, options = {}) {\n        super();\n        this.duplicateOdd = false;\n        this.concatenator = buffer_1.Buffer.concat;\n        this.hashLeaves = false;\n        this.isBitcoinTree = false;\n        this.leaves = [];\n        this.layers = [];\n        this.sortLeaves = false;\n        this.sortPairs = false;\n        this.sort = false;\n        this.fillDefaultHash = null;\n        this.complete = false;\n        if (options.complete) {\n            if (options.isBitcoinTree) {\n                throw new Error('option \"complete\" is incompatible with \"isBitcoinTree\"');\n            }\n            if (options.duplicateOdd) {\n                throw new Error('option \"complete\" is incompatible with \"duplicateOdd\"');\n            }\n        }\n        this.isBitcoinTree = !!options.isBitcoinTree;\n        this.hashLeaves = !!options.hashLeaves;\n        this.sortLeaves = !!options.sortLeaves;\n        this.sortPairs = !!options.sortPairs;\n        this.complete = !!options.complete;\n        if (options.fillDefaultHash) {\n            if (typeof options.fillDefaultHash === 'function') {\n                this.fillDefaultHash = options.fillDefaultHash;\n            }\n            else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n                this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n            }\n            else {\n                throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n            }\n        }\n        this.sort = !!options.sort;\n        if (this.sort) {\n            this.sortLeaves = true;\n            this.sortPairs = true;\n        }\n        this.duplicateOdd = !!options.duplicateOdd;\n        if (options.concatenator) {\n            this.concatenator = options.concatenator;\n        }\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.processLeaves(leaves);\n    }\n    getOptions() {\n        var _a, _b;\n        return {\n            complete: this.complete,\n            isBitcoinTree: this.isBitcoinTree,\n            hashLeaves: this.hashLeaves,\n            sortLeaves: this.sortLeaves,\n            sortPairs: this.sortPairs,\n            sort: this.sort,\n            fillDefaultHash: (_b = (_a = this.fillDefaultHash) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null,\n            duplicateOdd: this.duplicateOdd\n        };\n    }\n    processLeaves(leaves) {\n        if (this.hashLeaves) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.leaves = leaves.map(this.bufferify);\n        if (this.sortLeaves) {\n            this.leaves = this.leaves.sort(buffer_1.Buffer.compare);\n        }\n        if (this.fillDefaultHash) {\n            for (let i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n                if (i >= this.leaves.length) {\n                    this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n                }\n            }\n        }\n        this.createHashes(this.leaves);\n    }\n    createHashes(nodes) {\n        this.layers = [nodes];\n        while (nodes.length > 1) {\n            const layerIndex = this.layers.length;\n            this.layers.push([]);\n            const layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length))\n                ? (2 * nodes.length) - (Math.pow(2, Math.ceil(Math.log2(nodes.length))))\n                : nodes.length;\n            for (let i = 0; i < nodes.length; i += 2) {\n                if (i >= layerLimit) {\n                    this.layers[layerIndex].push(...nodes.slice(layerLimit));\n                    break;\n                }\n                else if (i + 1 === nodes.length) {\n                    if (nodes.length % 2 === 1) {\n                        const data = nodes[nodes.length - 1];\n                        let hash = data;\n                        // is bitcoin tree\n                        if (this.isBitcoinTree) {\n                            // Bitcoin method of duplicating the odd ending nodes\n                            hash = this.hashFn(this.concatenator([buffer_reverse_1.default(data), buffer_reverse_1.default(data)]));\n                            hash = buffer_reverse_1.default(this.hashFn(hash));\n                            this.layers[layerIndex].push(hash);\n                            continue;\n                        }\n                        else {\n                            if (this.duplicateOdd) {\n                                // continue with creating layer\n                            }\n                            else {\n                                // push copy of hash and continue iteration\n                                this.layers[layerIndex].push(nodes[i]);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                const left = nodes[i];\n                const right = i + 1 === nodes.length ? left : nodes[i + 1];\n                let combined = null;\n                if (this.isBitcoinTree) {\n                    combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n                }\n                else {\n                    combined = [left, right];\n                }\n                if (this.sortPairs) {\n                    combined.sort(buffer_1.Buffer.compare);\n                }\n                let hash = this.hashFn(this.concatenator(combined));\n                // double hash if bitcoin tree\n                if (this.isBitcoinTree) {\n                    hash = buffer_reverse_1.default(this.hashFn(hash));\n                }\n                this.layers[layerIndex].push(hash);\n            }\n            nodes = this.layers[layerIndex];\n        }\n    }\n    /**\n     * addLeaf\n     * @desc Adds a leaf to the tree and re-calculates layers.\n     * @param {String|Buffer} - Leaf\n     * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaf(newLeaf)\n     *```\n     */\n    addLeaf(leaf, shouldHash = false) {\n        if (shouldHash) {\n            leaf = this.hashFn(leaf);\n        }\n        this.processLeaves(this.leaves.concat(leaf));\n    }\n    /**\n     * addLeaves\n     * @desc Adds multiple leaves to the tree and re-calculates layers.\n     * @param {String[]|Buffer[]} - Array of leaves\n     * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaves(newLeaves)\n     *```\n     */\n    addLeaves(leaves, shouldHash = false) {\n        if (shouldHash) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.processLeaves(this.leaves.concat(leaves));\n    }\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */\n    getLeaves(values) {\n        if (Array.isArray(values)) {\n            if (this.hashLeaves) {\n                values = values.map(this.hashFn);\n                if (this.sortLeaves) {\n                    values = values.sort(buffer_1.Buffer.compare);\n                }\n            }\n            return this.leaves.filter(leaf => this.bufferIndexOf(values, leaf, this.sortLeaves) !== -1);\n        }\n        return this.leaves;\n    }\n    /**\n     * getLeaf\n     * @desc Returns the leaf at the given index.\n     * @param {Number} - Index number\n     * @return {Buffer}\n     * @example\n     *```js\n     *const leaf = tree.getLeaf(1)\n     *```\n     */\n    getLeaf(index) {\n        if (index < 0 || index > this.leaves.length - 1) {\n            return buffer_1.Buffer.from([]);\n        }\n        return this.leaves[index];\n    }\n    /**\n     * getLeafIndex\n     * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n     * @param {String|Buffer} - Target leaf\n     * @return {number}\n     * @example\n     *```js\n     *const leaf = Buffer.from('abc')\n     *const index = tree.getLeafIndex(leaf)\n     *```\n     */\n    getLeafIndex(target) {\n        target = this.bufferify(target);\n        const leaves = this.getLeaves();\n        for (let i = 0; i < leaves.length; i++) {\n            const leaf = leaves[i];\n            if (leaf.equals(target)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * getLeafCount\n     * @desc Returns the total number of leaves.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLeafCount()\n     *```\n     */\n    getLeafCount() {\n        return this.leaves.length;\n    }\n    /**\n     * getHexLeaves\n     * @desc Returns array of leaves of Merkle Tree as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const leaves = tree.getHexLeaves()\n     *```\n     */\n    getHexLeaves() {\n        return this.leaves.map(leaf => this.bufferToHex(leaf));\n    }\n    /**\n     * marshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a JSON string.\n     * @param {String[]|Buffer[]} - Merkle tree leaves\n     * @return {String} - List of leaves as JSON string\n     * @example\n     *```js\n     *const jsonStr = MerkleTree.marshalLeaves(leaves)\n     *```\n     */\n    static marshalLeaves(leaves) {\n        return JSON.stringify(leaves.map(leaf => MerkleTree.bufferToHex(leaf)), null, 2);\n    }\n    /**\n     * unmarshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a Buffers.\n     * @param {String|Object} - JSON stringified leaves\n     * @return {Buffer[]} - Unmarshalled list of leaves\n     * @example\n     *```js\n     *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n     *```\n     */\n    static unmarshalLeaves(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(MerkleTree.bufferify);\n    }\n    /**\n     * getLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */\n    getLayers() {\n        return this.layers;\n    }\n    /**\n     * getHexLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayers()\n     *```\n     */\n    getHexLayers() {\n        return this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.push(item.map(layer => this.bufferToHex(layer)));\n            }\n            else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    /**\n     * getLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayersFlat()\n     *```\n     */\n    getLayersFlat() {\n        const layers = this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.unshift(...item);\n            }\n            else {\n                acc.unshift(item);\n            }\n            return acc;\n        }, []);\n        layers.unshift(buffer_1.Buffer.from([0]));\n        return layers;\n    }\n    /**\n     * getHexLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayersFlat()\n     *```\n     */\n    getHexLayersFlat() {\n        return this.getLayersFlat().map(layer => this.bufferToHex(layer));\n    }\n    /**\n     * getLayerCount\n     * @desc Returns the total number of layers.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLayerCount()\n     *```\n     */\n    getLayerCount() {\n        return this.getLayers().length;\n    }\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */\n    getRoot() {\n        if (this.layers.length === 0) {\n            return buffer_1.Buffer.from([]);\n        }\n        return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);\n    }\n    /**\n     * getHexRoot\n     * @desc Returns the Merkle root hash as a hex string.\n     * @return {String}\n     * @example\n     *```js\n     *const root = tree.getHexRoot()\n     *```\n     */\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     * @example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */\n    getProof(leaf, index) {\n        if (typeof leaf === 'undefined') {\n            throw new Error('leaf is required');\n        }\n        leaf = this.bufferify(leaf);\n        const proof = [];\n        if (!Number.isInteger(index)) {\n            index = -1;\n            for (let i = 0; i < this.leaves.length; i++) {\n                if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {\n                    index = i;\n                }\n            }\n        }\n        if (index <= -1) {\n            return [];\n        }\n        for (let i = 0; i < this.layers.length; i++) {\n            const layer = this.layers[i];\n            const isRightNode = index % 2;\n            const pairIndex = (isRightNode ? index - 1\n                : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1\n                    // Proof Generation for Bitcoin Trees\n                    ? index\n                    // Proof Generation for Non-Bitcoin Trees\n                    : index + 1);\n            if (pairIndex < layer.length) {\n                proof.push({\n                    position: isRightNode ? 'left' : 'right',\n                    data: layer[pairIndex]\n                });\n            }\n            // set index to parent index\n            index = (index / 2) | 0;\n        }\n        return proof;\n    }\n    /**\n     * getHexProof\n     * @desc Returns the proof for a target leaf as hex strings.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {String[]} - Proof array as hex strings.\n     * @example\n     * ```js\n     *const proof = tree.getHexProof(leaves[2])\n     *```\n     */\n    getHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(item => this.bufferToHex(item.data));\n    }\n    /**\n     * getProofs\n     * @desc Returns the proofs for all leaves.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer for all leaves.\n     * @example\n     * ```js\n     *const proofs = tree.getProofs()\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proofs = tree.getProofs()\n     *```\n     */\n    getProofs() {\n        const proof = [];\n        const proofs = [];\n        this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);\n        return proofs;\n    }\n    /**\n     * getProofsDFS\n     * @desc Get all proofs through single traverse\n     * @param {Number} currentLayer - Current layer index in traverse.\n     * @param {Number} index - Current tarvese node index in traverse.\n     * @param {Object[]} proof - Proof chain for single leaf.\n     * @param {Object[]} proofs - Proofs for all leaves\n     * @example\n     * ```js\n     *const layers = tree.getLayers()\n     *const index = 0;\n     *let proof = [];\n     *let proofs = [];\n     *const proof = tree.getProofsDFS(layers, index, proof, proofs)\n     *```\n     */\n    getProofsDFS(currentLayer, index, proof, proofs) {\n        const isRightNode = index % 2;\n        if (currentLayer === -1) {\n            if (!isRightNode)\n                proofs.push([...proof].reverse());\n            return;\n        }\n        if (index >= this.layers[currentLayer].length)\n            return;\n        const layer = this.layers[currentLayer];\n        const pairIndex = isRightNode ? index - 1 : index + 1;\n        let pushed = false;\n        if (pairIndex < layer.length) {\n            pushed = true;\n            proof.push({\n                position: isRightNode ? 'left' : 'right',\n                data: layer[pairIndex]\n            });\n        }\n        const leftchildIndex = index * 2;\n        const rightchildIndex = index * 2 + 1;\n        this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);\n        this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);\n        if (pushed)\n            proof.splice(proof.length - 1, 1);\n    }\n    /**\n     * getHexProofs\n     * @desc Returns the proofs for all leaves as hex strings.\n     * @return {String[]} - Proofs array as hex strings.\n     * @example\n     * ```js\n     *const proofs = tree.getHexProofs()\n     *```\n     */\n    getHexProofs() {\n        return this.getProofs().map(item => this.bufferToHex(item.data));\n    }\n    /**\n    * getPositionalHexProof\n    * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n    * @param {Buffer} leaf - Target leaf\n    * @param {Number} [index] - Target leaf index in leaves array.\n    * Use if there are leaves containing duplicate data in order to distinguish it.\n    * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n    * @example\n    * ```js\n    *const proof = tree.getPositionalHexProof(leaves[2])\n    *```\n    */\n    getPositionalHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(item => {\n            return [\n                item.position === 'left' ? 0 : 1,\n                this.bufferToHex(item.data)\n            ];\n        });\n    }\n    /**\n     * marshalProof\n     * @desc Returns proof array as JSON string.\n     * @param {String[]|Object[]} proof - Merkle tree proof array\n     * @return {String} - Proof array as JSON string.\n     * @example\n     * ```js\n     *const jsonStr = MerkleTree.marshalProof(proof)\n     *```\n     */\n    static marshalProof(proof) {\n        const json = proof.map(item => {\n            if (typeof item === 'string') {\n                return item;\n            }\n            if (buffer_1.Buffer.isBuffer(item)) {\n                return MerkleTree.bufferToHex(item);\n            }\n            return {\n                position: item.position,\n                data: MerkleTree.bufferToHex(item.data)\n            };\n        });\n        return JSON.stringify(json, null, 2);\n    }\n    /**\n     * unmarshalProof\n     * @desc Returns the proof for a target leaf as a list of Buffers.\n     * @param {String|Object} - Merkle tree leaves\n     * @return {String|Object} - Marshalled proof\n     * @example\n     * ```js\n     *const proof = MerkleTree.unmarshalProof(jsonStr)\n     *```\n     */\n    static unmarshalProof(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(item => {\n            if (typeof item === 'string') {\n                return MerkleTree.bufferify(item);\n            }\n            else if (item instanceof Object) {\n                return {\n                    position: item.position,\n                    data: MerkleTree.bufferify(item.data)\n                };\n            }\n            else {\n                throw new Error('Expected item to be of type string or object');\n            }\n        });\n    }\n    static marshalTree(tree) {\n        const root = tree.getHexRoot();\n        const leaves = tree.leaves.map(leaf => MerkleTree.bufferToHex(leaf));\n        const layers = tree.getHexLayers();\n        const options = tree.getOptions();\n        return JSON.stringify({\n            options,\n            root,\n            layers,\n            leaves\n        }, null, 2);\n    }\n    static unmarshalTree(jsonStr, hashFn = sha256_1.default, options = {}) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            throw new Error('could not parse json');\n        }\n        options = Object.assign({}, parsed.options || {}, options);\n        return new MerkleTree(parsed.leaves, hashFn, options);\n    }\n    /**\n     * getProofIndices\n     * @desc Returns the proof indices for given tree indices.\n     * @param {Number[]} treeIndices - Tree indices\n     * @param {Number} depth - Tree depth; number of layers.\n     * @return {Number[]} - Proof indices\n     * @example\n     * ```js\n     *const proofIndices = tree.getProofIndices([2,5,6], 4)\n     *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n     *```\n     */\n    getProofIndices(treeIndices, depth) {\n        const leafCount = Math.pow(2, depth);\n        let maximalIndices = new Set();\n        for (const index of treeIndices) {\n            let x = leafCount + index;\n            while (x > 1) {\n                maximalIndices.add(x ^ 1);\n                x = (x / 2) | 0;\n            }\n        }\n        const a = treeIndices.map(index => leafCount + index);\n        const b = Array.from(maximalIndices).sort((a, b) => a - b).reverse();\n        maximalIndices = a.concat(b);\n        const redundantIndices = new Set();\n        const proof = [];\n        for (let index of maximalIndices) {\n            if (!redundantIndices.has(index)) {\n                proof.push(index);\n                while (index > 1) {\n                    redundantIndices.add(index);\n                    if (!redundantIndices.has(index ^ 1))\n                        break;\n                    index = (index / 2) | 0;\n                }\n            }\n        }\n        return proof.filter(index => {\n            return !treeIndices.includes(index - leafCount);\n        });\n    }\n    getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n        const depth = Math.ceil(Math.log2(leavesCount));\n        const unevenLayers = [];\n        for (let index = 0; index < depth; index++) {\n            const unevenLayer = leavesCount % 2 !== 0;\n            if (unevenLayer) {\n                unevenLayers.push({ index, leavesCount });\n            }\n            leavesCount = Math.ceil(leavesCount / 2);\n        }\n        const proofIndices = [];\n        let layerNodes = sortedLeafIndices;\n        for (let layerIndex = 0; layerIndex < depth; layerIndex++) {\n            const siblingIndices = layerNodes.map((index) => {\n                if (index % 2 === 0) {\n                    return index + 1;\n                }\n                return index - 1;\n            });\n            let proofNodeIndices = siblingIndices.filter((index) => !layerNodes.includes(index));\n            const unevenLayer = unevenLayers.find(({ index }) => index === layerIndex);\n            if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n                proofNodeIndices = proofNodeIndices.slice(0, -1);\n            }\n            proofIndices.push(proofNodeIndices);\n            layerNodes = [...new Set(layerNodes.map((index) => {\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))];\n        }\n        return proofIndices;\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *```\n     */\n    getMultiProof(tree, indices) {\n        if (!this.complete) {\n            console.warn('Warning: For correct multiProofs it\\'s strongly recommended to set complete: true');\n        }\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayersFlat();\n        }\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            if (indices.every(Number.isInteger)) {\n                return this.getMultiProofForUnevenTree(indices);\n            }\n        }\n        if (!indices.every(Number.isInteger)) {\n            let els = indices;\n            if (this.sortPairs) {\n                els = els.sort(buffer_1.Buffer.compare);\n            }\n            let ids = els.map((el) => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n            if (!ids.every((idx) => idx !== -1)) {\n                throw new Error('Element does not exist in Merkle tree');\n            }\n            const hashes = [];\n            const proof = [];\n            let nextIds = [];\n            for (let i = 0; i < this.layers.length; i++) {\n                const layer = this.layers[i];\n                for (let j = 0; j < ids.length; j++) {\n                    const idx = ids[j];\n                    const pairElement = this.getPairNode(layer, idx);\n                    hashes.push(layer[idx]);\n                    if (pairElement) {\n                        proof.push(pairElement);\n                    }\n                    nextIds.push((idx / 2) | 0);\n                }\n                ids = nextIds.filter((value, i, self) => self.indexOf(value) === i);\n                nextIds = [];\n            }\n            return proof.filter((value) => !hashes.includes(value));\n        }\n        return this.getProofIndices(indices, Math.log2((tree.length / 2) | 0)).map(index => tree[index]);\n    }\n    getMultiProofForUnevenTree(tree, indices) {\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayers();\n        }\n        let proofHashes = [];\n        let currentLayerIndices = indices;\n        for (const treeLayer of tree) {\n            const siblings = [];\n            for (const index of currentLayerIndices) {\n                if (index % 2 === 0) {\n                    const idx = index + 1;\n                    if (!currentLayerIndices.includes(idx)) {\n                        if (treeLayer[idx]) {\n                            siblings.push(treeLayer[idx]);\n                            continue;\n                        }\n                    }\n                }\n                const idx = index - 1;\n                if (!currentLayerIndices.includes(idx)) {\n                    if (treeLayer[idx]) {\n                        siblings.push(treeLayer[idx]);\n                        continue;\n                    }\n                }\n            }\n            proofHashes = proofHashes.concat(siblings);\n            const uniqueIndices = new Set();\n            for (const index of currentLayerIndices) {\n                if (index % 2 === 0) {\n                    uniqueIndices.add(index / 2);\n                    continue;\n                }\n                if (index % 2 === 0) {\n                    uniqueIndices.add((index + 1) / 2);\n                    continue;\n                }\n                uniqueIndices.add((index - 1) / 2);\n            }\n            currentLayerIndices = Array.from(uniqueIndices);\n        }\n        return proofHashes;\n    }\n    /**\n     * getHexMultiProof\n     * @desc Returns the multiproof for given tree indices as hex strings.\n     * @param {Number[]} indices - Tree indices.\n     * @return {String[]} - Multiproofs as hex strings.\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getHexMultiProof(indices)\n     *```\n     */\n    getHexMultiProof(tree, indices) {\n        return this.getMultiProof(tree, indices).map((x) => this.bufferToHex(x));\n    }\n    /**\n     * getProofFlags\n     * @desc Returns list of booleans where proofs should be used instead of hashing.\n     * Proof flags are used in the Solidity multiproof verifiers.\n     * @param {Number[]|Buffer[]} leaves\n     * @param {Buffer[]} proofs\n     * @return {Boolean[]} - Boolean flags\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *const proofFlags = tree.getProofFlags(leaves, proof)\n     *```\n     */\n    getProofFlags(leaves, proofs) {\n        if (!Array.isArray(leaves) || leaves.length <= 0) {\n            throw new Error('Invalid Inputs!');\n        }\n        let ids;\n        if (leaves.every(Number.isInteger)) {\n            ids = [...leaves].sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n        }\n        else {\n            ids = leaves.map((el) => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n        }\n        if (!ids.every((idx) => idx !== -1)) {\n            throw new Error('Element does not exist in Merkle tree');\n        }\n        const _proofs = proofs.map(item => this.bufferify(item));\n        const tested = [];\n        const flags = [];\n        for (let index = 0; index < this.layers.length; index++) {\n            const layer = this.layers[index];\n            ids = ids.reduce((ids, idx) => {\n                const skipped = tested.includes(layer[idx]);\n                if (!skipped) {\n                    const pairElement = this.getPairNode(layer, idx);\n                    const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n                    pairElement && flags.push(!proofUsed);\n                    tested.push(layer[idx]);\n                    tested.push(pairElement);\n                }\n                ids.push((idx / 2) | 0);\n                return ids;\n            }, []);\n        }\n        return flags;\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */\n    verify(proof, targetNode, root) {\n        let hash = this.bufferify(targetNode);\n        root = this.bufferify(root);\n        if (!Array.isArray(proof) ||\n            !targetNode ||\n            !root) {\n            return false;\n        }\n        for (let i = 0; i < proof.length; i++) {\n            const node = proof[i];\n            let data = null;\n            let isLeftNode = null;\n            // case for when proof is hex values only\n            if (typeof node === 'string') {\n                data = this.bufferify(node);\n                isLeftNode = true;\n            }\n            else if (Array.isArray(node)) {\n                isLeftNode = (node[0] === 0);\n                data = this.bufferify(node[1]);\n            }\n            else if (buffer_1.Buffer.isBuffer(node)) {\n                data = node;\n                isLeftNode = true;\n            }\n            else if (node instanceof Object) {\n                data = this.bufferify(node.data);\n                isLeftNode = (node.position === 'left');\n            }\n            else {\n                throw new Error('Expected node to be of type string or object');\n            }\n            const buffers = [];\n            if (this.isBitcoinTree) {\n                buffers.push(buffer_reverse_1.default(hash));\n                buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n                hash = this.hashFn(this.concatenator(buffers));\n                hash = buffer_reverse_1.default(this.hashFn(hash));\n            }\n            else {\n                if (this.sortPairs) {\n                    if (buffer_1.Buffer.compare(hash, data) === -1) {\n                        buffers.push(hash, data);\n                        hash = this.hashFn(this.concatenator(buffers));\n                    }\n                    else {\n                        buffers.push(data, hash);\n                        hash = this.hashFn(this.concatenator(buffers));\n                    }\n                }\n                else {\n                    buffers.push(hash);\n                    buffers[isLeftNode ? 'unshift' : 'push'](data);\n                    hash = this.hashFn(this.concatenator(buffers));\n                }\n            }\n        }\n        return buffer_1.Buffer.compare(hash, root) === 0;\n    }\n    /**\n     * verifyMultiProof\n     * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n     * @param {Buffer} root - Merkle tree root\n     * @param {Number[]} proofIndices - Leave indices for proof\n     * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n     * @param {Number} leavesCount - Count of original leaves\n     * @param {Buffer[]} proof - Multiproofs given indices\n     * @return {Boolean}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *const root = tree.getRoot()\n     *const treeFlat = tree.getLayersFlat()\n     *const leavesCount = leaves.length\n     *const proofIndices = [2, 5, 6]\n     *const proofLeaves = proofIndices.map(i => leaves[i])\n     *const proof = tree.getMultiProof(treeFlat, indices)\n     *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n     *```\n     */\n    verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            // TODO: combine these functions and simplify\n            return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n        }\n        const depth = Math.ceil(Math.log2(leavesCount));\n        root = this.bufferify(root);\n        proofLeaves = proofLeaves.map(leaf => this.bufferify(leaf));\n        proof = proof.map(leaf => this.bufferify(leaf));\n        const tree = {};\n        for (const [index, leaf] of this.zip(proofIndices, proofLeaves)) {\n            tree[(Math.pow(2, depth)) + index] = leaf;\n        }\n        for (const [index, proofitem] of this.zip(this.getProofIndices(proofIndices, depth), proof)) {\n            tree[index] = proofitem;\n        }\n        let indexqueue = Object.keys(tree).map(value => +value).sort((a, b) => a - b);\n        indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n        let i = 0;\n        while (i < indexqueue.length) {\n            const index = indexqueue[i];\n            if (index >= 2 && ({}).hasOwnProperty.call(tree, index ^ 1)) {\n                let pair = [tree[index - (index % 2)], tree[index - (index % 2) + 1]];\n                if (this.sortPairs) {\n                    pair = pair.sort(buffer_1.Buffer.compare);\n                }\n                const hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];\n                tree[(index / 2) | 0] = hash;\n                indexqueue.push((index / 2) | 0);\n            }\n            i += 1;\n        }\n        return !proofIndices.length || (({}).hasOwnProperty.call(tree, 1) && tree[1].equals(root));\n    }\n    verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n        root = this.bufferify(root);\n        leaves = leaves.map(this.bufferify);\n        proofs = proofs.map(this.bufferify);\n        const leavesLen = leaves.length;\n        const totalHashes = proofFlag.length;\n        const hashes = [];\n        let leafPos = 0;\n        let hashPos = 0;\n        let proofPos = 0;\n        for (let i = 0; i < totalHashes; i++) {\n            const bufA = proofFlag[i] ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++]) : proofs[proofPos++];\n            const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            const buffers = [bufA, bufB].sort(buffer_1.Buffer.compare);\n            hashes[i] = this.hashFn(this.concatenator(buffers));\n        }\n        return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;\n    }\n    verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n        root = this.bufferify(root);\n        leaves = leaves.map(leaf => this.bufferify(leaf));\n        proof = proof.map(leaf => this.bufferify(leaf));\n        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n        return root.equals(computedRoot);\n    }\n    /**\n     * getDepth\n     * @desc Returns the tree depth (number of layers)\n     * @return {Number}\n     * @example\n     *```js\n     *const depth = tree.getDepth()\n     *```\n     */\n    getDepth() {\n        return this.getLayers().length - 1;\n    }\n    /**\n     * getLayersAsObject\n     * @desc Returns the layers as nested objects instead of an array.\n     * @example\n     *```js\n     *const layersObj = tree.getLayersAsObject()\n     *```\n     */\n    getLayersAsObject() {\n        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(value, false)));\n        const objs = [];\n        for (let i = 0; i < layers.length; i++) {\n            const arr = [];\n            for (let j = 0; j < layers[i].length; j++) {\n                const obj = { [layers[i][j]]: null };\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    const akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        const bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @return {Boolean}\n     * @example\n     *```js\n     *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n     *```\n     */\n    static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {\n        const tree = new MerkleTree([], hashFn, options);\n        return tree.verify(proof, targetNode, root);\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Buffer[]} tree - Tree as a flat array.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     *\n     *@example\n     * ```js\n     *const flatTree = tree.getLayersFlat()\n     *const indices = [2, 5, 6]\n     *const proof = MerkleTree.getMultiProof(flatTree, indices)\n     *```\n     */\n    static getMultiProof(tree, indices) {\n        const t = new MerkleTree([]);\n        return t.getMultiProof(tree, indices);\n    }\n    /**\n     * resetTree\n     * @desc Resets the tree by clearing the leaves and layers.\n     * @example\n     *```js\n     *tree.resetTree()\n     *```\n     */\n    resetTree() {\n        this.leaves = [];\n        this.layers = [];\n    }\n    /**\n     * getPairNode\n     * @desc Returns the node at the index for given layer.\n     * @param {Buffer[]} layer - Tree layer\n     * @param {Number} index - Index at layer.\n     * @return {Buffer} - Node\n     *\n     *@example\n     * ```js\n     *const node = tree.getPairNode(layer, index)\n     *```\n     */\n    getPairNode(layer, idx) {\n        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n        if (pairIdx < layer.length) {\n            return layer[pairIdx];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * toTreeString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @return {String}\n     * @example\n     *```js\n     *console.log(tree.toTreeString())\n     *```\n     */\n    toTreeString() {\n        const obj = this.getLayersAsObject();\n        return treeify_1.default.asTree(obj, true);\n    }\n    /**\n     * toString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @example\n     *```js\n     *console.log(tree.toString())\n     *```\n     */\n    toString() {\n        return this.toTreeString();\n    }\n    isUnevenTree(treeLayers) {\n        const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();\n        return !this.isPowOf2(depth);\n    }\n    isPowOf2(v) {\n        return v && !(v & (v - 1));\n    }\n    calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n        const leafTuples = this.zip(leafIndices, leafHashes).sort(([indexA], [indexB]) => indexA - indexB);\n        const leafTupleIndices = leafTuples.map(([index]) => index);\n        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n        let nextSliceStart = 0;\n        const proofTuplesByLayers = [];\n        for (let i = 0; i < proofIndices.length; i++) {\n            const indices = proofIndices[i];\n            const sliceStart = nextSliceStart;\n            nextSliceStart += indices.length;\n            proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n        }\n        const tree = [leafTuples];\n        for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n            const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(([indexA], [indexB]) => indexA - indexB)\n                .map(([, hash]) => hash);\n            const s = tree[layerIndex].map(([layerIndex]) => layerIndex);\n            const parentIndices = [...new Set(s.map((index) => {\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))];\n            const parentLayer = [];\n            for (let i = 0; i < parentIndices.length; i++) {\n                const parentNodeTreeIndex = parentIndices[i];\n                const bufA = currentLayer[i * 2];\n                const bufB = currentLayer[i * 2 + 1];\n                const hash = bufB ? this.hashFn(this.concatenator([bufA, bufB])) : bufA;\n                parentLayer.push([parentNodeTreeIndex, hash]);\n            }\n            tree.push(parentLayer);\n        }\n        return tree[tree.length - 1][0][1];\n    }\n}\nexports.MerkleTree = MerkleTree;\nif (typeof window !== 'undefined') {\n    ;\n    window.MerkleTree = MerkleTree;\n}\nexports.default = MerkleTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}