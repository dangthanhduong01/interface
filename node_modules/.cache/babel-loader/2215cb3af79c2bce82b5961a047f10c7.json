{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IncrementalMerkleTree = void 0;\nconst Base_1 = __importDefault(require(\"./Base\"));\nconst treeify_1 = __importDefault(require(\"treeify\"));\nclass IncrementalMerkleTree extends Base_1.default {\n  constructor(hashFn, options) {\n    super();\n    this.hashFn = hashFn;\n    if (options.depth) {\n      this.depth = options.depth;\n    }\n    if (options.arity) {\n      this.arity = options.arity;\n    }\n    if (this.depth < 1) {\n      throw new Error('depth must be greater than 0');\n    }\n    if (this.arity < 1) {\n      throw new Error('arity must be greater than 0');\n    }\n    const nodes = [];\n    let zeroValue = options.zeroValue;\n    this.zeroValue = zeroValue;\n    this.zeroes = [];\n    if (this.depth) {\n      for (let i = 0; i < this.depth; i++) {\n        this.zeroes.push(zeroValue);\n        nodes[i] = [];\n        zeroValue = this.hashFn(Array(this.arity).fill(zeroValue));\n      }\n    }\n    this.nodes = nodes;\n    this.root = zeroValue;\n  }\n  getRoot() {\n    return this.root;\n  }\n  getHexRoot() {\n    return this.bufferToHex(this.bufferify(this.getRoot()));\n  }\n  insert(leaf) {\n    if (this.depth && this.arity) {\n      if (this.nodes[0].length >= this.getMaxLeaves()) {\n        throw new Error('tree is full');\n      }\n    }\n    let node = leaf;\n    let index = this.nodes[0].length;\n    for (let level = 0; level < this.depth; level += 1) {\n      const position = index % this.arity;\n      const levelStartIndex = index - position;\n      const levelEndIndex = levelStartIndex + this.arity;\n      const children = [];\n      this.nodes[level][index] = node;\n      for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n        if (i < this.nodes[level].length) {\n          children.push(this.nodes[level][i]);\n        } else {\n          children.push(this.zeroes[level]);\n        }\n      }\n      node = this.hashFn(children);\n      index = Math.floor(index / this.arity);\n    }\n    this.root = node;\n  }\n  delete(index) {\n    this.update(index, this.zeroValue);\n  }\n  update(index, newLeaf) {\n    if (index < 0 || index >= this.nodes[0].length) {\n      throw new Error('out of bounds');\n    }\n    let node = newLeaf;\n    for (let level = 0; level < this.depth; level += 1) {\n      const position = index % this.arity;\n      const levelStartIndex = index - position;\n      const levelEndIndex = levelStartIndex + this.arity;\n      const children = [];\n      this.nodes[level][index] = node;\n      for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n        if (i < this.nodes[level].length) {\n          children.push(this.nodes[level][i]);\n        } else {\n          children.push(this.zeroes[level]);\n        }\n      }\n      node = this.hashFn(children);\n      index = Math.floor(index / this.arity);\n    }\n    this.root = node;\n  }\n  getDepth() {\n    return this.depth;\n  }\n  getArity() {\n    return this.arity;\n  }\n  getMaxLeaves() {\n    return Math.pow(this.depth, this.arity);\n  }\n  indexOf(leaf) {\n    return this.nodes[0].indexOf(leaf);\n  }\n  getLeaves() {\n    const leaves = this.copyList(this.nodes[0]);\n    const index = this.nodes[0].length;\n    for (let i = index; i < this.getMaxLeaves(); i++) {\n      leaves[i] = this.zeroValue;\n    }\n    return leaves;\n  }\n  copyList(list) {\n    return list.map(x => BigInt(x));\n  }\n  getLayers() {\n    const layers = [];\n    for (const list of this.nodes) {\n      layers.push(this.copyList(list));\n    }\n    if (layers[0].length < this.getMaxLeaves()) {\n      let index = layers[0].length;\n      for (let i = index; i < this.getMaxLeaves(); i++) {\n        layers[0][i] = this.zeroValue;\n      }\n      for (let level = 0; level < this.depth; level++) {\n        const position = index % this.arity;\n        const levelStartIndex = index - position;\n        const levelEndIndex = levelStartIndex + this.arity;\n        for (let i = levelStartIndex; i < levelEndIndex; i++) {\n          if (i >= layers[level].length) {\n            layers[level][i] = this.zeroes[level];\n          }\n        }\n        index = Math.floor(index / this.arity);\n      }\n    }\n    layers.push([this.root]);\n    return layers;\n  }\n  getHexLayers() {\n    return this.getLayers().reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.push(item.map(layer => this.bufferToHex(this.bufferify(layer))));\n      } else {\n        acc.push(item);\n      }\n      return acc;\n    }, []);\n  }\n  getLayersAsObject() {\n    const layers = this.getLayers().map(layer => layer.map(value => this.bufferToHex(this.bufferify(value), false)));\n    const objs = [];\n    for (let i = 0; i < layers.length; i++) {\n      const arr = [];\n      for (let j = 0; j < layers[i].length; j++) {\n        const obj = {\n          [layers[i][j]]: null\n        };\n        if (objs.length) {\n          obj[layers[i][j]] = {};\n          const a = objs.shift();\n          const akey = Object.keys(a)[0];\n          obj[layers[i][j]][akey] = a[akey];\n          if (objs.length) {\n            const b = objs.shift();\n            const bkey = Object.keys(b)[0];\n            obj[layers[i][j]][bkey] = b[bkey];\n          }\n        }\n        arr.push(obj);\n      }\n      objs.push(...arr);\n    }\n    return objs[0];\n  }\n  computeRoot() {\n    let node;\n    let index = this.nodes[0].length;\n    for (let level = 0; level < this.depth; level += 1) {\n      const position = index % this.arity;\n      const levelStartIndex = index - position;\n      const levelEndIndex = levelStartIndex + this.arity;\n      const children = [];\n      for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n        if (i < this.nodes[level].length) {\n          children.push(this.nodes[level][i]);\n        } else {\n          children.push(this.zeroes[level]);\n        }\n      }\n      node = this.hashFn(children);\n      index = Math.floor(index / this.arity);\n    }\n    return node;\n  }\n  getProof(index) {\n    if (index < 0 || index >= this.nodes[0].length) {\n      throw new Error('The leaf does not exist in this tree');\n    }\n    const siblings = [];\n    const pathIndices = [];\n    const leafIndex = index;\n    for (let level = 0; level < this.depth; level += 1) {\n      const position = index % this.arity;\n      const levelStartIndex = index - position;\n      const levelEndIndex = levelStartIndex + this.arity;\n      pathIndices[level] = position;\n      siblings[level] = [];\n      for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n        if (i !== index) {\n          if (i < this.nodes[level].length) {\n            siblings[level].push(this.nodes[level][i]);\n          } else {\n            siblings[level].push(this.zeroes[level]);\n          }\n        }\n      }\n      index = Math.floor(index / this.arity);\n    }\n    return {\n      root: this.root,\n      leaf: this.nodes[0][leafIndex],\n      pathIndices,\n      siblings\n    };\n  }\n  verify(proof) {\n    let node = proof.leaf;\n    for (let i = 0; i < proof.siblings.length; i += 1) {\n      const children = proof.siblings[i].slice();\n      children.splice(proof.pathIndices[i], 0, node);\n      node = this.hashFn(children);\n    }\n    return proof.root === node;\n  }\n  toString() {\n    return this.toTreeString();\n  }\n  toTreeString() {\n    const obj = this.getLayersAsObject();\n    return treeify_1.default.asTree(obj, true);\n  }\n}\nexports.IncrementalMerkleTree = IncrementalMerkleTree;\nif (typeof window !== 'undefined') {\n  ;\n  window.IncrementalMerkleTree = IncrementalMerkleTree;\n}\nexports.default = IncrementalMerkleTree;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","IncrementalMerkleTree","Base_1","require","treeify_1","default","constructor","hashFn","options","depth","arity","Error","nodes","zeroValue","zeroes","i","push","Array","fill","root","getRoot","getHexRoot","bufferToHex","bufferify","insert","leaf","length","getMaxLeaves","node","index","level","position","levelStartIndex","levelEndIndex","children","Math","floor","delete","update","newLeaf","getDepth","getArity","pow","indexOf","getLeaves","leaves","copyList","list","map","x","BigInt","getLayers","layers","getHexLayers","reduce","acc","item","isArray","layer","getLayersAsObject","objs","arr","j","obj","a","shift","akey","keys","b","bkey","computeRoot","getProof","siblings","pathIndices","leafIndex","verify","proof","slice","splice","toString","toTreeString","asTree","window"],"sources":["/home/diep/freelance/interface/node_modules/merkletreejs/dist/IncrementalMerkleTree.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IncrementalMerkleTree = void 0;\nconst Base_1 = __importDefault(require(\"./Base\"));\nconst treeify_1 = __importDefault(require(\"treeify\"));\nclass IncrementalMerkleTree extends Base_1.default {\n    constructor(hashFn, options) {\n        super();\n        this.hashFn = hashFn;\n        if (options.depth) {\n            this.depth = options.depth;\n        }\n        if (options.arity) {\n            this.arity = options.arity;\n        }\n        if (this.depth < 1) {\n            throw new Error('depth must be greater than 0');\n        }\n        if (this.arity < 1) {\n            throw new Error('arity must be greater than 0');\n        }\n        const nodes = [];\n        let zeroValue = options.zeroValue;\n        this.zeroValue = zeroValue;\n        this.zeroes = [];\n        if (this.depth) {\n            for (let i = 0; i < this.depth; i++) {\n                this.zeroes.push(zeroValue);\n                nodes[i] = [];\n                zeroValue = this.hashFn(Array(this.arity).fill(zeroValue));\n            }\n        }\n        this.nodes = nodes;\n        this.root = zeroValue;\n    }\n    getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.bufferify(this.getRoot()));\n    }\n    insert(leaf) {\n        if (this.depth && this.arity) {\n            if (this.nodes[0].length >= this.getMaxLeaves()) {\n                throw new Error('tree is full');\n            }\n        }\n        let node = leaf;\n        let index = this.nodes[0].length;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            this.nodes[level][index] = node;\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this.nodes[level].length) {\n                    children.push(this.nodes[level][i]);\n                }\n                else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this.hashFn(children);\n            index = Math.floor(index / this.arity);\n        }\n        this.root = node;\n    }\n    delete(index) {\n        this.update(index, this.zeroValue);\n    }\n    update(index, newLeaf) {\n        if (index < 0 || index >= this.nodes[0].length) {\n            throw new Error('out of bounds');\n        }\n        let node = newLeaf;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            this.nodes[level][index] = node;\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this.nodes[level].length) {\n                    children.push(this.nodes[level][i]);\n                }\n                else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this.hashFn(children);\n            index = Math.floor(index / this.arity);\n        }\n        this.root = node;\n    }\n    getDepth() {\n        return this.depth;\n    }\n    getArity() {\n        return this.arity;\n    }\n    getMaxLeaves() {\n        return Math.pow(this.depth, this.arity);\n    }\n    indexOf(leaf) {\n        return this.nodes[0].indexOf(leaf);\n    }\n    getLeaves() {\n        const leaves = this.copyList(this.nodes[0]);\n        const index = this.nodes[0].length;\n        for (let i = index; i < this.getMaxLeaves(); i++) {\n            leaves[i] = this.zeroValue;\n        }\n        return leaves;\n    }\n    copyList(list) {\n        return list.map((x) => BigInt(x));\n    }\n    getLayers() {\n        const layers = [];\n        for (const list of this.nodes) {\n            layers.push(this.copyList(list));\n        }\n        if (layers[0].length < this.getMaxLeaves()) {\n            let index = layers[0].length;\n            for (let i = index; i < this.getMaxLeaves(); i++) {\n                layers[0][i] = this.zeroValue;\n            }\n            for (let level = 0; level < this.depth; level++) {\n                const position = index % this.arity;\n                const levelStartIndex = index - position;\n                const levelEndIndex = levelStartIndex + this.arity;\n                for (let i = levelStartIndex; i < levelEndIndex; i++) {\n                    if (i >= layers[level].length) {\n                        layers[level][i] = this.zeroes[level];\n                    }\n                }\n                index = Math.floor(index / this.arity);\n            }\n        }\n        layers.push([this.root]);\n        return layers;\n    }\n    getHexLayers() {\n        return this.getLayers().reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.push(item.map(layer => this.bufferToHex(this.bufferify(layer))));\n            }\n            else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    getLayersAsObject() {\n        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(this.bufferify(value), false)));\n        const objs = [];\n        for (let i = 0; i < layers.length; i++) {\n            const arr = [];\n            for (let j = 0; j < layers[i].length; j++) {\n                const obj = { [layers[i][j]]: null };\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    const akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        const bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    computeRoot() {\n        let node;\n        let index = this.nodes[0].length;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this.nodes[level].length) {\n                    children.push(this.nodes[level][i]);\n                }\n                else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this.hashFn(children);\n            index = Math.floor(index / this.arity);\n        }\n        return node;\n    }\n    getProof(index) {\n        if (index < 0 || index >= this.nodes[0].length) {\n            throw new Error('The leaf does not exist in this tree');\n        }\n        const siblings = [];\n        const pathIndices = [];\n        const leafIndex = index;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            pathIndices[level] = position;\n            siblings[level] = [];\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i !== index) {\n                    if (i < this.nodes[level].length) {\n                        siblings[level].push(this.nodes[level][i]);\n                    }\n                    else {\n                        siblings[level].push(this.zeroes[level]);\n                    }\n                }\n            }\n            index = Math.floor(index / this.arity);\n        }\n        return { root: this.root, leaf: this.nodes[0][leafIndex], pathIndices, siblings };\n    }\n    verify(proof) {\n        let node = proof.leaf;\n        for (let i = 0; i < proof.siblings.length; i += 1) {\n            const children = proof.siblings[i].slice();\n            children.splice(proof.pathIndices[i], 0, node);\n            node = this.hashFn(children);\n        }\n        return proof.root === node;\n    }\n    toString() {\n        return this.toTreeString();\n    }\n    toTreeString() {\n        const obj = this.getLayersAsObject();\n        return treeify_1.default.asTree(obj, true);\n    }\n}\nexports.IncrementalMerkleTree = IncrementalMerkleTree;\nif (typeof window !== 'undefined') {\n    ;\n    window.IncrementalMerkleTree = IncrementalMerkleTree;\n}\nexports.default = IncrementalMerkleTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}