{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\nimport { useAllTokensMultichain } from 'hooks/Tokens';\nimport { atom, useAtom } from 'jotai';\nimport { atomWithStorage } from 'jotai/utils';\nimport { useCallback } from 'react';\nimport { deserializeToken, serializeToken } from 'state/user/hooks';\nimport { buildCurrencyKey, currencyKey } from 'utils/currencyKey';\nimport { getTokensAsync } from './getTokensAsync';\nimport { useInterfaceMulticallContracts } from './hooks';\nconst POSITION_CACHE_EXPIRY = 60000; // 1 minute is arbitrary here\n// Allows reusing recently fetched positions between component mounts\n\nconst cachedPositionsAtom = atom({});\n/**\n * Caches positions to allow reusing between component mounts\n * @param account address to cache positions for\n * @returns cached positions for the account, whether the cache is stale, and a function to update the positions and cache\n */\nexport function useCachedPositions(account) {\n  _s();\n  const [cachedPositions, setCachedPositions] = useAtom(cachedPositionsAtom);\n  const setPositionsAndStaleTimeout = useCallback(positions => {\n    setCachedPositions(cache => ({\n      ...cache,\n      [account]: {\n        result: positions,\n        stale: false\n      }\n    }));\n    setTimeout(() => setCachedPositions(cache => {\n      var _cache$account;\n      // sets stale to true if the positions haven't been updated since the timeout\n      if (positions === ((_cache$account = cache[account]) === null || _cache$account === void 0 ? void 0 : _cache$account.result)) {\n        return {\n          ...cache,\n          [account]: {\n            result: positions,\n            stale: true\n          }\n        };\n      } else {\n        return cache;\n      }\n    }), POSITION_CACHE_EXPIRY);\n  }, [account, setCachedPositions]);\n  return [cachedPositions[account], setPositionsAndStaleTimeout];\n}\n_s(useCachedPositions, \"YkO0h0qX1mJKG0kx5DKjiNzLHrQ=\", false, function () {\n  return [useAtom];\n});\nconst poolAddressKey = (details, chainId) => `${chainId}-${details.token0}-${details.token1}-${details.fee}`;\nconst poolAddressCacheAtom = atomWithStorage('poolCache', {});\n/**\n * Caches pool addresses to prevent components from having to re-compute them\n * @returns get and set functions for the cache\n */\nexport function usePoolAddressCache() {\n  _s2();\n  const [cache, updateCache] = useAtom(poolAddressCacheAtom);\n  const get = useCallback((details, chainId) => cache[poolAddressKey(details, chainId)], [cache]);\n  const set = useCallback((details, chainId, address) => updateCache(c => ({\n    ...c,\n    [poolAddressKey(details, chainId)]: address\n  })), [updateCache]);\n  return {\n    get,\n    set\n  };\n}\n\n// These values are static, so we can persist them across sessions using `WithStorage`\n_s2(usePoolAddressCache, \"RhKUdB0Z4aiKBumbydLCYdyuriA=\", false, function () {\n  return [useAtom];\n});\nconst tokenCacheAtom = atomWithStorage('cachedAsyncTokens', {});\nfunction useTokenCache() {\n  _s3();\n  const [cache, setCache] = useAtom(tokenCacheAtom);\n  const get = useCallback((chainId, address) => {\n    const entry = cache[buildCurrencyKey(chainId, address)];\n    return entry ? deserializeToken(entry) : undefined;\n  }, [cache]);\n  const set = useCallback(token => {\n    if (token) {\n      setCache(cache => ({\n        ...cache,\n        [currencyKey(token)]: serializeToken(token)\n      }));\n    }\n  }, [setCache]);\n  return {\n    get,\n    set\n  };\n}\n_s3(useTokenCache, \"c+3ssgwn+woC3Vs9Hgc5UHjpRVY=\", false, function () {\n  return [useAtom];\n});\nexport function useGetCachedTokens(chains) {\n  _s4();\n  const allTokens = useAllTokensMultichain();\n  const multicallContracts = useInterfaceMulticallContracts(chains);\n  const tokenCache = useTokenCache();\n\n  // Used to fetch tokens not available in local state\n  const fetchRemoteTokens = useCallback(async (addresses, chainId) => {\n    const fetched = await getTokensAsync(addresses, chainId, multicallContracts[chainId]);\n    Object.values(fetched).forEach(tokenCache.set);\n    return fetched;\n  }, [multicallContracts, tokenCache]);\n\n  // Uses tokens from local state if available, otherwise fetches them\n  const getTokens = useCallback(async (addresses, chainId) => {\n    const local = {};\n    const missing = new Set();\n    addresses.forEach(address => {\n      var _tokenCache$get, _allTokens$chainId$ad;\n      const cached = (_tokenCache$get = tokenCache.get(chainId, address)) !== null && _tokenCache$get !== void 0 ? _tokenCache$get : (_allTokens$chainId$ad = allTokens[chainId][address]) === null || _allTokens$chainId$ad === void 0 ? void 0 : _allTokens$chainId$ad.token;\n      cached ? local[address] = cached : missing.add(address);\n    });\n    const fetched = await fetchRemoteTokens([...missing], chainId);\n    return {\n      ...local,\n      ...fetched\n    };\n  }, [allTokens, fetchRemoteTokens, tokenCache]);\n  return getTokens;\n}\n_s4(useGetCachedTokens, \"6dRl0R5YvE6IVsjxXPEE77WMZII=\", false, function () {\n  return [useAllTokensMultichain, useInterfaceMulticallContracts, useTokenCache];\n});","map":{"version":3,"names":["useAllTokensMultichain","atom","useAtom","atomWithStorage","useCallback","deserializeToken","serializeToken","buildCurrencyKey","currencyKey","getTokensAsync","useInterfaceMulticallContracts","POSITION_CACHE_EXPIRY","cachedPositionsAtom","useCachedPositions","account","cachedPositions","setCachedPositions","setPositionsAndStaleTimeout","positions","cache","result","stale","setTimeout","poolAddressKey","details","chainId","token0","token1","fee","poolAddressCacheAtom","usePoolAddressCache","updateCache","get","set","address","c","tokenCacheAtom","useTokenCache","setCache","entry","undefined","token","useGetCachedTokens","chains","allTokens","multicallContracts","tokenCache","fetchRemoteTokens","addresses","fetched","Object","values","forEach","getTokens","local","missing","Set","cached","add"],"sources":["/home/diep/freelance/interface/src/components/AccountDrawer/MiniPortfolio/Pools/cache.ts"],"sourcesContent":["import { Token } from '@uniswap/sdk-core'\nimport { Pool, Position } from '@uniswap/v3-sdk'\nimport { SupportedChainId } from 'constants/chains'\nimport { useAllTokensMultichain } from 'hooks/Tokens'\nimport { atom, useAtom } from 'jotai'\nimport { atomWithStorage } from 'jotai/utils'\nimport ms from 'ms.macro'\nimport { useCallback } from 'react'\nimport { deserializeToken, serializeToken } from 'state/user/hooks'\nimport { SerializedToken } from 'state/user/types'\nimport { PositionDetails } from 'types/position'\nimport { buildCurrencyKey, currencyKey } from 'utils/currencyKey'\n\nimport { getTokensAsync } from './getTokensAsync'\nimport { useInterfaceMulticallContracts } from './hooks'\n\nexport type PositionInfo = {\n  owner: string\n  chainId: SupportedChainId\n  position: Position\n  pool: Pool\n  details: PositionDetails\n  inRange: boolean\n  closed: boolean\n  fees?: [number?, number?]\n  prices?: [number?, number?]\n}\n\nconst POSITION_CACHE_EXPIRY = ms`1m` // 1 minute is arbitrary here\n// Allows reusing recently fetched positions between component mounts\ntype CachedPositionsEntry = { result: PositionInfo[]; stale: boolean }\nconst cachedPositionsAtom = atom<{ [address: string]: CachedPositionsEntry | undefined }>({})\ntype UseCachedPositionsReturnType = [CachedPositionsEntry | undefined, (positions: PositionInfo[]) => void]\n/**\n * Caches positions to allow reusing between component mounts\n * @param account address to cache positions for\n * @returns cached positions for the account, whether the cache is stale, and a function to update the positions and cache\n */\nexport function useCachedPositions(account: string): UseCachedPositionsReturnType {\n  const [cachedPositions, setCachedPositions] = useAtom(cachedPositionsAtom)\n  const setPositionsAndStaleTimeout = useCallback(\n    (positions: PositionInfo[]) => {\n      setCachedPositions((cache) => ({ ...cache, [account]: { result: positions, stale: false } }))\n      setTimeout(\n        () =>\n          setCachedPositions((cache) => {\n            // sets stale to true if the positions haven't been updated since the timeout\n            if (positions === cache[account]?.result) {\n              return { ...cache, [account]: { result: positions, stale: true } }\n            } else {\n              return cache\n            }\n          }),\n        POSITION_CACHE_EXPIRY\n      )\n    },\n    [account, setCachedPositions]\n  )\n  return [cachedPositions[account], setPositionsAndStaleTimeout]\n}\n\nconst poolAddressKey = (details: PositionDetails, chainId: SupportedChainId) =>\n  `${chainId}-${details.token0}-${details.token1}-${details.fee}`\n\ntype PoolAddressMap = { [key: string]: string | undefined }\nconst poolAddressCacheAtom = atomWithStorage<PoolAddressMap>('poolCache', {})\n/**\n * Caches pool addresses to prevent components from having to re-compute them\n * @returns get and set functions for the cache\n */\nexport function usePoolAddressCache() {\n  const [cache, updateCache] = useAtom(poolAddressCacheAtom)\n  const get = useCallback(\n    (details: PositionDetails, chainId: SupportedChainId) => cache[poolAddressKey(details, chainId)],\n    [cache]\n  )\n  const set = useCallback(\n    (details: PositionDetails, chainId: SupportedChainId, address: string) =>\n      updateCache((c) => ({ ...c, [poolAddressKey(details, chainId)]: address })),\n    [updateCache]\n  )\n  return { get, set }\n}\n\n// These values are static, so we can persist them across sessions using `WithStorage`\nconst tokenCacheAtom = atomWithStorage<{ [key: string]: SerializedToken | undefined }>('cachedAsyncTokens', {})\nfunction useTokenCache() {\n  const [cache, setCache] = useAtom(tokenCacheAtom)\n  const get = useCallback(\n    (chainId: number, address: string) => {\n      const entry = cache[buildCurrencyKey(chainId, address)]\n      return entry ? deserializeToken(entry) : undefined\n    },\n    [cache]\n  )\n  const set = useCallback(\n    (token?: Token) => {\n      if (token) {\n        setCache((cache) => ({ ...cache, [currencyKey(token)]: serializeToken(token) }))\n      }\n    },\n    [setCache]\n  )\n  return { get, set }\n}\n\ntype TokenGetterFn = (addresses: string[], chainId: SupportedChainId) => Promise<{ [key: string]: Token | undefined }>\nexport function useGetCachedTokens(chains: SupportedChainId[]): TokenGetterFn {\n  const allTokens = useAllTokensMultichain()\n  const multicallContracts = useInterfaceMulticallContracts(chains)\n  const tokenCache = useTokenCache()\n\n  // Used to fetch tokens not available in local state\n  const fetchRemoteTokens: TokenGetterFn = useCallback(\n    async (addresses, chainId) => {\n      const fetched = await getTokensAsync(addresses, chainId, multicallContracts[chainId])\n      Object.values(fetched).forEach(tokenCache.set)\n      return fetched\n    },\n    [multicallContracts, tokenCache]\n  )\n\n  // Uses tokens from local state if available, otherwise fetches them\n  const getTokens: TokenGetterFn = useCallback(\n    async (addresses, chainId) => {\n      const local: { [address: string]: Token | undefined } = {}\n      const missing = new Set<string>()\n      addresses.forEach((address) => {\n        const cached = tokenCache.get(chainId, address) ?? allTokens[chainId][address]?.token\n        cached ? (local[address] = cached) : missing.add(address)\n      })\n\n      const fetched = await fetchRemoteTokens([...missing], chainId)\n      return { ...local, ...fetched }\n    },\n    [allTokens, fetchRemoteTokens, tokenCache]\n  )\n\n  return getTokens\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}