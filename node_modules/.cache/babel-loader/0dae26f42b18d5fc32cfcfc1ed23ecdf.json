{"ast":null,"code":"var _s = $RefreshSig$();\nimport { CurrencyAmount, Token } from '@uniswap/sdk-core';\nimport { abi as IUniswapV3PoolStateABI } from '@uniswap/v3-core/artifacts/contracts/interfaces/pool/IUniswapV3PoolState.sol/IUniswapV3PoolState.json';\nimport { computePoolAddress, Pool, Position } from '@uniswap/v3-sdk';\nimport { V3_CORE_FACTORY_ADDRESSES } from 'constants/addresses';\nimport { SupportedChainId } from 'constants/chains';\nimport { DEFAULT_ERC20_DECIMALS } from 'constants/tokens';\nimport { BigNumber } from 'ethers/lib/ethers';\nimport { Interface } from 'ethers/lib/utils';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { currencyKey } from 'utils/currencyKey';\nimport { useCachedPositions, useGetCachedTokens, usePoolAddressCache } from './cache';\nimport { DEFAULT_GAS_LIMIT } from './getTokensAsync';\nimport { useInterfaceMulticallContracts, usePoolPriceMap, useV3ManagerContracts } from './hooks';\nfunction createPositionInfo(owner, chainId, details, slot0, tokenA, tokenB) {\n  /* Instantiates a Pool with a hardcoded 0 liqudity value since the sdk only uses this value for swap state and this avoids an RPC fetch */\n  const pool = new Pool(tokenA, tokenB, details.fee, slot0.sqrtPriceX96.toString(), 0, slot0.tick);\n  const position = new Position({\n    pool,\n    liquidity: details.liquidity.toString(),\n    tickLower: details.tickLower,\n    tickUpper: details.tickUpper\n  });\n  const inRange = slot0.tick >= details.tickLower && slot0.tick < details.tickUpper;\n  const closed = details.liquidity.eq(0);\n  return {\n    owner,\n    chainId,\n    pool,\n    position,\n    details,\n    inRange,\n    closed\n  };\n}\nconst MAX_UINT128 = BigNumber.from(2).pow(128).sub(1);\nconst DEFAULT_CHAINS = [SupportedChainId.MAINNET, SupportedChainId.ARBITRUM_ONE, SupportedChainId.OPTIMISM, SupportedChainId.POLYGON, SupportedChainId.CELO];\n/**\n * Returns all positions for a given account on multiple chains.\n *\n * This hook doesn't use the redux-multicall library to avoid having to manually fetching blocknumbers for each chain.\n *\n * @param account - account to fetch positions for\n * @param chains - chains to fetch positions from\n * @returns positions, fees\n */\nexport default function useMultiChainPositions(account) {\n  _s();\n  let chains = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_CHAINS;\n  const pms = useV3ManagerContracts(chains);\n  const multicalls = useInterfaceMulticallContracts(chains);\n  const getTokens = useGetCachedTokens(chains);\n  const poolAddressCache = usePoolAddressCache();\n  const [cachedPositions, setPositions] = useCachedPositions(account);\n  const positions = cachedPositions === null || cachedPositions === void 0 ? void 0 : cachedPositions.result;\n  const positionsFetching = useRef(false);\n  const positionsLoading = !(cachedPositions === null || cachedPositions === void 0 ? void 0 : cachedPositions.result) && positionsFetching.current;\n  const [feeMap, setFeeMap] = useState({});\n  const {\n    priceMap,\n    pricesLoading\n  } = usePoolPriceMap(positions);\n  const fetchPositionFees = useCallback(async (pm, positionIds, chainId) => {\n    const callData = positionIds.map(id => pm.interface.encodeFunctionData('collect', [{\n      tokenId: id,\n      recipient: account,\n      amount0Max: MAX_UINT128,\n      amount1Max: MAX_UINT128\n    }]));\n    const fees = (await pm.callStatic.multicall(callData)).reduce((acc, feeBytes, index) => {\n      const key = chainId.toString() + positionIds[index];\n      acc[key] = pm.interface.decodeFunctionResult('collect', feeBytes);\n      return acc;\n    }, {});\n    setFeeMap(prev => ({\n      ...prev,\n      ...fees\n    }));\n  }, [account]);\n  const fetchPositionIds = useCallback(async (pm, balance) => {\n    const callData = Array.from({\n      length: balance.toNumber()\n    }, (_, i) => pm.interface.encodeFunctionData('tokenOfOwnerByIndex', [account, i]));\n    return (await pm.callStatic.multicall(callData)).map(idByte => BigNumber.from(idByte));\n  }, [account]);\n  const fetchPositionDetails = useCallback(async (pm, positionIds) => {\n    const callData = positionIds.map(id => pm.interface.encodeFunctionData('positions', [id]));\n    return (await pm.callStatic.multicall(callData)).map((positionBytes, index) => ({\n      ...pm.interface.decodeFunctionResult('positions', positionBytes),\n      tokenId: positionIds[index]\n    }));\n  }, []);\n\n  // Combines PositionDetails with Pool data to build our return type\n  const fetchPositionInfo = useCallback(async (positionDetails, chainId, multicall) => {\n    const poolInterface = new Interface(IUniswapV3PoolStateABI);\n    const tokens = await getTokens(positionDetails.flatMap(details => [details.token0, details.token1]), chainId);\n    const calls = [];\n    const poolPairs = [];\n    positionDetails.forEach(details => {\n      var _tokens$details$token, _tokens$details$token2;\n      const tokenA = (_tokens$details$token = tokens[details.token0]) !== null && _tokens$details$token !== void 0 ? _tokens$details$token : new Token(chainId, details.token0, DEFAULT_ERC20_DECIMALS);\n      const tokenB = (_tokens$details$token2 = tokens[details.token1]) !== null && _tokens$details$token2 !== void 0 ? _tokens$details$token2 : new Token(chainId, details.token1, DEFAULT_ERC20_DECIMALS);\n      let poolAddress = poolAddressCache.get(details, chainId);\n      if (!poolAddress) {\n        const factoryAddress = V3_CORE_FACTORY_ADDRESSES[chainId];\n        poolAddress = computePoolAddress({\n          factoryAddress,\n          tokenA,\n          tokenB,\n          fee: details.fee\n        });\n        poolAddressCache.set(details, chainId, poolAddress);\n      }\n      poolPairs.push([tokenA, tokenB]);\n      calls.push({\n        target: poolAddress,\n        callData: poolInterface.encodeFunctionData('slot0'),\n        gasLimit: DEFAULT_GAS_LIMIT\n      });\n    }, []);\n    return (await multicall.callStatic.multicall(calls)).returnData.reduce((acc, result, i) => {\n      if (result.success) {\n        const slot0 = poolInterface.decodeFunctionResult('slot0', result.returnData);\n        acc.push(createPositionInfo(account, chainId, positionDetails[i], slot0, ...poolPairs[i]));\n      } else {\n        console.debug('slot0 fetch errored', result);\n      }\n      return acc;\n    }, []);\n  }, [account, poolAddressCache, getTokens]);\n  const fetchPositionsForChain = useCallback(async chainId => {\n    try {\n      const pm = pms[chainId];\n      const multicall = multicalls[chainId];\n      const balance = await (pm === null || pm === void 0 ? void 0 : pm.balanceOf(account));\n      if (!pm || !multicall || balance.lt(1)) return [];\n      const positionIds = await fetchPositionIds(pm, balance);\n      // Fetches fees in the background and stores them separetely from the results of this function\n      fetchPositionFees(pm, positionIds, chainId);\n      const postionDetails = await fetchPositionDetails(pm, positionIds);\n      return fetchPositionInfo(postionDetails, chainId, multicall);\n    } catch (error) {\n      console.error(`Failed to fetch positions for chain ${chainId}`, error);\n      return [];\n    }\n  }, [account, fetchPositionDetails, fetchPositionFees, fetchPositionIds, fetchPositionInfo, pms, multicalls]);\n  const fetchAllPositions = useCallback(async () => {\n    positionsFetching.current = true;\n    const positions = (await Promise.all(chains.map(fetchPositionsForChain))).flat();\n    positionsFetching.current = false;\n    setPositions(positions);\n  }, [chains, fetchPositionsForChain, setPositions]);\n\n  // Fetches positions when existing positions are stale and the document has focus\n  useEffect(() => {\n    if (positionsFetching.current || (cachedPositions === null || cachedPositions === void 0 ? void 0 : cachedPositions.stale) === false) return;else if (document.hasFocus()) {\n      fetchAllPositions();\n    } else {\n      // Avoids refetching positions until the user returns to Interface to avoid polling unnused rpc data\n      const onFocus = () => {\n        fetchAllPositions();\n        window.removeEventListener('focus', onFocus);\n      };\n      window.addEventListener('focus', onFocus);\n      return () => {\n        window.removeEventListener('focus', onFocus);\n      };\n    }\n    return;\n  }, [fetchAllPositions, positionsFetching, cachedPositions === null || cachedPositions === void 0 ? void 0 : cachedPositions.stale]);\n  const positionsWithFeesAndPrices = useMemo(() => positions === null || positions === void 0 ? void 0 : positions.map(position => {\n    var _feeMap$key, _feeMap$key2;\n    const key = position.chainId.toString() + position.details.tokenId;\n    const fees = feeMap[key] ? [\n    // We parse away from SDK/ethers types so fees can be multiplied by primitive number prices\n    parseFloat(CurrencyAmount.fromRawAmount(position.pool.token0, (_feeMap$key = feeMap[key]) === null || _feeMap$key === void 0 ? void 0 : _feeMap$key[0].toString()).toExact()), parseFloat(CurrencyAmount.fromRawAmount(position.pool.token1, (_feeMap$key2 = feeMap[key]) === null || _feeMap$key2 === void 0 ? void 0 : _feeMap$key2[1].toString()).toExact())] : undefined;\n    const prices = [priceMap[currencyKey(position.pool.token0)], priceMap[currencyKey(position.pool.token1)]];\n    return {\n      ...position,\n      fees,\n      prices\n    };\n  }), [feeMap, positions, priceMap]);\n  return {\n    positions: positionsWithFeesAndPrices,\n    loading: pricesLoading || positionsLoading\n  };\n}\n_s(useMultiChainPositions, \"9UpPN5Pnu6jzU5mQKayPVVJASC8=\", false, function () {\n  return [useV3ManagerContracts, useInterfaceMulticallContracts, useGetCachedTokens, usePoolAddressCache, useCachedPositions, usePoolPriceMap];\n});","map":{"version":3,"names":["CurrencyAmount","Token","abi","IUniswapV3PoolStateABI","computePoolAddress","Pool","Position","V3_CORE_FACTORY_ADDRESSES","SupportedChainId","DEFAULT_ERC20_DECIMALS","BigNumber","Interface","useCallback","useEffect","useMemo","useRef","useState","currencyKey","useCachedPositions","useGetCachedTokens","usePoolAddressCache","DEFAULT_GAS_LIMIT","useInterfaceMulticallContracts","usePoolPriceMap","useV3ManagerContracts","createPositionInfo","owner","chainId","details","slot0","tokenA","tokenB","pool","fee","sqrtPriceX96","toString","tick","position","liquidity","tickLower","tickUpper","inRange","closed","eq","MAX_UINT128","from","pow","sub","DEFAULT_CHAINS","MAINNET","ARBITRUM_ONE","OPTIMISM","POLYGON","CELO","useMultiChainPositions","account","chains","pms","multicalls","getTokens","poolAddressCache","cachedPositions","setPositions","positions","result","positionsFetching","positionsLoading","current","feeMap","setFeeMap","priceMap","pricesLoading","fetchPositionFees","pm","positionIds","callData","map","id","interface","encodeFunctionData","tokenId","recipient","amount0Max","amount1Max","fees","callStatic","multicall","reduce","acc","feeBytes","index","key","decodeFunctionResult","prev","fetchPositionIds","balance","Array","length","toNumber","_","i","idByte","fetchPositionDetails","positionBytes","fetchPositionInfo","positionDetails","poolInterface","tokens","flatMap","token0","token1","calls","poolPairs","forEach","poolAddress","get","factoryAddress","set","push","target","gasLimit","returnData","success","console","debug","fetchPositionsForChain","balanceOf","lt","postionDetails","error","fetchAllPositions","Promise","all","flat","stale","document","hasFocus","onFocus","window","removeEventListener","addEventListener","positionsWithFeesAndPrices","parseFloat","fromRawAmount","toExact","undefined","prices","loading"],"sources":["/home/diep/freelance/interface/src/components/AccountDrawer/MiniPortfolio/Pools/useMultiChainPositions.tsx"],"sourcesContent":["import { CurrencyAmount, Token } from '@uniswap/sdk-core'\nimport { abi as IUniswapV3PoolStateABI } from '@uniswap/v3-core/artifacts/contracts/interfaces/pool/IUniswapV3PoolState.sol/IUniswapV3PoolState.json'\nimport { computePoolAddress, Pool, Position } from '@uniswap/v3-sdk'\nimport { V3_CORE_FACTORY_ADDRESSES } from 'constants/addresses'\nimport { SupportedChainId } from 'constants/chains'\nimport { DEFAULT_ERC20_DECIMALS } from 'constants/tokens'\nimport { BigNumber } from 'ethers/lib/ethers'\nimport { Interface } from 'ethers/lib/utils'\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { PositionDetails } from 'types/position'\nimport { NonfungiblePositionManager, UniswapInterfaceMulticall } from 'types/v3'\nimport { UniswapV3PoolInterface } from 'types/v3/UniswapV3Pool'\nimport { currencyKey } from 'utils/currencyKey'\n\nimport { PositionInfo, useCachedPositions, useGetCachedTokens, usePoolAddressCache } from './cache'\nimport { Call, DEFAULT_GAS_LIMIT } from './getTokensAsync'\nimport { useInterfaceMulticallContracts, usePoolPriceMap, useV3ManagerContracts } from './hooks'\n\nfunction createPositionInfo(\n  owner: string,\n  chainId: SupportedChainId,\n  details: PositionDetails,\n  slot0: any,\n  tokenA: Token,\n  tokenB: Token\n): PositionInfo {\n  /* Instantiates a Pool with a hardcoded 0 liqudity value since the sdk only uses this value for swap state and this avoids an RPC fetch */\n  const pool = new Pool(tokenA, tokenB, details.fee, slot0.sqrtPriceX96.toString(), 0, slot0.tick)\n  const position = new Position({\n    pool,\n    liquidity: details.liquidity.toString(),\n    tickLower: details.tickLower,\n    tickUpper: details.tickUpper,\n  })\n  const inRange = slot0.tick >= details.tickLower && slot0.tick < details.tickUpper\n  const closed = details.liquidity.eq(0)\n  return { owner, chainId, pool, position, details, inRange, closed }\n}\n\ntype FeeAmounts = [BigNumber, BigNumber]\n\nconst MAX_UINT128 = BigNumber.from(2).pow(128).sub(1)\n\nconst DEFAULT_CHAINS = [\n  SupportedChainId.MAINNET,\n  SupportedChainId.ARBITRUM_ONE,\n  SupportedChainId.OPTIMISM,\n  SupportedChainId.POLYGON,\n  SupportedChainId.CELO,\n]\n\ntype UseMultiChainPositionsData = { positions: PositionInfo[] | undefined; loading: boolean }\n\n/**\n * Returns all positions for a given account on multiple chains.\n *\n * This hook doesn't use the redux-multicall library to avoid having to manually fetching blocknumbers for each chain.\n *\n * @param account - account to fetch positions for\n * @param chains - chains to fetch positions from\n * @returns positions, fees\n */\nexport default function useMultiChainPositions(account: string, chains = DEFAULT_CHAINS): UseMultiChainPositionsData {\n  const pms = useV3ManagerContracts(chains)\n  const multicalls = useInterfaceMulticallContracts(chains)\n\n  const getTokens = useGetCachedTokens(chains)\n  const poolAddressCache = usePoolAddressCache()\n\n  const [cachedPositions, setPositions] = useCachedPositions(account)\n  const positions = cachedPositions?.result\n  const positionsFetching = useRef(false)\n  const positionsLoading = !cachedPositions?.result && positionsFetching.current\n\n  const [feeMap, setFeeMap] = useState<{ [key: string]: FeeAmounts }>({})\n\n  const { priceMap, pricesLoading } = usePoolPriceMap(positions)\n\n  const fetchPositionFees = useCallback(\n    async (pm: NonfungiblePositionManager, positionIds: BigNumber[], chainId: number) => {\n      const callData = positionIds.map((id) =>\n        pm.interface.encodeFunctionData('collect', [\n          { tokenId: id, recipient: account, amount0Max: MAX_UINT128, amount1Max: MAX_UINT128 },\n        ])\n      )\n      const fees = (await pm.callStatic.multicall(callData)).reduce((acc, feeBytes, index) => {\n        const key = chainId.toString() + positionIds[index]\n        acc[key] = pm.interface.decodeFunctionResult('collect', feeBytes) as FeeAmounts\n        return acc\n      }, {} as { [key: string]: FeeAmounts })\n\n      setFeeMap((prev) => ({ ...prev, ...fees }))\n    },\n    [account]\n  )\n\n  const fetchPositionIds = useCallback(\n    async (pm: NonfungiblePositionManager, balance: BigNumber) => {\n      const callData = Array.from({ length: balance.toNumber() }, (_, i) =>\n        pm.interface.encodeFunctionData('tokenOfOwnerByIndex', [account, i])\n      )\n      return (await pm.callStatic.multicall(callData)).map((idByte) => BigNumber.from(idByte))\n    },\n    [account]\n  )\n\n  const fetchPositionDetails = useCallback(async (pm: NonfungiblePositionManager, positionIds: BigNumber[]) => {\n    const callData = positionIds.map((id) => pm.interface.encodeFunctionData('positions', [id]))\n    return (await pm.callStatic.multicall(callData)).map(\n      (positionBytes, index) =>\n        ({\n          ...pm.interface.decodeFunctionResult('positions', positionBytes),\n          tokenId: positionIds[index],\n        } as unknown as PositionDetails)\n    )\n  }, [])\n\n  // Combines PositionDetails with Pool data to build our return type\n  const fetchPositionInfo = useCallback(\n    async (positionDetails: PositionDetails[], chainId: SupportedChainId, multicall: UniswapInterfaceMulticall) => {\n      const poolInterface = new Interface(IUniswapV3PoolStateABI) as UniswapV3PoolInterface\n      const tokens = await getTokens(\n        positionDetails.flatMap((details) => [details.token0, details.token1]),\n        chainId\n      )\n\n      const calls: Call[] = []\n      const poolPairs: [Token, Token][] = []\n      positionDetails.forEach((details) => {\n        const tokenA = tokens[details.token0] ?? new Token(chainId, details.token0, DEFAULT_ERC20_DECIMALS)\n        const tokenB = tokens[details.token1] ?? new Token(chainId, details.token1, DEFAULT_ERC20_DECIMALS)\n\n        let poolAddress = poolAddressCache.get(details, chainId)\n        if (!poolAddress) {\n          const factoryAddress = V3_CORE_FACTORY_ADDRESSES[chainId]\n          poolAddress = computePoolAddress({ factoryAddress, tokenA, tokenB, fee: details.fee })\n          poolAddressCache.set(details, chainId, poolAddress)\n        }\n        poolPairs.push([tokenA, tokenB])\n        calls.push({\n          target: poolAddress,\n          callData: poolInterface.encodeFunctionData('slot0'),\n          gasLimit: DEFAULT_GAS_LIMIT,\n        })\n      }, [])\n\n      return (await multicall.callStatic.multicall(calls)).returnData.reduce((acc: PositionInfo[], result, i) => {\n        if (result.success) {\n          const slot0 = poolInterface.decodeFunctionResult('slot0', result.returnData)\n          acc.push(createPositionInfo(account, chainId, positionDetails[i], slot0, ...poolPairs[i]))\n        } else {\n          console.debug('slot0 fetch errored', result)\n        }\n        return acc\n      }, [])\n    },\n    [account, poolAddressCache, getTokens]\n  )\n\n  const fetchPositionsForChain = useCallback(\n    async (chainId: SupportedChainId): Promise<PositionInfo[]> => {\n      try {\n        const pm = pms[chainId]\n        const multicall = multicalls[chainId]\n        const balance = await pm?.balanceOf(account)\n        if (!pm || !multicall || balance.lt(1)) return []\n\n        const positionIds = await fetchPositionIds(pm, balance)\n        // Fetches fees in the background and stores them separetely from the results of this function\n        fetchPositionFees(pm, positionIds, chainId)\n\n        const postionDetails = await fetchPositionDetails(pm, positionIds)\n        return fetchPositionInfo(postionDetails, chainId, multicall)\n      } catch (error) {\n        console.error(`Failed to fetch positions for chain ${chainId}`, error)\n        return []\n      }\n    },\n    [account, fetchPositionDetails, fetchPositionFees, fetchPositionIds, fetchPositionInfo, pms, multicalls]\n  )\n\n  const fetchAllPositions = useCallback(async () => {\n    positionsFetching.current = true\n    const positions = (await Promise.all(chains.map(fetchPositionsForChain))).flat()\n    positionsFetching.current = false\n    setPositions(positions)\n  }, [chains, fetchPositionsForChain, setPositions])\n\n  // Fetches positions when existing positions are stale and the document has focus\n  useEffect(() => {\n    if (positionsFetching.current || cachedPositions?.stale === false) return\n    else if (document.hasFocus()) {\n      fetchAllPositions()\n    } else {\n      // Avoids refetching positions until the user returns to Interface to avoid polling unnused rpc data\n      const onFocus = () => {\n        fetchAllPositions()\n        window.removeEventListener('focus', onFocus)\n      }\n      window.addEventListener('focus', onFocus)\n      return () => {\n        window.removeEventListener('focus', onFocus)\n      }\n    }\n    return\n  }, [fetchAllPositions, positionsFetching, cachedPositions?.stale])\n\n  const positionsWithFeesAndPrices: PositionInfo[] | undefined = useMemo(\n    () =>\n      positions?.map((position) => {\n        const key = position.chainId.toString() + position.details.tokenId\n        const fees = feeMap[key]\n          ? [\n              // We parse away from SDK/ethers types so fees can be multiplied by primitive number prices\n              parseFloat(CurrencyAmount.fromRawAmount(position.pool.token0, feeMap[key]?.[0].toString()).toExact()),\n              parseFloat(CurrencyAmount.fromRawAmount(position.pool.token1, feeMap[key]?.[1].toString()).toExact()),\n            ]\n          : undefined\n        const prices = [priceMap[currencyKey(position.pool.token0)], priceMap[currencyKey(position.pool.token1)]]\n        return { ...position, fees, prices } as PositionInfo\n      }),\n    [feeMap, positions, priceMap]\n  )\n\n  return { positions: positionsWithFeesAndPrices, loading: pricesLoading || positionsLoading }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}