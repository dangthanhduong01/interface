{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useMemo } from 'react';\nimport { hasURL } from 'utils/urlChecks';\nimport { useDefaultActiveTokens } from './Tokens';\nimport { useTokenContractsConstant } from './useTokenContractsConstant';\nfunction getUniqueAddressesFromPositions(positions) {\n  return Array.from(new Set(positions.reduce((acc, position) => acc.concat(position.token0, position.token1), [])));\n}\n/*\n * This function is an attempt to filter out an observed phishing attack from LP list UIs.\n * Attackers would airdrop valueless LP positions with urls in the symbol to render phishing sites into users' LP position list view.\n *\n * Our approach to filtering these out without naively prohibiting all valid URL symbols is to:\n * 1. allow any pair if both tokens are in the supported list\n * 2. allow one url if one token is in the supported list\n * 3. allow no urls if neither token is in the supported list\n *\n * The hope is that this approach removes the cheapest version of the attack without punishing non-malicious url symbols\n */\nexport function useFilterPossiblyMaliciousPositions(positions) {\n  _s();\n  const activeTokensList = useDefaultActiveTokens();\n  const nonListPositionTokenAddresses = useMemo(() => getUniqueAddressesFromPositions(positions).filter(address => !activeTokensList[address]), [positions, activeTokensList]);\n  const symbolCallStates = useTokenContractsConstant(nonListPositionTokenAddresses, 'symbol');\n  const addressesToSymbol = useMemo(() => {\n    const result = {};\n    for (let i = 0; i < nonListPositionTokenAddresses.length; i++) {\n      const callResult = symbolCallStates[i].result;\n      if (!callResult) continue;\n      const address = nonListPositionTokenAddresses[i];\n      result[address] = callResult;\n    }\n    return result;\n  }, [nonListPositionTokenAddresses, symbolCallStates]);\n  return useMemo(() => positions.filter(position => {\n    var _token0FromList$symbo, _token1FromList$symbo;\n    let tokensInListCount = 0;\n    const token0FromList = activeTokensList[position.token0];\n    const token1FromList = activeTokensList[position.token1];\n    if (token0FromList) tokensInListCount++;\n    if (token1FromList) tokensInListCount++;\n    // if both tokens are in the list, then we let both have url symbols (so we don't check)\n    if (tokensInListCount === 2) return true;\n\n    // check the token symbols to see if they contain a url\n    // prioritize the token entity from the list if it exists\n    // if the token isn't in the list, then use the data returned from chain calls\n    let urlSymbolCount = 0;\n    if (hasURL((_token0FromList$symbo = token0FromList === null || token0FromList === void 0 ? void 0 : token0FromList.symbol) !== null && _token0FromList$symbo !== void 0 ? _token0FromList$symbo : addressesToSymbol[position.token0])) urlSymbolCount++;\n    if (hasURL((_token1FromList$symbo = token1FromList === null || token1FromList === void 0 ? void 0 : token1FromList.symbol) !== null && _token1FromList$symbo !== void 0 ? _token1FromList$symbo : addressesToSymbol[position.token1])) urlSymbolCount++;\n    // if one token is in the list, then one token can have a url symbol\n    if (tokensInListCount === 1 && urlSymbolCount < 2) return true;\n\n    // if neither token is in the list, then neither can have a url symbol\n    return urlSymbolCount === 0;\n  }), [addressesToSymbol, positions, activeTokensList]);\n}\n_s(useFilterPossiblyMaliciousPositions, \"H50MegnXeVU6dGo1SztH1VefLsA=\", false, function () {\n  return [useDefaultActiveTokens, useTokenContractsConstant];\n});","map":{"version":3,"names":["useMemo","hasURL","useDefaultActiveTokens","useTokenContractsConstant","getUniqueAddressesFromPositions","positions","Array","from","Set","reduce","acc","position","concat","token0","token1","useFilterPossiblyMaliciousPositions","activeTokensList","nonListPositionTokenAddresses","filter","address","symbolCallStates","addressesToSymbol","result","i","length","callResult","tokensInListCount","token0FromList","token1FromList","urlSymbolCount","symbol"],"sources":["/home/diep/freelance/interface/src/hooks/useFilterPossiblyMaliciousPositions.ts"],"sourcesContent":["import { Token } from '@uniswap/sdk-core'\nimport { useMemo } from 'react'\nimport { PositionDetails } from 'types/position'\nimport { hasURL } from 'utils/urlChecks'\n\nimport { useDefaultActiveTokens } from './Tokens'\nimport { useTokenContractsConstant } from './useTokenContractsConstant'\n\nfunction getUniqueAddressesFromPositions(positions: PositionDetails[]): string[] {\n  return Array.from(\n    new Set(positions.reduce<string[]>((acc, position) => acc.concat(position.token0, position.token1), []))\n  )\n}\n/*\n * This function is an attempt to filter out an observed phishing attack from LP list UIs.\n * Attackers would airdrop valueless LP positions with urls in the symbol to render phishing sites into users' LP position list view.\n *\n * Our approach to filtering these out without naively prohibiting all valid URL symbols is to:\n * 1. allow any pair if both tokens are in the supported list\n * 2. allow one url if one token is in the supported list\n * 3. allow no urls if neither token is in the supported list\n *\n * The hope is that this approach removes the cheapest version of the attack without punishing non-malicious url symbols\n */\nexport function useFilterPossiblyMaliciousPositions(positions: PositionDetails[]): PositionDetails[] {\n  const activeTokensList = useDefaultActiveTokens()\n\n  const nonListPositionTokenAddresses = useMemo(\n    () => getUniqueAddressesFromPositions(positions).filter((address) => !activeTokensList[address]),\n    [positions, activeTokensList]\n  )\n\n  const symbolCallStates = useTokenContractsConstant(nonListPositionTokenAddresses, 'symbol')\n\n  const addressesToSymbol: Record<string, string> = useMemo(() => {\n    const result: Record<string, string> = {}\n    for (let i = 0; i < nonListPositionTokenAddresses.length; i++) {\n      const callResult = symbolCallStates[i].result\n      if (!callResult) continue\n      const address = nonListPositionTokenAddresses[i]\n      result[address] = callResult as unknown as string\n    }\n    return result\n  }, [nonListPositionTokenAddresses, symbolCallStates])\n\n  return useMemo(\n    () =>\n      positions.filter((position) => {\n        let tokensInListCount = 0\n        const token0FromList = activeTokensList[position.token0] as Token | undefined\n        const token1FromList = activeTokensList[position.token1] as Token | undefined\n        if (token0FromList) tokensInListCount++\n        if (token1FromList) tokensInListCount++\n        // if both tokens are in the list, then we let both have url symbols (so we don't check)\n        if (tokensInListCount === 2) return true\n\n        // check the token symbols to see if they contain a url\n        // prioritize the token entity from the list if it exists\n        // if the token isn't in the list, then use the data returned from chain calls\n        let urlSymbolCount = 0\n        if (hasURL(token0FromList?.symbol ?? addressesToSymbol[position.token0])) urlSymbolCount++\n        if (hasURL(token1FromList?.symbol ?? addressesToSymbol[position.token1])) urlSymbolCount++\n        // if one token is in the list, then one token can have a url symbol\n        if (tokensInListCount === 1 && urlSymbolCount < 2) return true\n\n        // if neither token is in the list, then neither can have a url symbol\n        return urlSymbolCount === 0\n      }),\n    [addressesToSymbol, positions, activeTokensList]\n  )\n}\n"],"mappings":";AACA,SAASA,OAAO,QAAQ,OAAO;AAE/B,SAASC,MAAM,QAAQ,iBAAiB;AAExC,SAASC,sBAAsB,QAAQ,UAAU;AACjD,SAASC,yBAAyB,QAAQ,6BAA6B;AAEvE,SAASC,+BAA+B,CAACC,SAA4B,EAAY;EAC/E,OAAOC,KAAK,CAACC,IAAI,CACf,IAAIC,GAAG,CAACH,SAAS,CAACI,MAAM,CAAW,CAACC,GAAG,EAAEC,QAAQ,KAAKD,GAAG,CAACE,MAAM,CAACD,QAAQ,CAACE,MAAM,EAAEF,QAAQ,CAACG,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,CACzG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,mCAAmC,CAACV,SAA4B,EAAqB;EAAA;EACnG,MAAMW,gBAAgB,GAAGd,sBAAsB,EAAE;EAEjD,MAAMe,6BAA6B,GAAGjB,OAAO,CAC3C,MAAMI,+BAA+B,CAACC,SAAS,CAAC,CAACa,MAAM,CAAEC,OAAO,IAAK,CAACH,gBAAgB,CAACG,OAAO,CAAC,CAAC,EAChG,CAACd,SAAS,EAAEW,gBAAgB,CAAC,CAC9B;EAED,MAAMI,gBAAgB,GAAGjB,yBAAyB,CAACc,6BAA6B,EAAE,QAAQ,CAAC;EAE3F,MAAMI,iBAAyC,GAAGrB,OAAO,CAAC,MAAM;IAC9D,MAAMsB,MAA8B,GAAG,CAAC,CAAC;IACzC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,6BAA6B,CAACO,MAAM,EAAED,CAAC,EAAE,EAAE;MAC7D,MAAME,UAAU,GAAGL,gBAAgB,CAACG,CAAC,CAAC,CAACD,MAAM;MAC7C,IAAI,CAACG,UAAU,EAAE;MACjB,MAAMN,OAAO,GAAGF,6BAA6B,CAACM,CAAC,CAAC;MAChDD,MAAM,CAACH,OAAO,CAAC,GAAGM,UAA+B;IACnD;IACA,OAAOH,MAAM;EACf,CAAC,EAAE,CAACL,6BAA6B,EAAEG,gBAAgB,CAAC,CAAC;EAErD,OAAOpB,OAAO,CACZ,MACEK,SAAS,CAACa,MAAM,CAAEP,QAAQ,IAAK;IAAA;IAC7B,IAAIe,iBAAiB,GAAG,CAAC;IACzB,MAAMC,cAAc,GAAGX,gBAAgB,CAACL,QAAQ,CAACE,MAAM,CAAsB;IAC7E,MAAMe,cAAc,GAAGZ,gBAAgB,CAACL,QAAQ,CAACG,MAAM,CAAsB;IAC7E,IAAIa,cAAc,EAAED,iBAAiB,EAAE;IACvC,IAAIE,cAAc,EAAEF,iBAAiB,EAAE;IACvC;IACA,IAAIA,iBAAiB,KAAK,CAAC,EAAE,OAAO,IAAI;;IAExC;IACA;IACA;IACA,IAAIG,cAAc,GAAG,CAAC;IACtB,IAAI5B,MAAM,0BAAC0B,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEG,MAAM,yEAAIT,iBAAiB,CAACV,QAAQ,CAACE,MAAM,CAAC,CAAC,EAAEgB,cAAc,EAAE;IAC1F,IAAI5B,MAAM,0BAAC2B,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEE,MAAM,yEAAIT,iBAAiB,CAACV,QAAQ,CAACG,MAAM,CAAC,CAAC,EAAEe,cAAc,EAAE;IAC1F;IACA,IAAIH,iBAAiB,KAAK,CAAC,IAAIG,cAAc,GAAG,CAAC,EAAE,OAAO,IAAI;;IAE9D;IACA,OAAOA,cAAc,KAAK,CAAC;EAC7B,CAAC,CAAC,EACJ,CAACR,iBAAiB,EAAEhB,SAAS,EAAEW,gBAAgB,CAAC,CACjD;AACH;AAAC,GA9CeD,mCAAmC;EAAA,QACxBb,sBAAsB,EAOtBC,yBAAyB;AAAA"},"metadata":{},"sourceType":"module"}