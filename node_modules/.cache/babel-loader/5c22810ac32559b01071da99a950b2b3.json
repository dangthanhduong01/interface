{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\nimport { nearestUsableTick, Pool, TICK_SPACINGS, tickToPrice } from '@uniswap/v3-sdk';\nimport { useWeb3React } from '@web3-react/core';\nimport { SupportedChainId } from 'constants/chains';\nimport { ZERO_ADDRESS } from 'constants/misc';\nimport { useAllV3TicksQuery } from 'graphql/thegraph/__generated__/types-and-hooks';\nimport { apolloClient } from 'graphql/thegraph/apollo';\nimport JSBI from 'jsbi';\nimport { useSingleContractMultipleData } from 'lib/hooks/multicall';\nimport { useEffect, useMemo, useState } from 'react';\nimport computeSurroundingTicks from 'utils/computeSurroundingTicks';\nimport { V3_CORE_FACTORY_ADDRESSES } from '../constants/addresses';\nimport { useTickLens } from './useContract';\nimport { PoolState, usePool } from './usePools';\nconst PRICE_FIXED_DIGITS = 8;\nconst CHAIN_IDS_MISSING_SUBGRAPH_DATA = [SupportedChainId.ARBITRUM_ONE, SupportedChainId.ARBITRUM_GOERLI];\n\n// Tick with fields parsed to JSBIs, and active liquidity computed.\n\nconst REFRESH_FREQUENCY = {\n  blocksPerFetch: 2\n};\nconst getActiveTick = (tickCurrent, feeAmount) => tickCurrent && feeAmount ? Math.floor(tickCurrent / TICK_SPACINGS[feeAmount]) * TICK_SPACINGS[feeAmount] : undefined;\nconst bitmapIndex = (tick, tickSpacing) => {\n  return Math.floor(tick / tickSpacing / 256);\n};\nfunction useTicksFromTickLens(currencyA, currencyB, feeAmount) {\n  _s();\n  let numSurroundingTicks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 125;\n  const [tickDataLatestSynced, setTickDataLatestSynced] = useState([]);\n  const [poolState, pool] = usePool(currencyA, currencyB, feeAmount);\n  const tickSpacing = feeAmount && TICK_SPACINGS[feeAmount];\n\n  // Find nearest valid tick for pool in case tick is not initialized.\n  const activeTick = (pool === null || pool === void 0 ? void 0 : pool.tickCurrent) && tickSpacing ? nearestUsableTick(pool === null || pool === void 0 ? void 0 : pool.tickCurrent, tickSpacing) : undefined;\n  const {\n    chainId\n  } = useWeb3React();\n  const poolAddress = currencyA && currencyB && feeAmount && poolState === PoolState.EXISTS ? Pool.getAddress(currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped, feeAmount, undefined, chainId ? V3_CORE_FACTORY_ADDRESSES[chainId] : undefined) : undefined;\n\n  // it is also possible to grab all tick data but it is extremely slow\n  // bitmapIndex(nearestUsableTick(TickMath.MIN_TICK, tickSpacing), tickSpacing)\n  const minIndex = useMemo(() => tickSpacing && activeTick ? bitmapIndex(activeTick - numSurroundingTicks * tickSpacing, tickSpacing) : undefined, [tickSpacing, activeTick, numSurroundingTicks]);\n  const maxIndex = useMemo(() => tickSpacing && activeTick ? bitmapIndex(activeTick + numSurroundingTicks * tickSpacing, tickSpacing) : undefined, [tickSpacing, activeTick, numSurroundingTicks]);\n  const tickLensArgs = useMemo(() => maxIndex && minIndex && poolAddress && poolAddress !== ZERO_ADDRESS ? new Array(maxIndex - minIndex + 1).fill(0).map((_, i) => i + minIndex).map(wordIndex => [poolAddress, wordIndex]) : [], [minIndex, maxIndex, poolAddress]);\n  const tickLens = useTickLens();\n  const callStates = useSingleContractMultipleData(tickLensArgs.length > 0 ? tickLens : undefined, 'getPopulatedTicksInWord', tickLensArgs, REFRESH_FREQUENCY);\n  const isError = useMemo(() => callStates.some(_ref => {\n    let {\n      error\n    } = _ref;\n    return error;\n  }), [callStates]);\n  const isLoading = useMemo(() => callStates.some(_ref2 => {\n    let {\n      loading\n    } = _ref2;\n    return loading;\n  }), [callStates]);\n  const IsSyncing = useMemo(() => callStates.some(_ref3 => {\n    let {\n      syncing\n    } = _ref3;\n    return syncing;\n  }), [callStates]);\n  const isValid = useMemo(() => callStates.some(_ref4 => {\n    let {\n      valid\n    } = _ref4;\n    return valid;\n  }), [callStates]);\n  const tickData = useMemo(() => callStates.map(_ref5 => {\n    let {\n      result\n    } = _ref5;\n    return result === null || result === void 0 ? void 0 : result.populatedTicks;\n  }).reduce((accumulator, current) => {\n    var _current$map;\n    return [...accumulator, ...((_current$map = current === null || current === void 0 ? void 0 : current.map(tickData => {\n      return {\n        tick: tickData.tick,\n        liquidityNet: JSBI.BigInt(tickData.liquidityNet)\n      };\n    })) !== null && _current$map !== void 0 ? _current$map : [])];\n  }, []), [callStates]);\n\n  // reset on input change\n  useEffect(() => {\n    setTickDataLatestSynced([]);\n  }, [currencyA, currencyB, feeAmount]);\n\n  // return the latest synced tickData even if we are still loading the newest data\n  useEffect(() => {\n    if (!IsSyncing && !isLoading && !isError && isValid) {\n      setTickDataLatestSynced(tickData.sort((a, b) => a.tick - b.tick));\n    }\n  }, [isError, isLoading, IsSyncing, tickData, isValid]);\n  return useMemo(() => ({\n    isLoading,\n    IsSyncing,\n    isError,\n    isValid,\n    tickData: tickDataLatestSynced\n  }), [isLoading, IsSyncing, isError, isValid, tickDataLatestSynced]);\n}\n_s(useTicksFromTickLens, \"KNoxVHsj5dAUNAeqcEjzxEKDUOg=\", false, function () {\n  return [usePool, useWeb3React, useTickLens, useSingleContractMultipleData];\n});\nfunction useTicksFromSubgraph(currencyA, currencyB, feeAmount) {\n  _s2();\n  let skip = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  const {\n    chainId\n  } = useWeb3React();\n  const poolAddress = currencyA && currencyB && feeAmount ? Pool.getAddress(currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped, feeAmount, undefined, chainId ? V3_CORE_FACTORY_ADDRESSES[chainId] : undefined) : undefined;\n  return useAllV3TicksQuery({\n    variables: {\n      poolAddress: poolAddress === null || poolAddress === void 0 ? void 0 : poolAddress.toLowerCase(),\n      skip\n    },\n    skip: !poolAddress,\n    pollInterval: 30000,\n    client: apolloClient\n  });\n}\n_s2(useTicksFromSubgraph, \"SK46pRsXXxTNUdE3xkwwexqHlQM=\", false, function () {\n  return [useWeb3React, useAllV3TicksQuery];\n});\nconst MAX_THE_GRAPH_TICK_FETCH_VALUE = 1000;\n// Fetches all ticks for a given pool\nfunction useAllV3Ticks(currencyA, currencyB, feeAmount) {\n  _s3();\n  const useSubgraph = currencyA ? !CHAIN_IDS_MISSING_SUBGRAPH_DATA.includes(currencyA.chainId) : true;\n  const tickLensTickData = useTicksFromTickLens(!useSubgraph ? currencyA : undefined, currencyB, feeAmount);\n  const [skipNumber, setSkipNumber] = useState(0);\n  const [subgraphTickData, setSubgraphTickData] = useState([]);\n  const {\n    data,\n    error,\n    loading: isLoading\n  } = useTicksFromSubgraph(useSubgraph ? currencyA : undefined, currencyB, feeAmount, skipNumber);\n  useEffect(() => {\n    if (data === null || data === void 0 ? void 0 : data.ticks.length) {\n      setSubgraphTickData(tickData => [...tickData, ...data.ticks]);\n      if (data.ticks.length === MAX_THE_GRAPH_TICK_FETCH_VALUE) {\n        setSkipNumber(skipNumber => skipNumber + MAX_THE_GRAPH_TICK_FETCH_VALUE);\n      }\n    }\n  }, [data === null || data === void 0 ? void 0 : data.ticks]);\n  return {\n    isLoading: useSubgraph ? isLoading || (data === null || data === void 0 ? void 0 : data.ticks.length) === MAX_THE_GRAPH_TICK_FETCH_VALUE : tickLensTickData.isLoading,\n    error: useSubgraph ? error : tickLensTickData.isError,\n    ticks: useSubgraph ? subgraphTickData : tickLensTickData.tickData\n  };\n}\n_s3(useAllV3Ticks, \"zOsIRNT5C0jAtK9rsYz+ItJvBw4=\", false, function () {\n  return [useTicksFromTickLens, useTicksFromSubgraph];\n});\nexport function usePoolActiveLiquidity(currencyA, currencyB, feeAmount) {\n  _s4();\n  const pool = usePool(currencyA, currencyB, feeAmount);\n\n  // Find nearest valid tick for pool in case tick is not initialized.\n  const activeTick = useMemo(() => {\n    var _pool$;\n    return getActiveTick((_pool$ = pool[1]) === null || _pool$ === void 0 ? void 0 : _pool$.tickCurrent, feeAmount);\n  }, [pool, feeAmount]);\n  const {\n    isLoading,\n    error,\n    ticks\n  } = useAllV3Ticks(currencyA, currencyB, feeAmount);\n  return useMemo(() => {\n    var _pool$1$liquidity, _pool$2;\n    if (!currencyA || !currencyB || activeTick === undefined || pool[0] !== PoolState.EXISTS || !ticks || ticks.length === 0 || isLoading) {\n      return {\n        isLoading: isLoading || pool[0] === PoolState.LOADING,\n        error,\n        activeTick,\n        data: undefined\n      };\n    }\n    const token0 = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped;\n    const token1 = currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped;\n\n    // find where the active tick would be to partition the array\n    // if the active tick is initialized, the pivot will be an element\n    // if not, take the previous tick as pivot\n    const pivot = ticks.findIndex(_ref6 => {\n      let {\n        tick\n      } = _ref6;\n      return tick > activeTick;\n    }) - 1;\n    if (pivot < 0) {\n      // consider setting a local error\n      console.error('TickData pivot not found');\n      return {\n        isLoading,\n        error,\n        activeTick,\n        data: undefined\n      };\n    }\n    const activeTickProcessed = {\n      liquidityActive: JSBI.BigInt((_pool$1$liquidity = (_pool$2 = pool[1]) === null || _pool$2 === void 0 ? void 0 : _pool$2.liquidity) !== null && _pool$1$liquidity !== void 0 ? _pool$1$liquidity : 0),\n      tick: activeTick,\n      liquidityNet: Number(ticks[pivot].tick) === activeTick ? JSBI.BigInt(ticks[pivot].liquidityNet) : JSBI.BigInt(0),\n      price0: tickToPrice(token0, token1, activeTick).toFixed(PRICE_FIXED_DIGITS)\n    };\n    const subsequentTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, true);\n    const previousTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, false);\n    const ticksProcessed = previousTicks.concat(activeTickProcessed).concat(subsequentTicks);\n    return {\n      isLoading,\n      error,\n      activeTick,\n      data: ticksProcessed\n    };\n  }, [currencyA, currencyB, activeTick, pool, ticks, isLoading, error]);\n}\n_s4(usePoolActiveLiquidity, \"zQbOlRypv5eqBNdV22MZ5kTxcbU=\", false, function () {\n  return [usePool, useAllV3Ticks];\n});","map":{"version":3,"names":["nearestUsableTick","Pool","TICK_SPACINGS","tickToPrice","useWeb3React","SupportedChainId","ZERO_ADDRESS","useAllV3TicksQuery","apolloClient","JSBI","useSingleContractMultipleData","useEffect","useMemo","useState","computeSurroundingTicks","V3_CORE_FACTORY_ADDRESSES","useTickLens","PoolState","usePool","PRICE_FIXED_DIGITS","CHAIN_IDS_MISSING_SUBGRAPH_DATA","ARBITRUM_ONE","ARBITRUM_GOERLI","REFRESH_FREQUENCY","blocksPerFetch","getActiveTick","tickCurrent","feeAmount","Math","floor","undefined","bitmapIndex","tick","tickSpacing","useTicksFromTickLens","currencyA","currencyB","numSurroundingTicks","tickDataLatestSynced","setTickDataLatestSynced","poolState","pool","activeTick","chainId","poolAddress","EXISTS","getAddress","wrapped","minIndex","maxIndex","tickLensArgs","Array","fill","map","_","i","wordIndex","tickLens","callStates","length","isError","some","error","isLoading","loading","IsSyncing","syncing","isValid","valid","tickData","result","populatedTicks","reduce","accumulator","current","liquidityNet","BigInt","sort","a","b","useTicksFromSubgraph","skip","variables","toLowerCase","pollInterval","client","MAX_THE_GRAPH_TICK_FETCH_VALUE","useAllV3Ticks","useSubgraph","includes","tickLensTickData","skipNumber","setSkipNumber","subgraphTickData","setSubgraphTickData","data","ticks","usePoolActiveLiquidity","LOADING","token0","token1","pivot","findIndex","console","activeTickProcessed","liquidityActive","liquidity","Number","price0","toFixed","subsequentTicks","previousTicks","ticksProcessed","concat"],"sources":["/home/diep/freelance/interface/src/hooks/usePoolTickData.ts"],"sourcesContent":["import { Currency } from '@uniswap/sdk-core'\nimport { FeeAmount, nearestUsableTick, Pool, TICK_SPACINGS, tickToPrice } from '@uniswap/v3-sdk'\nimport { useWeb3React } from '@web3-react/core'\nimport { SupportedChainId } from 'constants/chains'\nimport { ZERO_ADDRESS } from 'constants/misc'\nimport { useAllV3TicksQuery } from 'graphql/thegraph/__generated__/types-and-hooks'\nimport { TickData, Ticks } from 'graphql/thegraph/AllV3TicksQuery'\nimport { apolloClient } from 'graphql/thegraph/apollo'\nimport JSBI from 'jsbi'\nimport { useSingleContractMultipleData } from 'lib/hooks/multicall'\nimport ms from 'ms.macro'\nimport { useEffect, useMemo, useState } from 'react'\nimport computeSurroundingTicks from 'utils/computeSurroundingTicks'\n\nimport { V3_CORE_FACTORY_ADDRESSES } from '../constants/addresses'\nimport { useTickLens } from './useContract'\nimport { PoolState, usePool } from './usePools'\n\nconst PRICE_FIXED_DIGITS = 8\nconst CHAIN_IDS_MISSING_SUBGRAPH_DATA = [SupportedChainId.ARBITRUM_ONE, SupportedChainId.ARBITRUM_GOERLI]\n\n// Tick with fields parsed to JSBIs, and active liquidity computed.\nexport interface TickProcessed {\n  tick: number\n  liquidityActive: JSBI\n  liquidityNet: JSBI\n  price0: string\n}\n\nconst REFRESH_FREQUENCY = { blocksPerFetch: 2 }\n\nconst getActiveTick = (tickCurrent: number | undefined, feeAmount: FeeAmount | undefined) =>\n  tickCurrent && feeAmount ? Math.floor(tickCurrent / TICK_SPACINGS[feeAmount]) * TICK_SPACINGS[feeAmount] : undefined\n\nconst bitmapIndex = (tick: number, tickSpacing: number) => {\n  return Math.floor(tick / tickSpacing / 256)\n}\n\nfunction useTicksFromTickLens(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined,\n  numSurroundingTicks: number | undefined = 125\n) {\n  const [tickDataLatestSynced, setTickDataLatestSynced] = useState<TickData[]>([])\n\n  const [poolState, pool] = usePool(currencyA, currencyB, feeAmount)\n\n  const tickSpacing = feeAmount && TICK_SPACINGS[feeAmount]\n\n  // Find nearest valid tick for pool in case tick is not initialized.\n  const activeTick = pool?.tickCurrent && tickSpacing ? nearestUsableTick(pool?.tickCurrent, tickSpacing) : undefined\n\n  const { chainId } = useWeb3React()\n\n  const poolAddress =\n    currencyA && currencyB && feeAmount && poolState === PoolState.EXISTS\n      ? Pool.getAddress(\n          currencyA?.wrapped,\n          currencyB?.wrapped,\n          feeAmount,\n          undefined,\n          chainId ? V3_CORE_FACTORY_ADDRESSES[chainId] : undefined\n        )\n      : undefined\n\n  // it is also possible to grab all tick data but it is extremely slow\n  // bitmapIndex(nearestUsableTick(TickMath.MIN_TICK, tickSpacing), tickSpacing)\n  const minIndex = useMemo(\n    () =>\n      tickSpacing && activeTick ? bitmapIndex(activeTick - numSurroundingTicks * tickSpacing, tickSpacing) : undefined,\n    [tickSpacing, activeTick, numSurroundingTicks]\n  )\n\n  const maxIndex = useMemo(\n    () =>\n      tickSpacing && activeTick ? bitmapIndex(activeTick + numSurroundingTicks * tickSpacing, tickSpacing) : undefined,\n    [tickSpacing, activeTick, numSurroundingTicks]\n  )\n\n  const tickLensArgs: [string, number][] = useMemo(\n    () =>\n      maxIndex && minIndex && poolAddress && poolAddress !== ZERO_ADDRESS\n        ? new Array(maxIndex - minIndex + 1)\n            .fill(0)\n            .map((_, i) => i + minIndex)\n            .map((wordIndex) => [poolAddress, wordIndex])\n        : [],\n    [minIndex, maxIndex, poolAddress]\n  )\n\n  const tickLens = useTickLens()\n  const callStates = useSingleContractMultipleData(\n    tickLensArgs.length > 0 ? tickLens : undefined,\n    'getPopulatedTicksInWord',\n    tickLensArgs,\n    REFRESH_FREQUENCY\n  )\n\n  const isError = useMemo(() => callStates.some(({ error }) => error), [callStates])\n  const isLoading = useMemo(() => callStates.some(({ loading }) => loading), [callStates])\n  const IsSyncing = useMemo(() => callStates.some(({ syncing }) => syncing), [callStates])\n  const isValid = useMemo(() => callStates.some(({ valid }) => valid), [callStates])\n\n  const tickData: TickData[] = useMemo(\n    () =>\n      callStates\n        .map(({ result }) => result?.populatedTicks)\n        .reduce(\n          (accumulator, current) => [\n            ...accumulator,\n            ...(current?.map((tickData: TickData) => {\n              return {\n                tick: tickData.tick,\n                liquidityNet: JSBI.BigInt(tickData.liquidityNet),\n              }\n            }) ?? []),\n          ],\n          []\n        ),\n    [callStates]\n  )\n\n  // reset on input change\n  useEffect(() => {\n    setTickDataLatestSynced([])\n  }, [currencyA, currencyB, feeAmount])\n\n  // return the latest synced tickData even if we are still loading the newest data\n  useEffect(() => {\n    if (!IsSyncing && !isLoading && !isError && isValid) {\n      setTickDataLatestSynced(tickData.sort((a, b) => a.tick - b.tick))\n    }\n  }, [isError, isLoading, IsSyncing, tickData, isValid])\n\n  return useMemo(\n    () => ({ isLoading, IsSyncing, isError, isValid, tickData: tickDataLatestSynced }),\n    [isLoading, IsSyncing, isError, isValid, tickDataLatestSynced]\n  )\n}\n\nfunction useTicksFromSubgraph(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined,\n  skip = 0\n) {\n  const { chainId } = useWeb3React()\n  const poolAddress =\n    currencyA && currencyB && feeAmount\n      ? Pool.getAddress(\n          currencyA?.wrapped,\n          currencyB?.wrapped,\n          feeAmount,\n          undefined,\n          chainId ? V3_CORE_FACTORY_ADDRESSES[chainId] : undefined\n        )\n      : undefined\n\n  return useAllV3TicksQuery({\n    variables: { poolAddress: poolAddress?.toLowerCase(), skip },\n    skip: !poolAddress,\n    pollInterval: ms`30s`,\n    client: apolloClient,\n  })\n}\n\nconst MAX_THE_GRAPH_TICK_FETCH_VALUE = 1000\n// Fetches all ticks for a given pool\nfunction useAllV3Ticks(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined\n): {\n  isLoading: boolean\n  error: unknown\n  ticks: TickData[] | undefined\n} {\n  const useSubgraph = currencyA ? !CHAIN_IDS_MISSING_SUBGRAPH_DATA.includes(currencyA.chainId) : true\n\n  const tickLensTickData = useTicksFromTickLens(!useSubgraph ? currencyA : undefined, currencyB, feeAmount)\n\n  const [skipNumber, setSkipNumber] = useState(0)\n  const [subgraphTickData, setSubgraphTickData] = useState<Ticks>([])\n  const {\n    data,\n    error,\n    loading: isLoading,\n  } = useTicksFromSubgraph(useSubgraph ? currencyA : undefined, currencyB, feeAmount, skipNumber)\n\n  useEffect(() => {\n    if (data?.ticks.length) {\n      setSubgraphTickData((tickData) => [...tickData, ...data.ticks])\n      if (data.ticks.length === MAX_THE_GRAPH_TICK_FETCH_VALUE) {\n        setSkipNumber((skipNumber) => skipNumber + MAX_THE_GRAPH_TICK_FETCH_VALUE)\n      }\n    }\n  }, [data?.ticks])\n\n  return {\n    isLoading: useSubgraph\n      ? isLoading || data?.ticks.length === MAX_THE_GRAPH_TICK_FETCH_VALUE\n      : tickLensTickData.isLoading,\n    error: useSubgraph ? error : tickLensTickData.isError,\n    ticks: useSubgraph ? subgraphTickData : tickLensTickData.tickData,\n  }\n}\n\nexport function usePoolActiveLiquidity(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined\n): {\n  isLoading: boolean\n  error: any\n  activeTick: number | undefined\n  data: TickProcessed[] | undefined\n} {\n  const pool = usePool(currencyA, currencyB, feeAmount)\n\n  // Find nearest valid tick for pool in case tick is not initialized.\n  const activeTick = useMemo(() => getActiveTick(pool[1]?.tickCurrent, feeAmount), [pool, feeAmount])\n\n  const { isLoading, error, ticks } = useAllV3Ticks(currencyA, currencyB, feeAmount)\n\n  return useMemo(() => {\n    if (\n      !currencyA ||\n      !currencyB ||\n      activeTick === undefined ||\n      pool[0] !== PoolState.EXISTS ||\n      !ticks ||\n      ticks.length === 0 ||\n      isLoading\n    ) {\n      return {\n        isLoading: isLoading || pool[0] === PoolState.LOADING,\n        error,\n        activeTick,\n        data: undefined,\n      }\n    }\n\n    const token0 = currencyA?.wrapped\n    const token1 = currencyB?.wrapped\n\n    // find where the active tick would be to partition the array\n    // if the active tick is initialized, the pivot will be an element\n    // if not, take the previous tick as pivot\n    const pivot = ticks.findIndex(({ tick }) => tick > activeTick) - 1\n\n    if (pivot < 0) {\n      // consider setting a local error\n      console.error('TickData pivot not found')\n      return {\n        isLoading,\n        error,\n        activeTick,\n        data: undefined,\n      }\n    }\n\n    const activeTickProcessed: TickProcessed = {\n      liquidityActive: JSBI.BigInt(pool[1]?.liquidity ?? 0),\n      tick: activeTick,\n      liquidityNet: Number(ticks[pivot].tick) === activeTick ? JSBI.BigInt(ticks[pivot].liquidityNet) : JSBI.BigInt(0),\n      price0: tickToPrice(token0, token1, activeTick).toFixed(PRICE_FIXED_DIGITS),\n    }\n\n    const subsequentTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, true)\n\n    const previousTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, false)\n\n    const ticksProcessed = previousTicks.concat(activeTickProcessed).concat(subsequentTicks)\n\n    return {\n      isLoading,\n      error,\n      activeTick,\n      data: ticksProcessed,\n    }\n  }, [currencyA, currencyB, activeTick, pool, ticks, isLoading, error])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}