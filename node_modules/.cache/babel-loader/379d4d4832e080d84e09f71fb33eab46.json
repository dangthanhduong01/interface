{"ast":null,"code":"import { getCurrentHub, getMainCarrier } from '@sentry/core';\nimport { logger, uuid4 } from '@sentry/utils';\nimport { WINDOW } from '../helpers.js';\nimport { sendProfile } from './sendProfile.js';\n\n// Max profile duration.\nconst MAX_PROFILE_DURATION_MS = 30000;\n// Keep a flag value to avoid re-initializing the profiler constructor. If it fails\n// once, it will always fail and this allows us to early return.\nlet PROFILING_CONSTRUCTOR_FAILED = false;\n\n// While we experiment, per transaction sampling interval will be more flexible to work with.\n\n/**\n * Check if profiler constructor is available.\n * @param maybeProfiler\n */\nfunction isJSProfilerSupported(maybeProfiler) {\n  return typeof maybeProfiler === 'function';\n}\n\n/**\n * Safety wrapper for startTransaction for the unlikely case that transaction starts before tracing is imported -\n * if that happens we want to avoid throwing an error from profiling code.\n * see https://github.com/getsentry/sentry-javascript/issues/4731.\n *\n * @experimental\n */\nfunction onProfilingStartRouteTransaction(transaction) {\n  if (!transaction) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] Transaction is undefined, skipping profiling');\n    }\n    return transaction;\n  }\n  return wrapTransactionWithProfiling(transaction);\n}\n\n/**\n * Wraps startTransaction and stopTransaction with profiling related logic.\n * startProfiling is called after the call to startTransaction in order to avoid our own code from\n * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n */\nfunction wrapTransactionWithProfiling(transaction) {\n  // Feature support check first\n  const JSProfilerConstructor = WINDOW.Profiler;\n  if (!isJSProfilerSupported(JSProfilerConstructor)) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.');\n    }\n    return transaction;\n  }\n\n  // profilesSampleRate is multiplied with tracesSampleRate to get the final sampling rate.\n  if (!transaction.sampled) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] Transaction is not sampled, skipping profiling');\n    }\n    return transaction;\n  }\n\n  // If constructor failed once, it will always fail, so we can early return.\n  if (PROFILING_CONSTRUCTOR_FAILED) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] Profiling has been disabled for the duration of the current user session.');\n    }\n    return transaction;\n  }\n  const client = getCurrentHub().getClient();\n  const options = client && client.getOptions();\n\n  // @ts-ignore not part of the browser options yet\n  const profilesSampleRate = options && options.profilesSampleRate || 0;\n  if (profilesSampleRate === undefined) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] Profiling disabled, enable it by setting `profilesSampleRate` option to SDK init call.');\n    }\n    return transaction;\n  }\n\n  // Check if we should sample this profile\n  if (Math.random() > profilesSampleRate) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] Skip profiling transaction due to sampling.');\n    }\n    return transaction;\n  }\n\n  // From initial testing, it seems that the minimum value for sampleInterval is 10ms.\n  const samplingIntervalMS = 10;\n  // Start the profiler\n  const maxSamples = Math.floor(MAX_PROFILE_DURATION_MS / samplingIntervalMS);\n  let profiler;\n\n  // Attempt to initialize the profiler constructor, if it fails, we disable profiling for the current user session.\n  // This is likely due to a missing 'Document-Policy': 'js-profiling' header. We do not want to throw an error if this happens\n  // as we risk breaking the user's application, so just disable profiling and log an error.\n  try {\n    profiler = new JSProfilerConstructor({\n      sampleInterval: samplingIntervalMS,\n      maxBufferSize: maxSamples\n    });\n  } catch (e) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log(\"[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header.\");\n      logger.log('[Profiling] Disabling profiling for current user session.');\n    }\n    PROFILING_CONSTRUCTOR_FAILED = true;\n  }\n\n  // We failed to construct the profiler, fallback to original transaction - there is no need to log\n  // anything as we already did that in the try/catch block.\n  if (!profiler) {\n    return transaction;\n  }\n  if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n    logger.log(`[Profiling] started profiling transaction: ${transaction.name || transaction.description}`);\n  }\n\n  // We create \"unique\" transaction names to avoid concurrent transactions with same names\n  // from being ignored by the profiler. From here on, only this transaction name should be used when\n  // calling the profiler methods. Note: we log the original name to the user to avoid confusion.\n  const profileId = uuid4();\n\n  // A couple of important things to note here:\n  // `CpuProfilerBindings.stopProfiling` will be scheduled to run in 30seconds in order to exceed max profile duration.\n  // Whichever of the two (transaction.finish/timeout) is first to run, the profiling will be stopped and the gathered profile\n  // will be processed when the original transaction is finished. Since onProfileHandler can be invoked multiple times in the\n  // event of an error or user mistake (calling transaction.finish multiple times), it is important that the behavior of onProfileHandler\n  // is idempotent as we do not want any timings or profiles to be overriden by the last call to onProfileHandler.\n  // After the original finish method is called, the event will be reported through the integration and delegated to transport.\n  let processedProfile = null;\n\n  /**\n   * Idempotent handler for profile stop\n   */\n  function onProfileHandler() {\n    // Check if the profile exists and return it the behavior has to be idempotent as users may call transaction.finish multiple times.\n    if (!transaction) {\n      return;\n    }\n    // Satisfy the type checker, but profiler will always be defined here.\n    if (!profiler) {\n      return;\n    }\n    if (processedProfile) {\n      if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n        logger.log('[Profiling] profile for:', transaction.name || transaction.description, 'already exists, returning early');\n      }\n      return;\n    }\n    profiler.stop().then(p => {\n      if (maxDurationTimeoutID) {\n        WINDOW.clearTimeout(maxDurationTimeoutID);\n        maxDurationTimeoutID = undefined;\n      }\n      if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n        logger.log(`[Profiling] stopped profiling of transaction: ${transaction.name || transaction.description}`);\n      }\n\n      // In case of an overlapping transaction, stopProfiling may return null and silently ignore the overlapping profile.\n      if (!p) {\n        if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n          logger.log(`[Profiling] profiler returned null profile for: ${transaction.name || transaction.description}`, 'this may indicate an overlapping transaction or a call to stopProfiling with a profile title that was never started');\n        }\n        return;\n      }\n\n      // If a profile has less than 2 samples, it is not useful and should be discarded.\n      if (p.samples.length < 2) {\n        return;\n      }\n      processedProfile = {\n        ...p,\n        profile_id: profileId\n      };\n      sendProfile(profileId, processedProfile);\n    }).catch(error => {\n      if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n        logger.log('[Profiling] error while stopping profiler:', error);\n      }\n      return null;\n    });\n  }\n\n  // Enqueue a timeout to prevent profiles from running over max duration.\n  let maxDurationTimeoutID = WINDOW.setTimeout(() => {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] max profile duration elapsed, stopping profiling for:', transaction.name || transaction.description);\n    }\n    void onProfileHandler();\n  }, MAX_PROFILE_DURATION_MS);\n\n  // We need to reference the original finish call to avoid creating an infinite loop\n  const originalFinish = transaction.finish.bind(transaction);\n\n  /**\n   * Wraps startTransaction and stopTransaction with profiling related logic.\n   * startProfiling is called after the call to startTransaction in order to avoid our own code from\n   * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n   */\n  function profilingWrappedTransactionFinish() {\n    if (!transaction) {\n      return originalFinish();\n    }\n    // onProfileHandler should always return the same profile even if this is called multiple times.\n    // Always call onProfileHandler to ensure stopProfiling is called and the timeout is cleared.\n    onProfileHandler();\n\n    // Set profile context\n    transaction.setContext('profile', {\n      profile_id: profileId\n    });\n    return originalFinish();\n  }\n  transaction.finish = profilingWrappedTransactionFinish;\n  return transaction;\n}\n\n/**\n * Wraps startTransaction with profiling logic. This is done automatically by the profiling integration.\n */\nfunction __PRIVATE__wrapStartTransactionWithProfiling(startTransaction) {\n  return function wrappedStartTransaction(transactionContext, customSamplingContext) {\n    const transaction = startTransaction.call(this, transactionContext, customSamplingContext);\n    if (transaction === undefined) {\n      if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n        logger.log('[Profiling] Transaction is undefined, skipping profiling');\n      }\n      return transaction;\n    }\n    return wrapTransactionWithProfiling(transaction);\n  };\n}\n\n/**\n * Patches startTransaction and stopTransaction with profiling logic.\n */\nfunction addProfilingExtensionMethods() {\n  const carrier = getMainCarrier();\n  if (!carrier.__SENTRY__) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log(\"[Profiling] Can't find main carrier, profiling won't work.\");\n    }\n    return;\n  }\n  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n  if (!carrier.__SENTRY__.extensions['startTransaction']) {\n    if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n      logger.log('[Profiling] startTransaction does not exists, profiling will not work. Make sure you import @sentry/tracing package before @sentry/profiling-node as import order matters.');\n    }\n    return;\n  }\n  if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n    logger.log('[Profiling] startTransaction exists, patching it with profiling functionality...');\n  }\n  carrier.__SENTRY__.extensions['startTransaction'] = __PRIVATE__wrapStartTransactionWithProfiling(\n  // This is already patched by sentry/tracing, we are going to re-patch it...\n  carrier.__SENTRY__.extensions['startTransaction']);\n}\nexport { addProfilingExtensionMethods, onProfilingStartRouteTransaction };","map":{"version":3,"sources":["../../../../src/profiling/hubextensions.ts"],"names":[],"mappings":";;;;;AAaA;AACA,MAAA,uBAAA,GAAA,KAAA;AACA;AACA;AACA,IAAA,4BAAA,GAAA,KAAA;;AAEA;;AAOA;AACA;AACA;AACA;AACA,SAAA,qBAAA,CAAA,aAAA,EAAA;EACA,OAAA,OAAA,aAAA,KAAA,UAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,gCAAA,CAAA,WAAA,EAAA;EACA,IAAA,CAAA,WAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CAAA,0DAAA,CAAA;IACA;IACA,OAAA,WAAA;EACA;EAEA,OAAA,4BAAA,CAAA,WAAA,CAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAA,4BAAA,CAAA,WAAA,EAAA;EACA;EACA,MAAA,qBAAA,GAAA,MAAA,CAAA,QAAA;EAEA,IAAA,CAAA,qBAAA,CAAA,qBAAA,CAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CACA,sGAAA,CACA;IACA;IACA,OAAA,WAAA;EACA;;EAEA;EACA,IAAA,CAAA,WAAA,CAAA,OAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CAAA,4DAAA,CAAA;IACA;IACA,OAAA,WAAA;EACA;;EAEA;EACA,IAAA,4BAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CAAA,uFAAA,CAAA;IACA;IACA,OAAA,WAAA;EACA;EAEA,MAAA,MAAA,GAAA,aAAA,EAAA,CAAA,SAAA,EAAA;EACA,MAAA,OAAA,GAAA,MAAA,IAAA,MAAA,CAAA,UAAA,EAAA;;EAEA;EACA,MAAA,kBAAA,GAAA,OAAA,IAAA,OAAA,CAAA,kBAAA,IAAA,CAAA;EACA,IAAA,kBAAA,KAAA,SAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CAAA,oGAAA,CAAA;IACA;IACA,OAAA,WAAA;EACA;;EAEA;EACA,IAAA,IAAA,CAAA,MAAA,EAAA,GAAA,kBAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CAAA,yDAAA,CAAA;IACA;IACA,OAAA,WAAA;EACA;;EAEA;EACA,MAAA,kBAAA,GAAA,EAAA;EACA;EACA,MAAA,UAAA,GAAA,IAAA,CAAA,KAAA,CAAA,uBAAA,GAAA,kBAAA,CAAA;EACA,IAAA,QAAA;;EAEA;EACA;EACA;EACA,IAAA;IACA,QAAA,GAAA,IAAA,qBAAA,CAAA;MAAA,cAAA,EAAA,kBAAA;MAAA,aAAA,EAAA;IAAA,CAAA,CAAA;EACA,CAAA,CAAA,OAAA,CAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CACA,uIAAA,CACA;MACA,MAAA,CAAA,GAAA,CAAA,2DAAA,CAAA;IACA;IACA,4BAAA,GAAA,IAAA;EACA;;EAEA;EACA;EACA,IAAA,CAAA,QAAA,EAAA;IACA,OAAA,WAAA;EACA;EAEA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;IACA,MAAA,CAAA,GAAA,CAAA,8CAAA,WAAA,CAAA,IAAA,IAAA,WAAA,CAAA,WAAA,EAAA,CAAA;EACA;;EAEA;EACA;EACA;EACA,MAAA,SAAA,GAAA,KAAA,EAAA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAA,gBAAA,GAAA,IAAA;;EAEA;AACA;AACA;EACA,SAAA,gBAAA,GAAA;IACA;IACA,IAAA,CAAA,WAAA,EAAA;MACA;IACA;IACA;IACA,IAAA,CAAA,QAAA,EAAA;MACA;IACA;IACA,IAAA,gBAAA,EAAA;MACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;QACA,MAAA,CAAA,GAAA,CACA,0BAAA,EACA,WAAA,CAAA,IAAA,IAAA,WAAA,CAAA,WAAA,EACA,iCAAA,CACA;MACA;MACA;IACA;IAEA,QAAA,CACA,IAAA,EAAA,CACA,IAAA,CAAA,CAAA,IAAA;MACA,IAAA,oBAAA,EAAA;QACA,MAAA,CAAA,YAAA,CAAA,oBAAA,CAAA;QACA,oBAAA,GAAA,SAAA;MACA;MAEA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;QACA,MAAA,CAAA,GAAA,CAAA,iDAAA,WAAA,CAAA,IAAA,IAAA,WAAA,CAAA,WAAA,EAAA,CAAA;MACA;;MAEA;MACA,IAAA,CAAA,CAAA,EAAA;QACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;UACA,MAAA,CAAA,GAAA,CACA,mDAAA,WAAA,CAAA,IAAA,IAAA,WAAA,CAAA,WAAA,EAAA,EACA,qHAAA,CACA;QACA;QACA;MACA;;MAEA;MACA,IAAA,CAAA,CAAA,OAAA,CAAA,MAAA,GAAA,CAAA,EAAA;QACA;MACA;MAEA,gBAAA,GAAA;QAAA,GAAA,CAAA;QAAA,UAAA,EAAA;MAAA,CAAA;MACA,WAAA,CAAA,SAAA,EAAA,gBAAA,CAAA;IACA,CAAA,CAAA,CACA,KAAA,CAAA,KAAA,IAAA;MACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;QACA,MAAA,CAAA,GAAA,CAAA,4CAAA,EAAA,KAAA,CAAA;MACA;MACA,OAAA,IAAA;IACA,CAAA,CAAA;EACA;;EAEA;EACA,IAAA,oBAAA,GAAA,MAAA,CAAA,UAAA,CAAA,MAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CACA,mEAAA,EACA,WAAA,CAAA,IAAA,IAAA,WAAA,CAAA,WAAA,CACA;IACA;IACA,KAAA,gBAAA,EAAA;EACA,CAAA,EAAA,uBAAA,CAAA;;EAEA;EACA,MAAA,cAAA,GAAA,WAAA,CAAA,MAAA,CAAA,IAAA,CAAA,WAAA,CAAA;;EAEA;AACA;AACA;AACA;AACA;EACA,SAAA,iCAAA,GAAA;IACA,IAAA,CAAA,WAAA,EAAA;MACA,OAAA,cAAA,EAAA;IACA;IACA;IACA;IACA,gBAAA,EAAA;;IAEA;IACA,WAAA,CAAA,UAAA,CAAA,SAAA,EAAA;MAAA,UAAA,EAAA;IAAA,CAAA,CAAA;IAEA,OAAA,cAAA,EAAA;EACA;EAEA,WAAA,CAAA,MAAA,GAAA,iCAAA;EACA,OAAA,WAAA;AACA;;AAEA;AACA;AACA;AACA,SAAA,4CAAA,CAAA,gBAAA,EAAA;EACA,OAAA,SAAA,uBAAA,CAEA,kBAAA,EACA,qBAAA,EACA;IACA,MAAA,WAAA,GAAA,gBAAA,CAAA,IAAA,CAAA,IAAA,EAAA,kBAAA,EAAA,qBAAA,CAAA;IACA,IAAA,WAAA,KAAA,SAAA,EAAA;MACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;QACA,MAAA,CAAA,GAAA,CAAA,0DAAA,CAAA;MACA;MACA,OAAA,WAAA;IACA;IAEA,OAAA,4BAAA,CAAA,WAAA,CAAA;EACA,CAAA;AACA;;AAEA;AACA;AACA;AACA,SAAA,4BAAA,GAAA;EACA,MAAA,OAAA,GAAA,cAAA,EAAA;EACA,IAAA,CAAA,OAAA,CAAA,UAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CAAA,4DAAA,CAAA;IACA;IACA;EACA;EACA,OAAA,CAAA,UAAA,CAAA,UAAA,GAAA,OAAA,CAAA,UAAA,CAAA,UAAA,IAAA,CAAA,CAAA;EAEA,IAAA,CAAA,OAAA,CAAA,UAAA,CAAA,UAAA,CAAA,kBAAA,CAAA,EAAA;IACA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;MACA,MAAA,CAAA,GAAA,CACA,4KAAA,CACA;IACA;IACA;EACA;EAEA,IAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,EAAA;IACA,MAAA,CAAA,GAAA,CAAA,kFAAA,CAAA;EACA;EAEA,OAAA,CAAA,UAAA,CAAA,UAAA,CAAA,kBAAA,CAAA,GAAA,4CAAA;EACA;EACA,OAAA,CAAA,UAAA,CAAA,UAAA,CAAA,kBAAA,CAAA,CACA;AACA","sourcesContent":["import { getCurrentHub, getMainCarrier } from '@sentry/core';\nimport type { CustomSamplingContext, Hub, Transaction, TransactionContext } from '@sentry/types';\nimport { logger, uuid4 } from '@sentry/utils';\n\nimport { WINDOW } from '../helpers';\nimport type {\n  JSSelfProfile,\n  JSSelfProfiler,\n  JSSelfProfilerConstructor,\n  ProcessedJSSelfProfile,\n} from './jsSelfProfiling';\nimport { sendProfile } from './sendProfile';\n\n// Max profile duration.\nconst MAX_PROFILE_DURATION_MS = 30_000;\n// Keep a flag value to avoid re-initializing the profiler constructor. If it fails\n// once, it will always fail and this allows us to early return.\nlet PROFILING_CONSTRUCTOR_FAILED = false;\n\n// While we experiment, per transaction sampling interval will be more flexible to work with.\ntype StartTransaction = (\n  this: Hub,\n  transactionContext: TransactionContext,\n  customSamplingContext?: CustomSamplingContext,\n) => Transaction | undefined;\n\n/**\n * Check if profiler constructor is available.\n * @param maybeProfiler\n */\nfunction isJSProfilerSupported(maybeProfiler: unknown): maybeProfiler is typeof JSSelfProfilerConstructor {\n  return typeof maybeProfiler === 'function';\n}\n\n/**\n * Safety wrapper for startTransaction for the unlikely case that transaction starts before tracing is imported -\n * if that happens we want to avoid throwing an error from profiling code.\n * see https://github.com/getsentry/sentry-javascript/issues/4731.\n *\n * @experimental\n */\nexport function onProfilingStartRouteTransaction(transaction: Transaction | undefined): Transaction | undefined {\n  if (!transaction) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Transaction is undefined, skipping profiling');\n    }\n    return transaction;\n  }\n\n  return wrapTransactionWithProfiling(transaction);\n}\n\n/**\n * Wraps startTransaction and stopTransaction with profiling related logic.\n * startProfiling is called after the call to startTransaction in order to avoid our own code from\n * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n */\nfunction wrapTransactionWithProfiling(transaction: Transaction): Transaction {\n  // Feature support check first\n  const JSProfilerConstructor = WINDOW.Profiler;\n\n  if (!isJSProfilerSupported(JSProfilerConstructor)) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        '[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.',\n      );\n    }\n    return transaction;\n  }\n\n  // profilesSampleRate is multiplied with tracesSampleRate to get the final sampling rate.\n  if (!transaction.sampled) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Transaction is not sampled, skipping profiling');\n    }\n    return transaction;\n  }\n\n  // If constructor failed once, it will always fail, so we can early return.\n  if (PROFILING_CONSTRUCTOR_FAILED) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Profiling has been disabled for the duration of the current user session.');\n    }\n    return transaction;\n  }\n\n  const client = getCurrentHub().getClient();\n  const options = client && client.getOptions();\n\n  // @ts-ignore not part of the browser options yet\n  const profilesSampleRate = (options && options.profilesSampleRate) || 0;\n  if (profilesSampleRate === undefined) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Profiling disabled, enable it by setting `profilesSampleRate` option to SDK init call.');\n    }\n    return transaction;\n  }\n\n  // Check if we should sample this profile\n  if (Math.random() > profilesSampleRate) {\n    if (__DEBUG_BUILD__) {\n      logger.log('[Profiling] Skip profiling transaction due to sampling.');\n    }\n    return transaction;\n  }\n\n  // From initial testing, it seems that the minimum value for sampleInterval is 10ms.\n  const samplingIntervalMS = 10;\n  // Start the profiler\n  const maxSamples = Math.floor(MAX_PROFILE_DURATION_MS / samplingIntervalMS);\n  let profiler: JSSelfProfiler | undefined;\n\n  // Attempt to initialize the profiler constructor, if it fails, we disable profiling for the current user session.\n  // This is likely due to a missing 'Document-Policy': 'js-profiling' header. We do not want to throw an error if this happens\n  // as we risk breaking the user's application, so just disable profiling and log an error.\n  try {\n    profiler = new JSProfilerConstructor({ sampleInterval: samplingIntervalMS, maxBufferSize: maxSamples });\n  } catch (e) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        \"[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header.\",\n      );\n      logger.log('[Profiling] Disabling profiling for current user session.');\n    }\n    PROFILING_CONSTRUCTOR_FAILED = true;\n  }\n\n  // We failed to construct the profiler, fallback to original transaction - there is no need to log\n  // anything as we already did that in the try/catch block.\n  if (!profiler) {\n    return transaction;\n  }\n\n  if (__DEBUG_BUILD__) {\n    logger.log(`[Profiling] started profiling transaction: ${transaction.name || transaction.description}`);\n  }\n\n  // We create \"unique\" transaction names to avoid concurrent transactions with same names\n  // from being ignored by the profiler. From here on, only this transaction name should be used when\n  // calling the profiler methods. Note: we log the original name to the user to avoid confusion.\n  const profileId = uuid4();\n\n  // A couple of important things to note here:\n  // `CpuProfilerBindings.stopProfiling` will be scheduled to run in 30seconds in order to exceed max profile duration.\n  // Whichever of the two (transaction.finish/timeout) is first to run, the profiling will be stopped and the gathered profile\n  // will be processed when the original transaction is finished. Since onProfileHandler can be invoked multiple times in the\n  // event of an error or user mistake (calling transaction.finish multiple times), it is important that the behavior of onProfileHandler\n  // is idempotent as we do not want any timings or profiles to be overriden by the last call to onProfileHandler.\n  // After the original finish method is called, the event will be reported through the integration and delegated to transport.\n  let processedProfile: ProcessedJSSelfProfile | null = null;\n\n  /**\n   * Idempotent handler for profile stop\n   */\n  function onProfileHandler(): void {\n    // Check if the profile exists and return it the behavior has to be idempotent as users may call transaction.finish multiple times.\n    if (!transaction) {\n      return;\n    }\n    // Satisfy the type checker, but profiler will always be defined here.\n    if (!profiler) {\n      return;\n    }\n    if (processedProfile) {\n      if (__DEBUG_BUILD__) {\n        logger.log(\n          '[Profiling] profile for:',\n          transaction.name || transaction.description,\n          'already exists, returning early',\n        );\n      }\n      return;\n    }\n\n    profiler\n      .stop()\n      .then((p: JSSelfProfile): void => {\n        if (maxDurationTimeoutID) {\n          WINDOW.clearTimeout(maxDurationTimeoutID);\n          maxDurationTimeoutID = undefined;\n        }\n\n        if (__DEBUG_BUILD__) {\n          logger.log(`[Profiling] stopped profiling of transaction: ${transaction.name || transaction.description}`);\n        }\n\n        // In case of an overlapping transaction, stopProfiling may return null and silently ignore the overlapping profile.\n        if (!p) {\n          if (__DEBUG_BUILD__) {\n            logger.log(\n              `[Profiling] profiler returned null profile for: ${transaction.name || transaction.description}`,\n              'this may indicate an overlapping transaction or a call to stopProfiling with a profile title that was never started',\n            );\n          }\n          return;\n        }\n\n        // If a profile has less than 2 samples, it is not useful and should be discarded.\n        if (p.samples.length < 2) {\n          return;\n        }\n\n        processedProfile = { ...p, profile_id: profileId };\n        sendProfile(profileId, processedProfile);\n      })\n      .catch(error => {\n        if (__DEBUG_BUILD__) {\n          logger.log('[Profiling] error while stopping profiler:', error);\n        }\n        return null;\n      });\n  }\n\n  // Enqueue a timeout to prevent profiles from running over max duration.\n  let maxDurationTimeoutID: number | undefined = WINDOW.setTimeout(() => {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        '[Profiling] max profile duration elapsed, stopping profiling for:',\n        transaction.name || transaction.description,\n      );\n    }\n    void onProfileHandler();\n  }, MAX_PROFILE_DURATION_MS);\n\n  // We need to reference the original finish call to avoid creating an infinite loop\n  const originalFinish = transaction.finish.bind(transaction);\n\n  /**\n   * Wraps startTransaction and stopTransaction with profiling related logic.\n   * startProfiling is called after the call to startTransaction in order to avoid our own code from\n   * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n   */\n  function profilingWrappedTransactionFinish(): Promise<Transaction> {\n    if (!transaction) {\n      return originalFinish();\n    }\n    // onProfileHandler should always return the same profile even if this is called multiple times.\n    // Always call onProfileHandler to ensure stopProfiling is called and the timeout is cleared.\n    onProfileHandler();\n\n    // Set profile context\n    transaction.setContext('profile', { profile_id: profileId });\n\n    return originalFinish();\n  }\n\n  transaction.finish = profilingWrappedTransactionFinish;\n  return transaction;\n}\n\n/**\n * Wraps startTransaction with profiling logic. This is done automatically by the profiling integration.\n */\nfunction __PRIVATE__wrapStartTransactionWithProfiling(startTransaction: StartTransaction): StartTransaction {\n  return function wrappedStartTransaction(\n    this: Hub,\n    transactionContext: TransactionContext,\n    customSamplingContext?: CustomSamplingContext,\n  ): Transaction | undefined {\n    const transaction: Transaction | undefined = startTransaction.call(this, transactionContext, customSamplingContext);\n    if (transaction === undefined) {\n      if (__DEBUG_BUILD__) {\n        logger.log('[Profiling] Transaction is undefined, skipping profiling');\n      }\n      return transaction;\n    }\n\n    return wrapTransactionWithProfiling(transaction);\n  };\n}\n\n/**\n * Patches startTransaction and stopTransaction with profiling logic.\n */\nexport function addProfilingExtensionMethods(): void {\n  const carrier = getMainCarrier();\n  if (!carrier.__SENTRY__) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\"[Profiling] Can't find main carrier, profiling won't work.\");\n    }\n    return;\n  }\n  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n\n  if (!carrier.__SENTRY__.extensions['startTransaction']) {\n    if (__DEBUG_BUILD__) {\n      logger.log(\n        '[Profiling] startTransaction does not exists, profiling will not work. Make sure you import @sentry/tracing package before @sentry/profiling-node as import order matters.',\n      );\n    }\n    return;\n  }\n\n  if (__DEBUG_BUILD__) {\n    logger.log('[Profiling] startTransaction exists, patching it with profiling functionality...');\n  }\n\n  carrier.__SENTRY__.extensions['startTransaction'] = __PRIVATE__wrapStartTransactionWithProfiling(\n    // This is already patched by sentry/tracing, we are going to re-patch it...\n    carrier.__SENTRY__.extensions['startTransaction'] as StartTransaction,\n  );\n}\n"]},"metadata":{},"sourceType":"module"}