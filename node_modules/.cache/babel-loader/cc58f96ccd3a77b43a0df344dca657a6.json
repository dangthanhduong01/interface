{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNextLayer = exports.getRoot = exports.fillArray = exports.hashConcat = exports.bufferKeccak = exports.hexToBuffer = exports.bufferToHex = exports.chunk = exports.makeArray = void 0;\nvar utils_1 = require(\"ethers/lib/utils\");\nvar makeArray = function (len, getValue) {\n  return Array(len).fill(0).map(function (_, i) {\n    return getValue(i);\n  });\n};\nexports.makeArray = makeArray;\nvar chunk = function (array, size) {\n  return (0, exports.makeArray)(Math.ceil(array.length / size), function (i) {\n    return array.slice(i * size, (i + 1) * size);\n  });\n};\nexports.chunk = chunk;\nvar bufferToHex = function (buf) {\n  return (0, utils_1.hexlify)(buf);\n};\nexports.bufferToHex = bufferToHex;\nvar hexToBuffer = function (value) {\n  return Buffer.from(value.slice(2), \"hex\");\n};\nexports.hexToBuffer = hexToBuffer;\nvar bufferKeccak = function (value) {\n  return (0, exports.hexToBuffer)((0, utils_1.keccak256)(value));\n};\nexports.bufferKeccak = bufferKeccak;\nvar hashConcat = function (arr) {\n  return (0, exports.bufferKeccak)((0, utils_1.hexConcat)(arr));\n};\nexports.hashConcat = hashConcat;\nvar fillArray = function (arr, length, value) {\n  if (length > arr.length) arr.push.apply(arr, __spreadArray([], __read(Array(length - arr.length).fill(value)), false));\n  return arr;\n};\nexports.fillArray = fillArray;\nvar getRoot = function (elements, hashLeaves) {\n  if (hashLeaves === void 0) {\n    hashLeaves = true;\n  }\n  if (elements.length === 0) throw new Error(\"empty tree\");\n  var leaves = elements.map(function (e) {\n    var leaf = Buffer.isBuffer(e) ? e : (0, exports.hexToBuffer)(e);\n    return hashLeaves ? (0, exports.bufferKeccak)(leaf) : leaf;\n  });\n  var layers = [leaves];\n  // Get next layer until we reach the root\n  while (layers[layers.length - 1].length > 1) {\n    layers.push((0, exports.getNextLayer)(layers[layers.length - 1]));\n  }\n  return layers[layers.length - 1][0];\n};\nexports.getRoot = getRoot;\nvar getNextLayer = function (elements) {\n  return (0, exports.chunk)(elements, 2).map(exports.hashConcat);\n};\nexports.getNextLayer = getNextLayer;","map":{"version":3,"sources":["../../../src/utils/eip712/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getNextLayer = exports.getRoot = exports.fillArray = exports.hashConcat = exports.bufferKeccak = exports.hexToBuffer = exports.bufferToHex = exports.chunk = exports.makeArray = void 0;\nvar utils_1 = require(\"ethers/lib/utils\");\nvar makeArray = function (len, getValue) {\n    return Array(len)\n        .fill(0)\n        .map(function (_, i) { return getValue(i); });\n};\nexports.makeArray = makeArray;\nvar chunk = function (array, size) {\n    return (0, exports.makeArray)(Math.ceil(array.length / size), function (i) {\n        return array.slice(i * size, (i + 1) * size);\n    });\n};\nexports.chunk = chunk;\nvar bufferToHex = function (buf) { return (0, utils_1.hexlify)(buf); };\nexports.bufferToHex = bufferToHex;\nvar hexToBuffer = function (value) {\n    return Buffer.from(value.slice(2), \"hex\");\n};\nexports.hexToBuffer = hexToBuffer;\nvar bufferKeccak = function (value) { return (0, exports.hexToBuffer)((0, utils_1.keccak256)(value)); };\nexports.bufferKeccak = bufferKeccak;\nvar hashConcat = function (arr) { return (0, exports.bufferKeccak)((0, utils_1.hexConcat)(arr)); };\nexports.hashConcat = hashConcat;\nvar fillArray = function (arr, length, value) {\n    if (length > arr.length)\n        arr.push.apply(arr, __spreadArray([], __read(Array(length - arr.length).fill(value)), false));\n    return arr;\n};\nexports.fillArray = fillArray;\nvar getRoot = function (elements, hashLeaves) {\n    if (hashLeaves === void 0) { hashLeaves = true; }\n    if (elements.length === 0)\n        throw new Error(\"empty tree\");\n    var leaves = elements.map(function (e) {\n        var leaf = Buffer.isBuffer(e) ? e : (0, exports.hexToBuffer)(e);\n        return hashLeaves ? (0, exports.bufferKeccak)(leaf) : leaf;\n    });\n    var layers = [leaves];\n    // Get next layer until we reach the root\n    while (layers[layers.length - 1].length > 1) {\n        layers.push((0, exports.getNextLayer)(layers[layers.length - 1]));\n    }\n    return layers[layers.length - 1][0];\n};\nexports.getRoot = getRoot;\nvar getNextLayer = function (elements) {\n    return (0, exports.chunk)(elements, 2).map(exports.hashConcat);\n};\nexports.getNextLayer = getNextLayer;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}