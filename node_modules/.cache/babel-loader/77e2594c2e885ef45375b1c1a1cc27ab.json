{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar invariant = _interopDefault(require('tiny-invariant'));\nvar UniversalRouter_json = require('@uniswap/universal-router/artifacts/contracts/UniversalRouter.sol/UniversalRouter.json');\nvar abi$7 = require('@ethersproject/abi');\nvar ethers = require('ethers');\nvar JSBI = _interopDefault(require('jsbi'));\nvar utils = require('ethers/lib/utils');\nvar v2Sdk = require('@uniswap/v2-sdk');\nvar v3Sdk = require('@uniswap/v3-sdk');\nvar routerSdk = require('@uniswap/router-sdk');\nvar sdkCore = require('@uniswap/sdk-core');\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n(function (RouterTradeType) {\n  RouterTradeType[\"UniswapTrade\"] = \"UniswapTrade\";\n  RouterTradeType[\"NFTTrade\"] = \"NFTTrade\";\n  RouterTradeType[\"UnwrapWETH\"] = \"UnwrapWETH\";\n})(exports.RouterTradeType || (exports.RouterTradeType = {}));\nvar _ABI_DEFINITION;\n/**\n * CommandTypes\n * @description Flags that modify a command's execution\n * @enum {number}\n */\nvar CommandType;\n(function (CommandType) {\n  CommandType[CommandType[\"V3_SWAP_EXACT_IN\"] = 0] = \"V3_SWAP_EXACT_IN\";\n  CommandType[CommandType[\"V3_SWAP_EXACT_OUT\"] = 1] = \"V3_SWAP_EXACT_OUT\";\n  CommandType[CommandType[\"PERMIT2_TRANSFER_FROM\"] = 2] = \"PERMIT2_TRANSFER_FROM\";\n  CommandType[CommandType[\"PERMIT2_PERMIT_BATCH\"] = 3] = \"PERMIT2_PERMIT_BATCH\";\n  CommandType[CommandType[\"SWEEP\"] = 4] = \"SWEEP\";\n  CommandType[CommandType[\"TRANSFER\"] = 5] = \"TRANSFER\";\n  CommandType[CommandType[\"PAY_PORTION\"] = 6] = \"PAY_PORTION\";\n  CommandType[CommandType[\"V2_SWAP_EXACT_IN\"] = 8] = \"V2_SWAP_EXACT_IN\";\n  CommandType[CommandType[\"V2_SWAP_EXACT_OUT\"] = 9] = \"V2_SWAP_EXACT_OUT\";\n  CommandType[CommandType[\"PERMIT\"] = 10] = \"PERMIT\";\n  CommandType[CommandType[\"WRAP_ETH\"] = 11] = \"WRAP_ETH\";\n  CommandType[CommandType[\"UNWRAP_WETH\"] = 12] = \"UNWRAP_WETH\";\n  CommandType[CommandType[\"PERMIT2_TRANSFER_FROM_BATCH\"] = 13] = \"PERMIT2_TRANSFER_FROM_BATCH\";\n  // NFT-related command types\n  CommandType[CommandType[\"SEAPORT\"] = 16] = \"SEAPORT\";\n  CommandType[CommandType[\"LOOKS_RARE_721\"] = 17] = \"LOOKS_RARE_721\";\n  CommandType[CommandType[\"NFTX\"] = 18] = \"NFTX\";\n  CommandType[CommandType[\"CRYPTOPUNKS\"] = 19] = \"CRYPTOPUNKS\";\n  CommandType[CommandType[\"LOOKS_RARE_1155\"] = 20] = \"LOOKS_RARE_1155\";\n  CommandType[CommandType[\"OWNER_CHECK_721\"] = 21] = \"OWNER_CHECK_721\";\n  CommandType[CommandType[\"OWNER_CHECK_1155\"] = 22] = \"OWNER_CHECK_1155\";\n  CommandType[CommandType[\"X2Y2_721\"] = 24] = \"X2Y2_721\";\n  CommandType[CommandType[\"SUDOSWAP\"] = 25] = \"SUDOSWAP\";\n  CommandType[CommandType[\"NFT20\"] = 26] = \"NFT20\";\n  CommandType[CommandType[\"X2Y2_1155\"] = 27] = \"X2Y2_1155\";\n  CommandType[CommandType[\"FOUNDATION\"] = 28] = \"FOUNDATION\";\n})(CommandType || (CommandType = {}));\nvar PERMIT_STRUCT = '((address token,uint160 amount,uint48 expiration,uint48 nonce) details, address spender, uint256 sigDeadline)';\nvar PERMIT_BATCH_STRUCT = '((address token,uint160 amount,uint48 expiration,uint48 nonce)[] details, address spender, uint256 sigDeadline)';\nvar ALLOW_REVERT_FLAG = 0x80;\nvar REVERTABLE_COMMANDS = /*#__PURE__*/new Set([CommandType.SEAPORT, CommandType.NFTX, CommandType.LOOKS_RARE_721, CommandType.LOOKS_RARE_1155, CommandType.X2Y2_721, CommandType.X2Y2_1155, CommandType.FOUNDATION, CommandType.SUDOSWAP, CommandType.NFT20, CommandType.CRYPTOPUNKS]);\nvar ABI_DEFINITION = (_ABI_DEFINITION = {}, _ABI_DEFINITION[CommandType.PERMIT] = [PERMIT_STRUCT, 'bytes'], _ABI_DEFINITION[CommandType.PERMIT2_PERMIT_BATCH] = [PERMIT_BATCH_STRUCT, 'bytes'], _ABI_DEFINITION[CommandType.PERMIT2_TRANSFER_FROM] = ['address', 'address', 'uint160'], _ABI_DEFINITION[CommandType.PERMIT2_TRANSFER_FROM_BATCH] = ['bytes'], _ABI_DEFINITION[CommandType.TRANSFER] = ['address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.V3_SWAP_EXACT_IN] = ['address', 'uint256', 'uint256', 'bytes', 'bool'], _ABI_DEFINITION[CommandType.V3_SWAP_EXACT_OUT] = ['address', 'uint256', 'uint256', 'bytes', 'bool'], _ABI_DEFINITION[CommandType.V2_SWAP_EXACT_IN] = ['address', 'uint256', 'uint256', 'address[]', 'bool'], _ABI_DEFINITION[CommandType.V2_SWAP_EXACT_OUT] = ['address', 'uint256', 'uint256', 'address[]', 'bool'], _ABI_DEFINITION[CommandType.SEAPORT] = ['uint256', 'bytes'], _ABI_DEFINITION[CommandType.WRAP_ETH] = ['address', 'uint256'], _ABI_DEFINITION[CommandType.UNWRAP_WETH] = ['address', 'uint256'], _ABI_DEFINITION[CommandType.SWEEP] = ['address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.NFTX] = ['uint256', 'bytes'], _ABI_DEFINITION[CommandType.LOOKS_RARE_721] = ['uint256', 'bytes', 'address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.LOOKS_RARE_1155] = ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'], _ABI_DEFINITION[CommandType.X2Y2_721] = ['uint256', 'bytes', 'address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.X2Y2_1155] = ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'], _ABI_DEFINITION[CommandType.FOUNDATION] = ['uint256', 'bytes', 'address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.PAY_PORTION] = ['address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.SUDOSWAP] = ['uint256', 'bytes'], _ABI_DEFINITION[CommandType.OWNER_CHECK_721] = ['address', 'address', 'uint256'], _ABI_DEFINITION[CommandType.OWNER_CHECK_1155] = ['address', 'address', 'uint256', 'uint256'], _ABI_DEFINITION[CommandType.NFT20] = ['uint256', 'bytes'], _ABI_DEFINITION[CommandType.CRYPTOPUNKS] = ['uint256', 'address', 'uint256'], _ABI_DEFINITION);\nvar RoutePlanner = /*#__PURE__*/function () {\n  function RoutePlanner() {\n    this.commands = '0x';\n    this.inputs = [];\n  }\n  var _proto = RoutePlanner.prototype;\n  _proto.addCommand = function addCommand(type, parameters, allowRevert) {\n    if (allowRevert === void 0) {\n      allowRevert = false;\n    }\n    var command = createCommand(type, parameters);\n    this.inputs.push(command.encodedInput);\n    if (allowRevert) {\n      if (!REVERTABLE_COMMANDS.has(command.type)) {\n        throw new Error(\"command type: \" + command.type + \" cannot be allowed to revert\");\n      }\n      command.type = command.type | ALLOW_REVERT_FLAG;\n    }\n    this.commands = this.commands.concat(command.type.toString(16).padStart(2, '0'));\n  };\n  return RoutePlanner;\n}();\nfunction createCommand(type, parameters) {\n  var encodedInput = utils.defaultAbiCoder.encode(ABI_DEFINITION[type], parameters);\n  return {\n    type: type,\n    encodedInput: encodedInput\n  };\n}\nvar UNIVERSAL_ROUTER_ADDRESS = function UNIVERSAL_ROUTER_ADDRESS(chainId) {\n  switch (chainId) {\n    case 1:\n      // mainnet\n      return '0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B';\n    case 5:\n      // goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 137:\n      // polygon\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5';\n    case 80001:\n      // polygon mumbai\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 10:\n      // optimism\n      return '0xb555edF5dcF85f42cEeF1f3630a52A108E55A654';\n    case 420:\n      // optimism goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 42161:\n      // arbitrum\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5';\n    case 421613:\n      // arbitrum goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 42220:\n      // celo\n      return '0xC73d61d192FB994157168Fb56730FdEc64C9Cb8F';\n    case 44787:\n      // celo alfajores\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491';\n    case 56:\n      // binance smart chain\n      return '0x5Dc88340E1c5c6366864Ee415d6034cadd1A9897';\n    case 11968:\n      return '0x5Dc88340E1c5c6366864Ee415d6034cadd1A9897';\n    default:\n      throw new Error(\"Universal Router not deployed on chain \" + chainId);\n  }\n};\nvar WETH_ADDRESS = function WETH_ADDRESS(chainId) {\n  switch (chainId) {\n    case 1:\n      //mainnet\n      return '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';\n    case 5:\n      // goerli\n      return '0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6';\n    case 137:\n      // polygon\n      return '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270';\n    case 80001:\n      // polygon mumbai\n      return '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889';\n    case 10:\n      // optimism\n      return '0x4200000000000000000000000000000000000006';\n    case 420:\n      // optimism goerli\n      return '0x4200000000000000000000000000000000000006';\n    case 42161:\n      // arbitrum\n      return '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1';\n    case 421613:\n      // arbitrum goerli\n      return '0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3';\n    case 56:\n      // binance smart chain\n      return '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c';\n    case 11968:\n      return '0x528f15986Dd88Cc90ad134F1c9d759729Ae925Af';\n    default:\n      throw new Error(\"WETH9 or UniversalRouter not deployed on chain \" + chainId);\n  }\n};\nvar PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3';\nvar CONTRACT_BALANCE = /*#__PURE__*/ethers.BigNumber.from(2).pow(255);\nvar ETH_ADDRESS = '0x0000000000000000000000000000000000000000';\nvar SENDER_AS_RECIPIENT = '0x0000000000000000000000000000000000000001';\nvar ROUTER_AS_RECIPIENT = '0x0000000000000000000000000000000000000002';\nvar REFUND_ETH_PRICE_IMPACT_THRESHOLD = /*#__PURE__*/new sdkCore.Percent( /*#__PURE__*/JSBI.BigInt(50), /*#__PURE__*/JSBI.BigInt(100));\n// Wrapper for uniswap router-sdk trade entity to encode swaps for Universal Router\n// also translates trade objects from previous (v2, v3) SDKs\nvar UniswapTrade = /*#__PURE__*/function () {\n  function UniswapTrade(trade, options) {\n    this.trade = trade;\n    this.options = options;\n    this.tradeType = exports.RouterTradeType.UniswapTrade;\n  }\n  var _proto = UniswapTrade.prototype;\n  _proto.encode = function encode(planner, _config) {\n    var _this$options$recipie;\n    var payerIsUser = true;\n    if (this.trade.inputAmount.currency.isNative) {\n      // TODO: optimize if only one v2 pool we can directly send this to the pool\n      planner.addCommand(CommandType.WRAP_ETH, [ROUTER_AS_RECIPIENT, this.trade.maximumAmountIn(this.options.slippageTolerance).quotient.toString()]);\n      // since WETH is now owned by the router, the router pays for inputs\n      payerIsUser = false;\n    }\n    this.options.recipient = (_this$options$recipie = this.options.recipient) != null ? _this$options$recipie : SENDER_AS_RECIPIENT;\n    // flag for whether we want to perform slippage check on aggregate output of multiple routes\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    var performAggregatedSlippageCheck = this.trade.tradeType === sdkCore.TradeType.EXACT_INPUT && this.trade.routes.length > 2;\n    var outputIsNative = this.trade.outputAmount.currency.isNative;\n    var inputIsNative = this.trade.inputAmount.currency.isNative;\n    var routerMustCustody = performAggregatedSlippageCheck || outputIsNative;\n    for (var _iterator = _createForOfIteratorHelperLoose(this.trade.swaps), _step; !(_step = _iterator()).done;) {\n      var swap = _step.value;\n      switch (swap.route.protocol) {\n        case routerSdk.Protocol.V2:\n          addV2Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody);\n          break;\n        case routerSdk.Protocol.V3:\n          addV3Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody);\n          break;\n        case routerSdk.Protocol.MIXED:\n          addMixedSwap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody);\n          break;\n        default:\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL');\n      }\n    }\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString()]);\n      } else {\n        planner.addCommand(CommandType.SWEEP, [this.trade.outputAmount.currency.wrapped.address, this.options.recipient, this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString()]);\n      }\n    }\n    if (inputIsNative && (this.trade.tradeType === sdkCore.TradeType.EXACT_OUTPUT || riskOfPartialFill(this.trade))) {\n      // for exactOutput swaps that take native currency as input\n      // we need to send back the change to the user\n      planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, 0]);\n    }\n  };\n  return UniswapTrade;\n}();\n// encode a uniswap v2 swap\nfunction addV2Swap(planner, _ref, tradeType, options, payerIsUser, routerMustCustody) {\n  var route = _ref.route,\n    inputAmount = _ref.inputAmount,\n    outputAmount = _ref.outputAmount;\n  var trade = new v2Sdk.Trade(route, tradeType == sdkCore.TradeType.EXACT_INPUT ? inputAmount : outputAmount, tradeType);\n  if (tradeType == sdkCore.TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n    // if native, we have to unwrap so keep in the router for now\n    routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient, trade.maximumAmountIn(options.slippageTolerance).quotient.toString(), trade.minimumAmountOut(options.slippageTolerance).quotient.toString(), route.path.map(function (pool) {\n      return pool.address;\n    }), payerIsUser]);\n  } else if (tradeType == sdkCore.TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_OUT, [routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient, trade.minimumAmountOut(options.slippageTolerance).quotient.toString(), trade.maximumAmountIn(options.slippageTolerance).quotient.toString(), route.path.map(function (pool) {\n      return pool.address;\n    }), payerIsUser]);\n  }\n}\n// encode a uniswap v3 swap\nfunction addV3Swap(planner, _ref2, tradeType, options, payerIsUser, routerMustCustody) {\n  var route = _ref2.route,\n    inputAmount = _ref2.inputAmount,\n    outputAmount = _ref2.outputAmount;\n  var trade = v3Sdk.Trade.createUncheckedTrade({\n    route: route,\n    inputAmount: inputAmount,\n    outputAmount: outputAmount,\n    tradeType: tradeType\n  });\n  var path = v3Sdk.encodeRouteToPath(route, trade.tradeType === sdkCore.TradeType.EXACT_OUTPUT);\n  if (tradeType == sdkCore.TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient, trade.maximumAmountIn(options.slippageTolerance).quotient.toString(), trade.minimumAmountOut(options.slippageTolerance).quotient.toString(), path, payerIsUser]);\n  } else if (tradeType == sdkCore.TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_OUT, [routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient, trade.minimumAmountOut(options.slippageTolerance).quotient.toString(), trade.maximumAmountIn(options.slippageTolerance).quotient.toString(), path, payerIsUser]);\n  }\n}\n// encode a mixed route swap, i.e. including both v2 and v3 pools\nfunction addMixedSwap(planner, swap, tradeType, options, payerIsUser, routerMustCustody) {\n  var route = swap.route,\n    inputAmount = swap.inputAmount,\n    outputAmount = swap.outputAmount;\n  var tradeRecipient = routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient;\n  // single hop, so it can be reduced to plain v2 or v3 swap logic\n  if (route.pools.length === 1) {\n    if (route.pools[0] instanceof v3Sdk.Pool) {\n      return addV3Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody);\n    } else if (route.pools[0] instanceof v2Sdk.Pair) {\n      return addV2Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody);\n    } else {\n      throw new Error('Invalid route type');\n    }\n  }\n  var trade = routerSdk.MixedRouteTrade.createUncheckedTrade({\n    route: route,\n    inputAmount: inputAmount,\n    outputAmount: outputAmount,\n    tradeType: tradeType\n  });\n  var amountIn = trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient.toString();\n  var amountOut = trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient.toString();\n  // logic from\n  // https://github.com/Uniswap/router-sdk/blob/d8eed164e6c79519983844ca8b6a3fc24ebcb8f8/src/swapRouter.ts#L276\n  var sections = routerSdk.partitionMixedRouteByProtocol(route);\n  var isLastSectionInRoute = function isLastSectionInRoute(i) {\n    return i === sections.length - 1;\n  };\n  var outputToken;\n  var inputToken = route.input.wrapped;\n  for (var i = 0; i < sections.length; i++) {\n    var section = sections[i];\n    /// Now, we get output of this section\n    outputToken = routerSdk.getOutputOfPools(section, inputToken);\n    var newRouteOriginal = new routerSdk.MixedRouteSDK([].concat(section), section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1, outputToken);\n    var newRoute = new routerSdk.MixedRoute(newRouteOriginal);\n    /// Previous output is now input\n    inputToken = outputToken;\n    var mixedRouteIsAllV3 = function mixedRouteIsAllV3(route) {\n      return route.pools.every(function (pool) {\n        return pool instanceof v3Sdk.Pool;\n      });\n    };\n    if (mixedRouteIsAllV3(newRoute)) {\n      var path = routerSdk.encodeMixedRouteToPath(newRoute);\n      planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n      // if not last section: send tokens directly to the first v2 pair of the next section\n      // note: because of the partitioning function we can be sure that the next section is v2\n      isLastSectionInRoute(i) ? tradeRecipient : sections[i + 1][0].liquidityToken.address, i == 0 ? amountIn : CONTRACT_BALANCE, !isLastSectionInRoute(i) ? 0 : amountOut, path, payerIsUser && i === 0]);\n    } else {\n      planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [isLastSectionInRoute(i) ? tradeRecipient : ROUTER_AS_RECIPIENT, i === 0 ? amountIn : CONTRACT_BALANCE, !isLastSectionInRoute(i) ? 0 : amountOut, newRoute.path.map(function (pool) {\n        return pool.address;\n      }), payerIsUser && i === 0]);\n    }\n  }\n}\n// if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\nfunction riskOfPartialFill(trade) {\n  return trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD);\n}\nvar SIGNATURE_LENGTH = 65;\nvar EIP_2098_SIGNATURE_LENGTH = 64;\nfunction encodePermit(planner, permit) {\n  var signature = permit.signature;\n  var length = ethers.ethers.utils.arrayify(permit.signature).length;\n  // signature data provided for EIP-1271 may have length different from ECDSA signature\n  if (length === SIGNATURE_LENGTH || length === EIP_2098_SIGNATURE_LENGTH) {\n    // sanitizes signature to cover edge cases of malformed EIP-2098 sigs and v used as recovery id\n    signature = ethers.ethers.utils.joinSignature(ethers.ethers.utils.splitSignature(permit.signature));\n  }\n  planner.addCommand(CommandType.PERMIT, [permit, signature]);\n}\nvar SwapRouter = /*#__PURE__*/function () {\n  function SwapRouter() {}\n  SwapRouter.swapCallParameters = function swapCallParameters(trades, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    if (!Array.isArray(trades)) trades = [trades];\n    var nftTrades = trades.filter(function (trade, _, _ref) {\n      return trade.hasOwnProperty('market');\n    });\n    var allowRevert = nftTrades.length == 1 && nftTrades[0].orders.length == 1 ? false : true;\n    var planner = new RoutePlanner();\n    // track value flow to require the right amount of native value\n    var currentNativeValueInRouter = ethers.BigNumber.from(0);\n    var transactionValue = ethers.BigNumber.from(0);\n    for (var _iterator = _createForOfIteratorHelperLoose(trades), _step; !(_step = _iterator()).done;) {\n      var trade = _step.value;\n      /**\n       * is NFTTrade\n       */\n      if (trade.tradeType == exports.RouterTradeType.NFTTrade) {\n        var nftTrade = trade;\n        nftTrade.encode(planner, {\n          allowRevert: allowRevert\n        });\n        var tradePrice = nftTrade.getTotalPrice();\n        // send enough native value to contract for NFT purchase\n        if (currentNativeValueInRouter.lt(tradePrice)) {\n          transactionValue = transactionValue.add(tradePrice.sub(currentNativeValueInRouter));\n          currentNativeValueInRouter = ethers.BigNumber.from(0);\n        } else {\n          currentNativeValueInRouter = currentNativeValueInRouter.sub(tradePrice);\n        }\n        /**\n         * is Uniswap Trade\n         */\n      } else if (trade.tradeType == exports.RouterTradeType.UniswapTrade) {\n        var uniswapTrade = trade;\n        var inputIsNative = uniswapTrade.trade.inputAmount.currency.isNative;\n        var outputIsNative = uniswapTrade.trade.outputAmount.currency.isNative;\n        var swapOptions = uniswapTrade.options;\n        !!(inputIsNative && !!swapOptions.inputTokenPermit) ? invariant(false, 'NATIVE_INPUT_PERMIT') : void 0;\n        if (!!swapOptions.inputTokenPermit) {\n          encodePermit(planner, swapOptions.inputTokenPermit);\n        }\n        if (inputIsNative) {\n          transactionValue = transactionValue.add(ethers.BigNumber.from(uniswapTrade.trade.maximumAmountIn(swapOptions.slippageTolerance).quotient.toString()));\n        }\n        // track amount of native currency in the router\n        if (outputIsNative && swapOptions.recipient == ROUTER_AS_RECIPIENT) {\n          currentNativeValueInRouter = currentNativeValueInRouter.add(ethers.BigNumber.from(uniswapTrade.trade.minimumAmountOut(swapOptions.slippageTolerance).quotient.toString()));\n        }\n        uniswapTrade.encode(planner, {\n          allowRevert: false\n        });\n        /**\n         * is UnwrapWETH\n         */\n      } else if (trade.tradeType == exports.RouterTradeType.UnwrapWETH) {\n        var UnwrapWETH = trade;\n        trade.encode(planner, {\n          allowRevert: false\n        });\n        currentNativeValueInRouter = currentNativeValueInRouter.add(UnwrapWETH.amount);\n        /**\n         * else\n         */\n      } else {\n        throw 'trade must be of instance: UniswapTrade or NFTTrade';\n      }\n    }\n    // TODO: matches current logic for now, but should eventually only sweep for multiple NFT trades\n    // or NFT trades with potential slippage (i.e. sudo)\n    if (nftTrades.length > 0) planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0]);\n    return SwapRouter.encodePlan(planner, transactionValue, config);\n  }\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given swap.\n   * @param trades to produce call parameters for\n   */;\n  SwapRouter.swapNFTCallParameters = function swapNFTCallParameters(trades, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var planner = new RoutePlanner();\n    var totalPrice = ethers.BigNumber.from(0);\n    var allowRevert = trades.length == 1 && trades[0].orders.length == 1 ? false : true;\n    for (var _iterator2 = _createForOfIteratorHelperLoose(trades), _step2; !(_step2 = _iterator2()).done;) {\n      var trade = _step2.value;\n      trade.encode(planner, {\n        allowRevert: allowRevert\n      });\n      totalPrice = totalPrice.add(trade.getTotalPrice());\n    }\n    planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0]);\n    return SwapRouter.encodePlan(planner, totalPrice, config);\n  }\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */;\n  SwapRouter.swapERC20CallParameters = function swapERC20CallParameters(trades, options) {\n    // TODO: use permit if signature included in swapOptions\n    var planner = new RoutePlanner();\n    var trade = new UniswapTrade(trades, options);\n    var inputCurrency = trade.trade.inputAmount.currency;\n    !!(inputCurrency.isNative && !!options.inputTokenPermit) ? invariant(false, 'NATIVE_INPUT_PERMIT') : void 0;\n    if (options.inputTokenPermit) {\n      encodePermit(planner, options.inputTokenPermit);\n    }\n    var nativeCurrencyValue = inputCurrency.isNative ? ethers.BigNumber.from(trade.trade.maximumAmountIn(options.slippageTolerance).quotient.toString()) : ethers.BigNumber.from(0);\n    trade.encode(planner, {\n      allowRevert: false\n    });\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue, {\n      deadline: options.deadlineOrPreviousBlockhash ? ethers.BigNumber.from(options.deadlineOrPreviousBlockhash) : undefined\n    });\n  }\n  /**\n   * Encodes a planned route into a method name and parameters for the Router contract.\n   * @param planner the planned route\n   * @param nativeCurrencyValue the native currency value of the planned route\n   * @param config the router config\n   */;\n  SwapRouter.encodePlan = function encodePlan(planner, nativeCurrencyValue, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var commands = planner.commands,\n      inputs = planner.inputs;\n    var functionSignature = !!config.deadline ? 'execute(bytes,bytes[],uint256)' : 'execute(bytes,bytes[])';\n    var parameters = !!config.deadline ? [commands, inputs, config.deadline] : [commands, inputs];\n    var calldata = SwapRouter.INTERFACE.encodeFunctionData(functionSignature, parameters);\n    return {\n      calldata: calldata,\n      value: nativeCurrencyValue.toHexString()\n    };\n  };\n  return SwapRouter;\n}();\nSwapRouter.INTERFACE = /*#__PURE__*/new abi$7.Interface(UniversalRouter_json.abi);\nvar NFTTrade = function NFTTrade(market, orders) {\n  this.tradeType = exports.RouterTradeType.NFTTrade;\n  !(orders.length > 0) ? invariant(false, 'no buy Items') : void 0;\n  this.market = market;\n  this.orders = orders;\n};\n(function (Market) {\n  Market[\"Foundation\"] = \"foundation\";\n  Market[\"LooksRare\"] = \"looksrare\";\n  Market[\"NFT20\"] = \"nft20\";\n  Market[\"NFTX\"] = \"nftx\";\n  Market[\"Seaport\"] = \"seaport\";\n  Market[\"Sudoswap\"] = \"Sudoswap\";\n  Market[\"Cryptopunks\"] = \"cryptopunks\";\n  Market[\"X2Y2\"] = \"x2y2\";\n})(exports.Market || (exports.Market = {}));\n(function (TokenType) {\n  TokenType[\"ERC721\"] = \"ERC721\";\n  TokenType[\"ERC1155\"] = \"ERC1155\";\n  TokenType[\"Cryptopunk\"] = \"Cryptopunk\";\n})(exports.TokenType || (exports.TokenType = {}));\nvar CryptopunkTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(CryptopunkTrade, _NFTTrade);\n  function CryptopunkTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.Cryptopunks, orders) || this;\n  }\n  var _proto = CryptopunkTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      planner.addCommand(CommandType.CRYPTOPUNKS, [item.tokenId, item.recipient, item.value], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var item = _step2.value;\n      buyItems.push({\n        tokenAddress: CryptopunkTrade.CRYPTOPUNK_ADDRESS,\n        tokenId: item.tokenId,\n        tokenType: exports.TokenType.Cryptopunk\n      });\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var item = _step3.value;\n      total = total.add(item.value);\n    }\n    return total;\n  };\n  return CryptopunkTrade;\n}(NFTTrade);\nCryptopunkTrade.CRYPTOPUNK_ADDRESS = '0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb';\nvar abi = [{\n  inputs: [{\n    internalType: \"address payable\",\n    name: \"treasury\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"feth\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"royaltyRegistry\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"duration\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  inputs: [],\n  name: \"FoundationTreasuryNode_Address_Is_Not_A_Contract\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"FoundationTreasuryNode_Caller_Not_Admin\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"buyPrice\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketBuyPrice_Cannot_Buy_At_Lower_Price\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketBuyPrice_Cannot_Buy_Unset_Price\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketBuyPrice_Cannot_Cancel_Unset_Price\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketBuyPrice_Only_Owner_Can_Cancel_Price\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketBuyPrice_Only_Owner_Can_Set_Price\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketBuyPrice_Price_Already_Set\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketBuyPrice_Price_Too_High\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketBuyPrice_Seller_Mismatch\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketCore_FETH_Address_Is_Not_A_Contract\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketCore_Only_FETH_Can_Transfer_ETH\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketCore_Seller_Not_Found\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketOffer_Cannot_Be_Made_While_In_Auction\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"currentOfferAmount\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketOffer_Offer_Below_Min_Amount\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"expiry\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketOffer_Offer_Expired\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"currentOfferFrom\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketOffer_Offer_From_Does_Not_Match\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"minOfferAmount\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketOffer_Provided_Contract_And_TokenId_Count_Must_Match\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketOffer_Reason_Required\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Already_Listed\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"minAmount\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"endTime\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"endTime\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"maxDuration\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Exceeds_Max_Duration\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"extensionDuration\",\n    type: \"uint256\"\n  }],\n  name: \"NFTMarketReserveAuction_Less_Than_Extension_Duration\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketReserveAuction_Not_Matching_Seller\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"NFTMarketReserveAuction_Only_Owner_Can_Update_Auction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Price_Already_Set\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NFTMarketReserveAuction_Too_Much_Value_Provided\",\n  type: \"error\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"buyer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"protocolFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"creatorFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"sellerRev\",\n    type: \"uint256\"\n  }],\n  name: \"BuyPriceAccepted\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"BuyPriceCanceled\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"BuyPriceInvalidated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"BuyPriceSet\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"buyReferrer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"buyReferrerProtocolFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"buyReferrerSellerFee\",\n    type: \"uint256\"\n  }],\n  name: \"BuyReferralPaid\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint8\",\n    name: \"version\",\n    type: \"uint8\"\n  }],\n  name: \"Initialized\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"buyer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"protocolFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"creatorFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"sellerRev\",\n    type: \"uint256\"\n  }],\n  name: \"OfferAccepted\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"string\",\n    name: \"reason\",\n    type: \"string\"\n  }],\n  name: \"OfferCanceledByAdmin\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"OfferInvalidated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"buyer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"expiration\",\n    type: \"uint256\"\n  }],\n  name: \"OfferMade\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"bidder\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"endTime\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionBidPlaced\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionCanceled\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"string\",\n    name: \"reason\",\n    type: \"string\"\n  }],\n  name: \"ReserveAuctionCanceledByAdmin\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"duration\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"extensionDuration\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionCreated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"bidder\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"protocolFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"creatorFee\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"sellerRev\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionFinalized\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionInvalidated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }],\n  name: \"ReserveAuctionUpdated\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"WithdrawalToFETH\",\n  type: \"event\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"offerFrom\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minAmount\",\n    type: \"uint256\"\n  }],\n  name: \"acceptOffer\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address[]\",\n    name: \"nftContracts\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"tokenIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"string\",\n    name: \"reason\",\n    type: \"string\"\n  }],\n  name: \"adminCancelOffers\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"string\",\n    name: \"reason\",\n    type: \"string\"\n  }],\n  name: \"adminCancelReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxPrice\",\n    type: \"uint256\"\n  }],\n  name: \"buy\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxPrice\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  name: \"buyV2\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"cancelBuyPrice\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"cancelReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }],\n  name: \"createReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"finalizeReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getBuyPrice\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"seller\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"getFeesAndRecipients\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"protocolFee\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"creatorRev\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable[]\",\n    name: \"creatorRecipients\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"creatorShares\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"sellerRev\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"getFethAddress\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"fethAddress\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"getFoundationTreasury\",\n  outputs: [{\n    internalType: \"address payable\",\n    name: \"treasuryAddress\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getImmutableRoyalties\",\n  outputs: [{\n    internalType: \"address payable[]\",\n    name: \"recipients\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"splitPerRecipientInBasisPoints\",\n    type: \"uint256[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"getMinBidAmount\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"minimum\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getMinOfferAmount\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"minimum\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"creator\",\n    type: \"address\"\n  }],\n  name: \"getMutableRoyalties\",\n  outputs: [{\n    internalType: \"address payable[]\",\n    name: \"recipients\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"splitPerRecipientInBasisPoints\",\n    type: \"uint256[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getOffer\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"buyer\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"expiration\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getOfferReferrer\",\n  outputs: [{\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"getReserveAuction\",\n  outputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"nftContract\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"seller\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"duration\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"extensionDuration\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"bidder\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct NFTMarketReserveAuction.ReserveAuction\",\n    name: \"auction\",\n    type: \"tuple\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"getReserveAuctionBidReferrer\",\n  outputs: [{\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getReserveAuctionIdFor\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"getRoyaltyRegistry\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"registry\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getTokenCreator\",\n  outputs: [{\n    internalType: \"address payable\",\n    name: \"creator\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"initialize\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"makeOffer\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"expiration\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  name: \"makeOfferV2\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"expiration\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }],\n  name: \"placeBid\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"referrer\",\n    type: \"address\"\n  }],\n  name: \"placeBidV2\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"nftContract\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"setBuyPrice\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"auctionId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"reservePrice\",\n    type: \"uint256\"\n  }],\n  name: \"updateReserveAuction\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar FoundationTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(FoundationTrade, _NFTTrade);\n  function FoundationTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.Foundation, orders) || this;\n  }\n  var _proto = FoundationTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      var calldata = FoundationTrade.INTERFACE.encodeFunctionData('buyV2', [item.tokenAddress, item.tokenId, item.price, item.referrer]);\n      planner.addCommand(CommandType.FOUNDATION, [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var item = _step2.value;\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: exports.TokenType.ERC721\n      });\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var item = _step3.value;\n      total = total.add(item.price);\n    }\n    return total;\n  };\n  return FoundationTrade;\n}(NFTTrade);\nFoundationTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi);\nvar abi$1 = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"_currencyManager\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_executionManager\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_royaltyFeeManager\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_WETH\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_protocolFeeRecipient\",\n    type: \"address\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"newMinNonce\",\n    type: \"uint256\"\n  }],\n  name: \"CancelAllOrders\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256[]\",\n    name: \"orderNonces\",\n    type: \"uint256[]\"\n  }],\n  name: \"CancelMultipleOrders\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"currencyManager\",\n    type: \"address\"\n  }],\n  name: \"NewCurrencyManager\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"executionManager\",\n    type: \"address\"\n  }],\n  name: \"NewExecutionManager\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"protocolFeeRecipient\",\n    type: \"address\"\n  }],\n  name: \"NewProtocolFeeRecipient\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"royaltyFeeManager\",\n    type: \"address\"\n  }],\n  name: \"NewRoyaltyFeeManager\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"transferSelectorNFT\",\n    type: \"address\"\n  }],\n  name: \"NewTransferSelectorNFT\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"collection\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"royaltyRecipient\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"RoyaltyPayment\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"orderNonce\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"taker\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"maker\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"strategy\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"collection\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"TakerAsk\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"orderNonce\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"taker\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"maker\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"strategy\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"collection\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"tokenId\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }],\n  name: \"TakerBid\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"DOMAIN_SEPARATOR\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"WETH\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"minNonce\",\n    type: \"uint256\"\n  }],\n  name: \"cancelAllOrdersForSender\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256[]\",\n    name: \"orderNonces\",\n    type: \"uint256[]\"\n  }],\n  name: \"cancelMultipleMakerOrders\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"currencyManager\",\n  outputs: [{\n    internalType: \"contract ICurrencyManager\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"executionManager\",\n  outputs: [{\n    internalType: \"contract IExecutionManager\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"orderNonce\",\n    type: \"uint256\"\n  }],\n  name: \"isUserOrderNonceExecutedOrCancelled\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"taker\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct OrderTypes.TakerOrder\",\n    name: \"takerBid\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"signer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"collection\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"strategy\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"currency\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct OrderTypes.MakerOrder\",\n    name: \"makerAsk\",\n    type: \"tuple\"\n  }],\n  name: \"matchAskWithTakerBid\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"taker\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct OrderTypes.TakerOrder\",\n    name: \"takerBid\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"signer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"collection\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"strategy\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"currency\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct OrderTypes.MakerOrder\",\n    name: \"makerAsk\",\n    type: \"tuple\"\n  }],\n  name: \"matchAskWithTakerBidUsingETHAndWETH\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"taker\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct OrderTypes.TakerOrder\",\n    name: \"takerAsk\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"bool\",\n      name: \"isOrderAsk\",\n      type: \"bool\"\n    }, {\n      internalType: \"address\",\n      name: \"signer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"collection\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"tokenId\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"strategy\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"currency\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minPercentageToAsk\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"params\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct OrderTypes.MakerOrder\",\n    name: \"makerBid\",\n    type: \"tuple\"\n  }],\n  name: \"matchBidWithTakerAsk\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"protocolFeeRecipient\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"royaltyFeeManager\",\n  outputs: [{\n    internalType: \"contract IRoyaltyFeeManager\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"transferSelectorNFT\",\n  outputs: [{\n    internalType: \"contract ITransferSelectorNFT\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_currencyManager\",\n    type: \"address\"\n  }],\n  name: \"updateCurrencyManager\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_executionManager\",\n    type: \"address\"\n  }],\n  name: \"updateExecutionManager\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_protocolFeeRecipient\",\n    type: \"address\"\n  }],\n  name: \"updateProtocolFeeRecipient\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_royaltyFeeManager\",\n    type: \"address\"\n  }],\n  name: \"updateRoyaltyFeeManager\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_transferSelectorNFT\",\n    type: \"address\"\n  }],\n  name: \"updateTransferSelectorNFT\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"userMinOrderNonce\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nvar LooksRareTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(LooksRareTrade, _NFTTrade);\n  function LooksRareTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.LooksRare, orders) || this;\n  }\n  var _proto = LooksRareTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      var calldata = LooksRareTrade.INTERFACE.encodeFunctionData('matchAskWithTakerBidUsingETHAndWETH', [item.takerOrder, item.makerOrder]);\n      if (item.tokenType == exports.TokenType.ERC721) {\n        !(item.makerOrder.amount == 1) ? invariant(false, 'ERC721 token amount must be 1') : void 0;\n        planner.addCommand(CommandType.LOOKS_RARE_721, [item.makerOrder.price, calldata, item.recipient, item.makerOrder.collection, item.makerOrder.tokenId], config.allowRevert);\n      } else if (item.tokenType == exports.TokenType.ERC1155) {\n        planner.addCommand(CommandType.LOOKS_RARE_1155, [item.makerOrder.price, calldata, item.recipient, item.makerOrder.collection, item.makerOrder.tokenId, item.makerOrder.amount], config.allowRevert);\n      }\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var item = _step2.value;\n      buyItems.push({\n        tokenAddress: item.makerOrder.collection,\n        tokenId: item.makerOrder.tokenId,\n        tokenType: item.tokenType\n      });\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var item = _step3.value;\n      total = total.add(item.makerOrder.price);\n    }\n    return total;\n  };\n  return LooksRareTrade;\n}(NFTTrade);\nLooksRareTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$1);\nvar abi$2 = [{\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"ETH\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"NFT20\",\n  outputs: [{\n    internalType: \"contract INFT20Factory\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"UNIV2\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"UNIV3\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"WETH\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_nft\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_toIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_toAmounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"address\",\n    name: \"_receipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint24\",\n    name: \"_fee\",\n    type: \"uint24\"\n  }, {\n    internalType: \"bool\",\n    name: \"isV3\",\n    type: \"bool\"\n  }],\n  name: \"ethForNft\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_nft\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"bool\",\n    name: \"isErc721\",\n    type: \"bool\"\n  }, {\n    internalType: \"uint24\",\n    name: \"_fee\",\n    type: \"uint24\"\n  }, {\n    internalType: \"bool\",\n    name: \"isV3\",\n    type: \"bool\"\n  }],\n  name: \"nftForEth\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"tokenAddress\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"tokenAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"sendTo\",\n    type: \"address\"\n  }],\n  name: \"recoverERC20\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_registry\",\n    type: \"address\"\n  }],\n  name: \"setNFT20\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"withdrawEth\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar NFT20Trade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(NFT20Trade, _NFTTrade);\n  function NFT20Trade(orders) {\n    return _NFTTrade.call(this, exports.Market.NFT20, orders) || this;\n  }\n  var _proto = NFT20Trade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var order = _step.value;\n      var calldata = NFT20Trade.INTERFACE.encodeFunctionData('ethForNft', [order.tokenAddress, order.tokenIds, order.tokenAmounts, order.recipient, order.fee, order.isV3]);\n      planner.addCommand(CommandType.NFT20, [order.value, calldata], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var pool = _step2.value;\n      for (var _iterator3 = _createForOfIteratorHelperLoose(pool.tokenIds), _step3; !(_step3 = _iterator3()).done;) {\n        var tokenId = _step3.value;\n        buyItems.push({\n          tokenAddress: pool.tokenAddress,\n          tokenId: tokenId,\n          tokenType: exports.TokenType.ERC721\n        });\n      }\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator4 = _createForOfIteratorHelperLoose(this.orders), _step4; !(_step4 = _iterator4()).done;) {\n      var item = _step4.value;\n      total = total.add(item.value);\n    }\n    return total;\n  };\n  return NFT20Trade;\n}(NFTTrade);\nNFT20Trade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$2);\nvar abi$3 = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"_nftxFactory\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_sushiRouter\",\n    type: \"address\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"count\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"ethSpent\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"Buy\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"count\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"ethReceived\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"Sell\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"count\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"ethSpent\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"Swap\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"WETH\",\n  outputs: [{\n    internalType: \"contract IWETH\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndRedeem\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxWethIn\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndRedeemWETH\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"idsIn\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndSwap1155\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"idsIn\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxWethIn\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndSwap1155WETH\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"idsIn\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndSwap721\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"idsIn\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"specificIds\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maxWethIn\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"buyAndSwap721WETH\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"lpStaking\",\n  outputs: [{\n    internalType: \"contract INFTXLPStaking\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minWethOut\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mintAndSell1155\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minWethOut\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mintAndSell1155WETH\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minEthOut\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mintAndSell721\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"vaultId\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"ids\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minWethOut\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address[]\",\n    name: \"path\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mintAndSell721WETH\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"nftxFactory\",\n  outputs: [{\n    internalType: \"contract INFTXVaultFactory\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"bytes\",\n    name: \"\",\n    type: \"bytes\"\n  }],\n  name: \"onERC1155BatchReceived\",\n  outputs: [{\n    internalType: \"bytes4\",\n    name: \"\",\n    type: \"bytes4\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }, {\n    internalType: \"bytes\",\n    name: \"\",\n    type: \"bytes\"\n  }],\n  name: \"onERC1155Received\",\n  outputs: [{\n    internalType: \"bytes4\",\n    name: \"\",\n    type: \"bytes4\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }, {\n    internalType: \"bytes\",\n    name: \"\",\n    type: \"bytes\"\n  }],\n  name: \"onERC721Received\",\n  outputs: [{\n    internalType: \"bytes4\",\n    name: \"\",\n    type: \"bytes4\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }],\n  name: \"rescue\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes4\",\n    name: \"interfaceId\",\n    type: \"bytes4\"\n  }],\n  name: \"supportsInterface\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"sushiRouter\",\n  outputs: [{\n    internalType: \"contract IUniswapV2Router01\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar NFTXTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(NFTXTrade, _NFTTrade);\n  function NFTXTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.NFTX, orders) || this;\n  }\n  var _proto = NFTXTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var order = _step.value;\n      var calldata = NFTXTrade.INTERFACE.encodeFunctionData('buyAndRedeem', [order.vaultId, order.tokenIds.length, order.tokenIds, [sdkCore.Ether.onChain(1).wrapped.address, order.vaultAddress], order.recipient]);\n      planner.addCommand(CommandType.NFTX, [order.value, calldata], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var order = _step2.value;\n      for (var _iterator3 = _createForOfIteratorHelperLoose(order.tokenIds), _step3; !(_step3 = _iterator3()).done;) {\n        var tokenId = _step3.value;\n        buyItems.push({\n          tokenAddress: order.tokenAddress,\n          tokenId: tokenId,\n          tokenType: exports.TokenType.ERC721\n        });\n      }\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator4 = _createForOfIteratorHelperLoose(this.orders), _step4; !(_step4 = _iterator4()).done;) {\n      var item = _step4.value;\n      total = total.add(item.value);\n    }\n    return total;\n  };\n  return NFTXTrade;\n}(NFTTrade);\nNFTXTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$3);\nvar abi$4 = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"conduitController\",\n    type: \"address\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  inputs: [],\n  name: \"BadContractSignature\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"BadFraction\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"BadReturnValueFromERC20OnTransfer\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint8\",\n    name: \"v\",\n    type: \"uint8\"\n  }],\n  name: \"BadSignatureV\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"ConsiderationCriteriaResolverOutOfRange\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"orderIndex\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"considerationIndex\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"shortfallAmount\",\n    type: \"uint256\"\n  }],\n  name: \"ConsiderationNotMet\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"CriteriaNotEnabledForItem\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"identifiers\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"amounts\",\n    type: \"uint256[]\"\n  }],\n  name: \"ERC1155BatchTransferGenericFailure\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"account\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"EtherTransferGenericFailure\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InexactFraction\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InsufficientEtherSupplied\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"Invalid1155BatchTransferEncoding\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidBasicOrderParameterEncoding\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"conduit\",\n    type: \"address\"\n  }],\n  name: \"InvalidCallToConduit\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidCanceller\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"conduitKey\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"address\",\n    name: \"conduit\",\n    type: \"address\"\n  }],\n  name: \"InvalidConduit\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidERC721TransferAmount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidFulfillmentComponentData\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"InvalidMsgValue\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidNativeOfferItem\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidProof\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"InvalidRestrictedOrder\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidSignature\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidSigner\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"InvalidTime\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"MismatchedFulfillmentOfferAndConsiderationComponents\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"enum Side\",\n    name: \"side\",\n    type: \"uint8\"\n  }],\n  name: \"MissingFulfillmentComponentOnAggregation\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"MissingItemAmount\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"MissingOriginalConsiderationItems\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"account\",\n    type: \"address\"\n  }],\n  name: \"NoContract\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NoReentrantCalls\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"NoSpecifiedOrdersAvailable\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"OfferAndConsiderationRequiredOnFulfillment\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"OfferCriteriaResolverOutOfRange\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"OrderAlreadyFilled\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"OrderCriteriaResolverOutOfRange\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"OrderIsCancelled\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"OrderPartiallyFilled\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"PartialFillsNotEnabledForOrder\",\n  type: \"error\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"identifier\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"TokenTransferGenericFailure\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"UnresolvedConsiderationCriteria\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"UnresolvedOfferCriteria\",\n  type: \"error\"\n}, {\n  inputs: [],\n  name: \"UnusedItemParameters\",\n  type: \"error\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"newCounter\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }],\n  name: \"CounterIncremented\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"zone\",\n    type: \"address\"\n  }],\n  name: \"OrderCancelled\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"zone\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    components: [{\n      internalType: \"enum ItemType\",\n      name: \"itemType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"address\",\n      name: \"token\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }],\n    indexed: false,\n    internalType: \"struct SpentItem[]\",\n    name: \"offer\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"enum ItemType\",\n      name: \"itemType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"address\",\n      name: \"token\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"recipient\",\n      type: \"address\"\n    }],\n    indexed: false,\n    internalType: \"struct ReceivedItem[]\",\n    name: \"consideration\",\n    type: \"tuple[]\"\n  }],\n  name: \"OrderFulfilled\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"zone\",\n    type: \"address\"\n  }],\n  name: \"OrderValidated\",\n  type: \"event\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"zone\",\n      type: \"address\"\n    }, {\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifierOrCriteria\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endAmount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OfferItem[]\",\n      name: \"offer\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifierOrCriteria\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ConsiderationItem[]\",\n      name: \"consideration\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"enum OrderType\",\n      name: \"orderType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"zoneHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"counter\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct OrderComponents[]\",\n    name: \"orders\",\n    type: \"tuple[]\"\n  }],\n  name: \"cancel\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"cancelled\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint120\",\n      name: \"numerator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"uint120\",\n      name: \"denominator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }, {\n      internalType: \"bytes\",\n      name: \"extraData\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct AdvancedOrder\",\n    name: \"advancedOrder\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"enum Side\",\n      name: \"side\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"index\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32[]\",\n      name: \"criteriaProof\",\n      type: \"bytes32[]\"\n    }],\n    internalType: \"struct CriteriaResolver[]\",\n    name: \"criteriaResolvers\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"fulfillerConduitKey\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"address\",\n    name: \"recipient\",\n    type: \"address\"\n  }],\n  name: \"fulfillAdvancedOrder\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"fulfilled\",\n    type: \"bool\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint120\",\n      name: \"numerator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"uint120\",\n      name: \"denominator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }, {\n      internalType: \"bytes\",\n      name: \"extraData\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct AdvancedOrder[]\",\n    name: \"advancedOrders\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"enum Side\",\n      name: \"side\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"index\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32[]\",\n      name: \"criteriaProof\",\n      type: \"bytes32[]\"\n    }],\n    internalType: \"struct CriteriaResolver[]\",\n    name: \"criteriaResolvers\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIndex\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct FulfillmentComponent[][]\",\n    name: \"offerFulfillments\",\n    type: \"tuple[][]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIndex\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct FulfillmentComponent[][]\",\n    name: \"considerationFulfillments\",\n    type: \"tuple[][]\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"fulfillerConduitKey\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"address\",\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maximumFulfilled\",\n    type: \"uint256\"\n  }],\n  name: \"fulfillAvailableAdvancedOrders\",\n  outputs: [{\n    internalType: \"bool[]\",\n    name: \"availableOrders\",\n    type: \"bool[]\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifier\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ReceivedItem\",\n      name: \"item\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct Execution[]\",\n    name: \"executions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct Order[]\",\n    name: \"orders\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIndex\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct FulfillmentComponent[][]\",\n    name: \"offerFulfillments\",\n    type: \"tuple[][]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIndex\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct FulfillmentComponent[][]\",\n    name: \"considerationFulfillments\",\n    type: \"tuple[][]\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"fulfillerConduitKey\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"uint256\",\n    name: \"maximumFulfilled\",\n    type: \"uint256\"\n  }],\n  name: \"fulfillAvailableOrders\",\n  outputs: [{\n    internalType: \"bool[]\",\n    name: \"availableOrders\",\n    type: \"bool[]\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifier\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ReceivedItem\",\n      name: \"item\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct Execution[]\",\n    name: \"executions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"considerationToken\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"considerationIdentifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"considerationAmount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"zone\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"offerToken\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"offerIdentifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"offerAmount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"enum BasicOrderType\",\n      name: \"basicOrderType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"zoneHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"offererConduitKey\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"fulfillerConduitKey\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"totalOriginalAdditionalRecipients\",\n      type: \"uint256\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct AdditionalRecipient[]\",\n      name: \"additionalRecipients\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct BasicOrderParameters\",\n    name: \"parameters\",\n    type: \"tuple\"\n  }],\n  name: \"fulfillBasicOrder\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"fulfilled\",\n    type: \"bool\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct Order\",\n    name: \"order\",\n    type: \"tuple\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"fulfillerConduitKey\",\n    type: \"bytes32\"\n  }],\n  name: \"fulfillOrder\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"fulfilled\",\n    type: \"bool\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"offerer\",\n    type: \"address\"\n  }],\n  name: \"getCounter\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"counter\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"zone\",\n      type: \"address\"\n    }, {\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifierOrCriteria\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endAmount\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OfferItem[]\",\n      name: \"offer\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifierOrCriteria\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endAmount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ConsiderationItem[]\",\n      name: \"consideration\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"enum OrderType\",\n      name: \"orderType\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"startTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"endTime\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"zoneHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"counter\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct OrderComponents\",\n    name: \"order\",\n    type: \"tuple\"\n  }],\n  name: \"getOrderHash\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"orderHash\",\n    type: \"bytes32\"\n  }],\n  name: \"getOrderStatus\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"isValidated\",\n    type: \"bool\"\n  }, {\n    internalType: \"bool\",\n    name: \"isCancelled\",\n    type: \"bool\"\n  }, {\n    internalType: \"uint256\",\n    name: \"totalFilled\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"totalSize\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"incrementCounter\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"newCounter\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"information\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"version\",\n    type: \"string\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"domainSeparator\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"address\",\n    name: \"conduitController\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint120\",\n      name: \"numerator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"uint120\",\n      name: \"denominator\",\n      type: \"uint120\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }, {\n      internalType: \"bytes\",\n      name: \"extraData\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct AdvancedOrder[]\",\n    name: \"advancedOrders\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"orderIndex\",\n      type: \"uint256\"\n    }, {\n      internalType: \"enum Side\",\n      name: \"side\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"index\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"identifier\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32[]\",\n      name: \"criteriaProof\",\n      type: \"bytes32[]\"\n    }],\n    internalType: \"struct CriteriaResolver[]\",\n    name: \"criteriaResolvers\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"uint256\",\n        name: \"orderIndex\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIndex\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct FulfillmentComponent[]\",\n      name: \"offerComponents\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"orderIndex\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIndex\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct FulfillmentComponent[]\",\n      name: \"considerationComponents\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct Fulfillment[]\",\n    name: \"fulfillments\",\n    type: \"tuple[]\"\n  }],\n  name: \"matchAdvancedOrders\",\n  outputs: [{\n    components: [{\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifier\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ReceivedItem\",\n      name: \"item\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct Execution[]\",\n    name: \"executions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct Order[]\",\n    name: \"orders\",\n    type: \"tuple[]\"\n  }, {\n    components: [{\n      components: [{\n        internalType: \"uint256\",\n        name: \"orderIndex\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIndex\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct FulfillmentComponent[]\",\n      name: \"offerComponents\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"orderIndex\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIndex\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct FulfillmentComponent[]\",\n      name: \"considerationComponents\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct Fulfillment[]\",\n    name: \"fulfillments\",\n    type: \"tuple[]\"\n  }],\n  name: \"matchOrders\",\n  outputs: [{\n    components: [{\n      components: [{\n        internalType: \"enum ItemType\",\n        name: \"itemType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"address\",\n        name: \"token\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"identifier\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address payable\",\n        name: \"recipient\",\n        type: \"address\"\n      }],\n      internalType: \"struct ReceivedItem\",\n      name: \"item\",\n      type: \"tuple\"\n    }, {\n      internalType: \"address\",\n      name: \"offerer\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"conduitKey\",\n      type: \"bytes32\"\n    }],\n    internalType: \"struct Execution[]\",\n    name: \"executions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"name\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"contractName\",\n    type: \"string\"\n  }],\n  stateMutability: \"pure\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"address\",\n        name: \"offerer\",\n        type: \"address\"\n      }, {\n        internalType: \"address\",\n        name: \"zone\",\n        type: \"address\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }],\n        internalType: \"struct OfferItem[]\",\n        name: \"offer\",\n        type: \"tuple[]\"\n      }, {\n        components: [{\n          internalType: \"enum ItemType\",\n          name: \"itemType\",\n          type: \"uint8\"\n        }, {\n          internalType: \"address\",\n          name: \"token\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256\",\n          name: \"identifierOrCriteria\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"startAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"uint256\",\n          name: \"endAmount\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address payable\",\n          name: \"recipient\",\n          type: \"address\"\n        }],\n        internalType: \"struct ConsiderationItem[]\",\n        name: \"consideration\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"enum OrderType\",\n        name: \"orderType\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"startTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"endTime\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"zoneHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"conduitKey\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint256\",\n        name: \"totalOriginalConsiderationItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct OrderParameters\",\n      name: \"parameters\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes\",\n      name: \"signature\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct Order[]\",\n    name: \"orders\",\n    type: \"tuple[]\"\n  }],\n  name: \"validate\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"validated\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}];\nvar SeaportTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(SeaportTrade, _NFTTrade);\n  function SeaportTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.Seaport, orders) || this;\n  }\n  var _proto = SeaportTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var order = _step.value;\n      var advancedOrders = [];\n      var orderFulfillments = order.items.map(function (_, index) {\n        return [{\n          orderIndex: index,\n          itemIndex: 0\n        }];\n      });\n      var considerationFulFillments = this.getConsiderationFulfillments(order.items);\n      for (var _iterator2 = _createForOfIteratorHelperLoose(order.items), _step2; !(_step2 = _iterator2()).done;) {\n        var item = _step2.value;\n        var _this$getAdvancedOrde = this.getAdvancedOrderParams(item),\n          advancedOrder = _this$getAdvancedOrde.advancedOrder;\n        advancedOrders.push(advancedOrder);\n      }\n      var calldata = void 0;\n      if (advancedOrders.length == 1) {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAdvancedOrder', [advancedOrders[0], [], SeaportTrade.OPENSEA_CONDUIT_KEY, order.recipient]);\n      } else {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAvailableAdvancedOrders', [advancedOrders, [], orderFulfillments, considerationFulFillments, SeaportTrade.OPENSEA_CONDUIT_KEY, order.recipient, 100]);\n      }\n      planner.addCommand(CommandType.SEAPORT, [this.getTotalPrice().toString(), calldata], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var order = _step3.value;\n      for (var _iterator4 = _createForOfIteratorHelperLoose(order.items), _step4; !(_step4 = _iterator4()).done;) {\n        var item = _step4.value;\n        for (var _iterator5 = _createForOfIteratorHelperLoose(item.parameters.offer), _step5; !(_step5 = _iterator5()).done;) {\n          var offer = _step5.value;\n          buyItems.push({\n            tokenAddress: offer.token,\n            tokenId: offer.identifierOrCriteria,\n            tokenType: exports.TokenType.ERC721\n          });\n        }\n      }\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var totalPrice = ethers.BigNumber.from(0);\n    for (var _iterator6 = _createForOfIteratorHelperLoose(this.orders), _step6; !(_step6 = _iterator6()).done;) {\n      var order = _step6.value;\n      for (var _iterator7 = _createForOfIteratorHelperLoose(order.items), _step7; !(_step7 = _iterator7()).done;) {\n        var item = _step7.value;\n        totalPrice = totalPrice.add(this.calculateValue(item.parameters.consideration));\n      }\n    }\n    return totalPrice;\n  };\n  _proto.getConsiderationFulfillments = function getConsiderationFulfillments(protocolDatas) {\n    var considerationFulfillments = [];\n    var considerationRecipients = [];\n    for (var i in protocolDatas) {\n      var protocolData = protocolDatas[i];\n      var _loop = function _loop(j) {\n        var item = protocolData.parameters.consideration[j];\n        if (considerationRecipients.findIndex(function (x) {\n          return x === item.recipient;\n        }) === -1) {\n          considerationRecipients.push(item.recipient);\n        }\n        var recipientIndex = considerationRecipients.findIndex(function (x) {\n          return x === item.recipient;\n        });\n        if (!considerationFulfillments[recipientIndex]) {\n          considerationFulfillments.push([{\n            orderIndex: i,\n            itemIndex: j\n          }]);\n        } else {\n          considerationFulfillments[recipientIndex].push({\n            orderIndex: i,\n            itemIndex: j\n          });\n        }\n      };\n      for (var j in protocolData.parameters.consideration) {\n        _loop(j);\n      }\n    }\n    return considerationFulfillments;\n  };\n  _proto.getAdvancedOrderParams = function getAdvancedOrderParams(data) {\n    var advancedOrder = {\n      parameters: data.parameters,\n      numerator: ethers.BigNumber.from('1'),\n      denominator: ethers.BigNumber.from('1'),\n      signature: data.signature,\n      extraData: '0x00'\n    };\n    var value = this.calculateValue(data.parameters.consideration);\n    return {\n      advancedOrder: advancedOrder,\n      value: value\n    };\n  };\n  _proto.calculateValue = function calculateValue(considerations) {\n    return considerations.reduce(function (amt, consideration) {\n      return amt.add(consideration.startAmount);\n    }, ethers.BigNumber.from(0));\n  };\n  return SeaportTrade;\n}(NFTTrade);\nSeaportTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$4);\nSeaportTrade.OPENSEA_CONDUIT_KEY = '0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000';\nvar abi$5 = [{\n  inputs: [{\n    internalType: \"contract ILSSVMPairFactoryLike\",\n    name: \"_factory\",\n    type: \"address\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  inputs: [],\n  name: \"factory\",\n  outputs: [{\n    internalType: \"contract ILSSVMPairFactoryLike\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"contract ERC20\",\n    name: \"token\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"enum ILSSVMPairFactoryLike.PairVariant\",\n    name: \"variant\",\n    type: \"uint8\"\n  }],\n  name: \"pairTransferERC20From\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"contract IERC721\",\n    name: \"nft\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"id\",\n    type: \"uint256\"\n  }, {\n    internalType: \"enum ILSSVMPairFactoryLike.PairVariant\",\n    name: \"variant\",\n    type: \"uint8\"\n  }],\n  name: \"pairTransferNFTFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"numItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapAny\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"maxCost\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapAny[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapERC20ForAnyNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"maxCost\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapERC20ForSpecificNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        components: [{\n          internalType: \"contract LSSVMPair\",\n          name: \"pair\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256[]\",\n          name: \"nftIds\",\n          type: \"uint256[]\"\n        }],\n        internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n        name: \"swapInfo\",\n        type: \"tuple\"\n      }, {\n        internalType: \"uint256\",\n        name: \"maxCost\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.RobustPairSwapSpecific[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        components: [{\n          internalType: \"contract LSSVMPair\",\n          name: \"pair\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256[]\",\n          name: \"nftIds\",\n          type: \"uint256[]\"\n        }],\n        internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n        name: \"swapInfo\",\n        type: \"tuple\"\n      }, {\n        internalType: \"uint256\",\n        name: \"minOutput\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.RobustPairSwapSpecificForToken[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"uint256\",\n      name: \"inputAmount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"tokenRecipient\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"nftRecipient\",\n      type: \"address\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairNFTsFoTokenAndTokenforNFTsTrade\",\n    name: \"params\",\n    type: \"tuple\"\n  }],\n  name: \"robustSwapERC20ForSpecificNFTsAndNFTsToToken\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"numItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapAny\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"maxCost\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapAny[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapETHForAnyNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"maxCost\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapETHForSpecificNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        components: [{\n          internalType: \"contract LSSVMPair\",\n          name: \"pair\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256[]\",\n          name: \"nftIds\",\n          type: \"uint256[]\"\n        }],\n        internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n        name: \"swapInfo\",\n        type: \"tuple\"\n      }, {\n        internalType: \"uint256\",\n        name: \"maxCost\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.RobustPairSwapSpecific[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        components: [{\n          internalType: \"contract LSSVMPair\",\n          name: \"pair\",\n          type: \"address\"\n        }, {\n          internalType: \"uint256[]\",\n          name: \"nftIds\",\n          type: \"uint256[]\"\n        }],\n        internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n        name: \"swapInfo\",\n        type: \"tuple\"\n      }, {\n        internalType: \"uint256\",\n        name: \"minOutput\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.RobustPairSwapSpecificForToken[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"uint256\",\n      name: \"inputAmount\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address payable\",\n      name: \"tokenRecipient\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"nftRecipient\",\n      type: \"address\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairNFTsFoTokenAndTokenforNFTsTrade\",\n    name: \"params\",\n    type: \"tuple\"\n  }],\n  name: \"robustSwapETHForSpecificNFTsAndNFTsToToken\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific\",\n      name: \"swapInfo\",\n      type: \"tuple\"\n    }, {\n      internalType: \"uint256\",\n      name: \"minOutput\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.RobustPairSwapSpecificForToken[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"tokenRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"robustSwapNFTsForToken\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"numItems\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapAny[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapERC20ForAnyNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256[]\",\n      name: \"nftIds\",\n      type: \"uint256[]\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapERC20ForSpecificNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"numItems\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapAny[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapETHForAnyNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256[]\",\n      name: \"nftIds\",\n      type: \"uint256[]\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapETHForSpecificNFTs\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"remainingValue\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"numItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapAny[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct LSSVMRouter.NFTsForAnyNFTsTrade\",\n    name: \"trade\",\n    type: \"tuple\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForAnyNFTsThroughERC20\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"numItems\",\n        type: \"uint256\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapAny[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct LSSVMRouter.NFTsForAnyNFTsTrade\",\n    name: \"trade\",\n    type: \"tuple\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForAnyNFTsThroughETH\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct LSSVMRouter.NFTsForSpecificNFTsTrade\",\n    name: \"trade\",\n    type: \"tuple\"\n  }, {\n    internalType: \"uint256\",\n    name: \"inputAmount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForSpecificNFTsThroughERC20\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"nftToTokenTrades\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"contract LSSVMPair\",\n        name: \"pair\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256[]\",\n        name: \"nftIds\",\n        type: \"uint256[]\"\n      }],\n      internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n      name: \"tokenToNFTTrades\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct LSSVMRouter.NFTsForSpecificNFTsTrade\",\n    name: \"trade\",\n    type: \"tuple\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address payable\",\n    name: \"ethRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"nftRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForSpecificNFTsThroughETH\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"contract LSSVMPair\",\n      name: \"pair\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256[]\",\n      name: \"nftIds\",\n      type: \"uint256[]\"\n    }],\n    internalType: \"struct LSSVMRouter.PairSwapSpecific[]\",\n    name: \"swapList\",\n    type: \"tuple[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"minOutput\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"tokenRecipient\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }],\n  name: \"swapNFTsForToken\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"outputAmount\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar SudoswapTrade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(SudoswapTrade, _NFTTrade);\n  function SudoswapTrade(orders) {\n    return _NFTTrade.call(this, exports.Market.Sudoswap, orders) || this;\n  }\n  var _proto = SudoswapTrade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var order = _step.value;\n      var calldata = SudoswapTrade.INTERFACE.encodeFunctionData('robustSwapETHForSpecificNFTs', [order.swaps.map(function (swap) {\n        return {\n          swapInfo: swap.swapInfo,\n          maxCost: swap.maxCost\n        };\n      }), order.ethRecipient, order.nftRecipient, order.deadline]);\n      var value = order.swaps.reduce(function (prevVal, swap) {\n        return prevVal.add(swap.maxCost);\n      }, ethers.BigNumber.from(0));\n      planner.addCommand(CommandType.SUDOSWAP, [value, calldata], config.allowRevert);\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var order = _step2.value;\n      for (var _iterator3 = _createForOfIteratorHelperLoose(order.swaps), _step3; !(_step3 = _iterator3()).done;) {\n        var swap = _step3.value;\n        for (var _iterator4 = _createForOfIteratorHelperLoose(swap.swapInfo.nftIds), _step4; !(_step4 = _iterator4()).done;) {\n          var tokenId = _step4.value;\n          buyItems.push({\n            tokenAddress: swap.tokenAddress,\n            tokenId: tokenId,\n            tokenType: exports.TokenType.ERC721\n          });\n        }\n      }\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator5 = _createForOfIteratorHelperLoose(this.orders), _step5; !(_step5 = _iterator5()).done;) {\n      var order = _step5.value;\n      for (var _iterator6 = _createForOfIteratorHelperLoose(order.swaps), _step6; !(_step6 = _iterator6()).done;) {\n        var swap = _step6.value;\n        total = total.add(swap.maxCost);\n      }\n    }\n    return total;\n  };\n  return SudoswapTrade;\n}(NFTTrade);\nSudoswapTrade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$5);\nvar abi$6 = [{\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"bytes32\",\n    name: \"itemHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"incentive\",\n    type: \"uint256\"\n  }],\n  name: \"EvAuctionRefund\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"bytes32\",\n    name: \"itemHash\",\n    type: \"bytes32\"\n  }],\n  name: \"EvCancel\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"delegate\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"bool\",\n    name: \"isRemoval\",\n    type: \"bool\"\n  }],\n  name: \"EvDelegate\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"index\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"bytes\",\n    name: \"error\",\n    type: \"bytes\"\n  }],\n  name: \"EvFailure\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"newValue\",\n    type: \"uint256\"\n  }],\n  name: \"EvFeeCapUpdate\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"bytes32\",\n    name: \"itemHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"maker\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"taker\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"orderSalt\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"settleSalt\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"intent\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"delegateType\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"contract IERC20Upgradeable\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"bytes\",\n    name: \"dataMask\",\n    type: \"bytes\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes\",\n      name: \"data\",\n      type: \"bytes\"\n    }],\n    indexed: false,\n    internalType: \"struct Market.OrderItem\",\n    name: \"item\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"enum Market.Op\",\n      name: \"op\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"orderIdx\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIdx\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"itemHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"contract IDelegate\",\n      name: \"executionDelegate\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes\",\n      name: \"dataReplacement\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint256\",\n      name: \"bidIncentivePct\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"aucMinIncrementPct\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"aucIncDurationSecs\",\n      type: \"uint256\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"percentage\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      }],\n      internalType: \"struct Market.Fee[]\",\n      name: \"fees\",\n      type: \"tuple[]\"\n    }],\n    indexed: false,\n    internalType: \"struct Market.SettleDetail\",\n    name: \"detail\",\n    type: \"tuple\"\n  }],\n  name: \"EvInventory\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"bytes32\",\n    name: \"itemHash\",\n    type: \"bytes32\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"currency\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"EvProfit\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"signer\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"bool\",\n    name: \"isRemoval\",\n    type: \"bool\"\n  }],\n  name: \"EvSigner\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"account\",\n    type: \"address\"\n  }],\n  name: \"Paused\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"account\",\n    type: \"address\"\n  }],\n  name: \"Unpaused\",\n  type: \"event\"\n}, {\n  inputs: [],\n  name: \"RATE_BASE\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes32[]\",\n    name: \"itemHashes\",\n    type: \"bytes32[]\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint8\",\n    name: \"v\",\n    type: \"uint8\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"r\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"s\",\n    type: \"bytes32\"\n  }],\n  name: \"cancel\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"delegates\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"feeCapPct\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"feeCapPct_\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"weth_\",\n    type: \"address\"\n  }],\n  name: \"initialize\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  name: \"inventoryStatus\",\n  outputs: [{\n    internalType: \"enum Market.InvStatus\",\n    name: \"\",\n    type: \"uint8\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  name: \"ongoingAuctions\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"price\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"netPrice\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"endAt\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"bidder\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"pause\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"paused\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      components: [{\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address\",\n        name: \"user\",\n        type: \"address\"\n      }, {\n        internalType: \"uint256\",\n        name: \"network\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"intent\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"delegateType\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"deadline\",\n        type: \"uint256\"\n      }, {\n        internalType: \"contract IERC20Upgradeable\",\n        name: \"currency\",\n        type: \"address\"\n      }, {\n        internalType: \"bytes\",\n        name: \"dataMask\",\n        type: \"bytes\"\n      }, {\n        components: [{\n          internalType: \"uint256\",\n          name: \"price\",\n          type: \"uint256\"\n        }, {\n          internalType: \"bytes\",\n          name: \"data\",\n          type: \"bytes\"\n        }],\n        internalType: \"struct Market.OrderItem[]\",\n        name: \"items\",\n        type: \"tuple[]\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"r\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"s\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"uint8\",\n        name: \"v\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint8\",\n        name: \"signVersion\",\n        type: \"uint8\"\n      }],\n      internalType: \"struct Market.Order[]\",\n      name: \"orders\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"enum Market.Op\",\n        name: \"op\",\n        type: \"uint8\"\n      }, {\n        internalType: \"uint256\",\n        name: \"orderIdx\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"itemIdx\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"price\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes32\",\n        name: \"itemHash\",\n        type: \"bytes32\"\n      }, {\n        internalType: \"contract IDelegate\",\n        name: \"executionDelegate\",\n        type: \"address\"\n      }, {\n        internalType: \"bytes\",\n        name: \"dataReplacement\",\n        type: \"bytes\"\n      }, {\n        internalType: \"uint256\",\n        name: \"bidIncentivePct\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"aucMinIncrementPct\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"aucIncDurationSecs\",\n        type: \"uint256\"\n      }, {\n        components: [{\n          internalType: \"uint256\",\n          name: \"percentage\",\n          type: \"uint256\"\n        }, {\n          internalType: \"address\",\n          name: \"to\",\n          type: \"address\"\n        }],\n        internalType: \"struct Market.Fee[]\",\n        name: \"fees\",\n        type: \"tuple[]\"\n      }],\n      internalType: \"struct Market.SettleDetail[]\",\n      name: \"details\",\n      type: \"tuple[]\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"salt\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"deadline\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amountToEth\",\n        type: \"uint256\"\n      }, {\n        internalType: \"uint256\",\n        name: \"amountToWeth\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address\",\n        name: \"user\",\n        type: \"address\"\n      }, {\n        internalType: \"bool\",\n        name: \"canFail\",\n        type: \"bool\"\n      }],\n      internalType: \"struct Market.SettleShared\",\n      name: \"shared\",\n      type: \"tuple\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }],\n    internalType: \"struct Market.RunInput\",\n    name: \"input\",\n    type: \"tuple\"\n  }],\n  name: \"run\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    components: [{\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"user\",\n      type: \"address\"\n    }, {\n      internalType: \"uint256\",\n      name: \"network\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"intent\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"delegateType\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }, {\n      internalType: \"contract IERC20Upgradeable\",\n      name: \"currency\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes\",\n      name: \"dataMask\",\n      type: \"bytes\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"price\",\n        type: \"uint256\"\n      }, {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\"\n      }],\n      internalType: \"struct Market.OrderItem[]\",\n      name: \"items\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"r\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"s\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"uint8\",\n      name: \"v\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint8\",\n      name: \"signVersion\",\n      type: \"uint8\"\n    }],\n    internalType: \"struct Market.Order\",\n    name: \"order\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"uint256\",\n      name: \"salt\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"deadline\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amountToEth\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"amountToWeth\",\n      type: \"uint256\"\n    }, {\n      internalType: \"address\",\n      name: \"user\",\n      type: \"address\"\n    }, {\n      internalType: \"bool\",\n      name: \"canFail\",\n      type: \"bool\"\n    }],\n    internalType: \"struct Market.SettleShared\",\n    name: \"shared\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"enum Market.Op\",\n      name: \"op\",\n      type: \"uint8\"\n    }, {\n      internalType: \"uint256\",\n      name: \"orderIdx\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"itemIdx\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"price\",\n      type: \"uint256\"\n    }, {\n      internalType: \"bytes32\",\n      name: \"itemHash\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"contract IDelegate\",\n      name: \"executionDelegate\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes\",\n      name: \"dataReplacement\",\n      type: \"bytes\"\n    }, {\n      internalType: \"uint256\",\n      name: \"bidIncentivePct\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"aucMinIncrementPct\",\n      type: \"uint256\"\n    }, {\n      internalType: \"uint256\",\n      name: \"aucIncDurationSecs\",\n      type: \"uint256\"\n    }, {\n      components: [{\n        internalType: \"uint256\",\n        name: \"percentage\",\n        type: \"uint256\"\n      }, {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      }],\n      internalType: \"struct Market.Fee[]\",\n      name: \"fees\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct Market.SettleDetail\",\n    name: \"detail\",\n    type: \"tuple\"\n  }],\n  name: \"run1\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"signers\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"unpause\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address[]\",\n    name: \"toAdd\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"toRemove\",\n    type: \"address[]\"\n  }],\n  name: \"updateDelegates\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"val\",\n    type: \"uint256\"\n  }],\n  name: \"updateFeeCap\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address[]\",\n    name: \"toAdd\",\n    type: \"address[]\"\n  }, {\n    internalType: \"address[]\",\n    name: \"toRemove\",\n    type: \"address[]\"\n  }],\n  name: \"updateSigners\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"weth\",\n  outputs: [{\n    internalType: \"contract IWETHUpgradable\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  stateMutability: \"payable\",\n  type: \"receive\"\n}];\nvar X2Y2Trade = /*#__PURE__*/function (_NFTTrade) {\n  _inheritsLoose(X2Y2Trade, _NFTTrade);\n  function X2Y2Trade(orders) {\n    return _NFTTrade.call(this, exports.Market.X2Y2, orders) || this;\n  }\n  var _proto = X2Y2Trade.prototype;\n  _proto.encode = function encode(planner, config) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.orders), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      var functionSelector = X2Y2Trade.INTERFACE.getSighash(X2Y2Trade.INTERFACE.getFunction('run'));\n      var calldata = functionSelector + item.signedInput.slice(2);\n      if (item.tokenType == exports.TokenType.ERC721) {\n        planner.addCommand(CommandType.X2Y2_721, [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId], config.allowRevert);\n      } else if (item.tokenType == exports.TokenType.ERC1155) {\n        planner.addCommand(CommandType.X2Y2_1155, [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId, item.tokenAmount], config.allowRevert);\n      }\n    }\n  };\n  _proto.getBuyItems = function getBuyItems() {\n    var buyItems = [];\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.orders), _step2; !(_step2 = _iterator2()).done;) {\n      var item = _step2.value;\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: item.tokenType\n      });\n    }\n    return buyItems;\n  };\n  _proto.getTotalPrice = function getTotalPrice() {\n    var total = ethers.BigNumber.from(0);\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.orders), _step3; !(_step3 = _iterator3()).done;) {\n      var item = _step3.value;\n      total = total.add(item.price);\n    }\n    return total;\n  };\n  return X2Y2Trade;\n}(NFTTrade);\nX2Y2Trade.INTERFACE = /*#__PURE__*/new abi$7.Interface(abi$6);\nvar UnwrapWETH = /*#__PURE__*/function () {\n  function UnwrapWETH(amount, chainId, permit2) {\n    this.tradeType = exports.RouterTradeType.UnwrapWETH;\n    this.wethAddress = WETH_ADDRESS(chainId);\n    this.routerAddress = UNIVERSAL_ROUTER_ADDRESS(chainId);\n    this.amount = amount;\n    if (!!permit2) {\n      !(permit2.details.token === this.wethAddress) ? invariant(false, \"must be permitting WETH address: \" + this.wethAddress) : void 0;\n      !(permit2.details.amount >= amount) ? invariant(false, \"Did not permit enough WETH for unwrapWETH transaction\") : void 0;\n      this.permit2Data = permit2;\n    }\n  }\n  var _proto = UnwrapWETH.prototype;\n  _proto.encode = function encode(planner, _) {\n    if (!!this.permit2Data) encodePermit(planner, this.permit2Data);\n    planner.addCommand(CommandType.PERMIT2_TRANSFER_FROM, [this.wethAddress, this.routerAddress, this.amount]);\n    planner.addCommand(CommandType.UNWRAP_WETH, [ROUTER_AS_RECIPIENT, this.amount]);\n  };\n  return UnwrapWETH;\n}();\nexports.CryptopunkTrade = CryptopunkTrade;\nexports.FoundationTrade = FoundationTrade;\nexports.LooksRareTrade = LooksRareTrade;\nexports.NFT20Trade = NFT20Trade;\nexports.NFTTrade = NFTTrade;\nexports.NFTXTrade = NFTXTrade;\nexports.PERMIT2_ADDRESS = PERMIT2_ADDRESS;\nexports.ROUTER_AS_RECIPIENT = ROUTER_AS_RECIPIENT;\nexports.SeaportTrade = SeaportTrade;\nexports.SudoswapTrade = SudoswapTrade;\nexports.SwapRouter = SwapRouter;\nexports.UNIVERSAL_ROUTER_ADDRESS = UNIVERSAL_ROUTER_ADDRESS;\nexports.UniswapTrade = UniswapTrade;\nexports.UnwrapWETH = UnwrapWETH;\nexports.WETH_ADDRESS = WETH_ADDRESS;\nexports.X2Y2Trade = X2Y2Trade;","map":{"version":3,"sources":["../src/entities/Command.ts","../src/utils/routerCommands.ts","../src/utils/constants.ts","../src/entities/protocols/uniswap.ts","../src/utils/permit2.ts","../src/swapRouter.ts","../src/entities/NFTTrade.ts","../src/entities/protocols/cryptopunk.ts","../src/entities/protocols/foundation.ts","../src/entities/protocols/looksRare.ts","../src/entities/protocols/nft20.ts","../src/entities/protocols/nftx.ts","../src/entities/protocols/seaport.ts","../src/entities/protocols/sudoswap.ts","../src/entities/protocols/x2y2.ts","../src/entities/protocols/unwrapWETH.ts"],"names":["RouterTradeType","CommandType","PERMIT_STRUCT","PERMIT_BATCH_STRUCT","ALLOW_REVERT_FLAG","REVERTABLE_COMMANDS","Set","SEAPORT","NFTX","LOOKS_RARE_721","LOOKS_RARE_1155","X2Y2_721","X2Y2_1155","FOUNDATION","SUDOSWAP","NFT20","CRYPTOPUNKS","ABI_DEFINITION","PERMIT","PERMIT2_PERMIT_BATCH","PERMIT2_TRANSFER_FROM","PERMIT2_TRANSFER_FROM_BATCH","TRANSFER","V3_SWAP_EXACT_IN","V3_SWAP_EXACT_OUT","V2_SWAP_EXACT_IN","V2_SWAP_EXACT_OUT","WRAP_ETH","UNWRAP_WETH","SWEEP","PAY_PORTION","OWNER_CHECK_721","OWNER_CHECK_1155","RoutePlanner","commands","inputs","addCommand","type","parameters","allowRevert","command","createCommand","push","encodedInput","has","Error","concat","toString","padStart","defaultAbiCoder","encode","UNIVERSAL_ROUTER_ADDRESS","chainId","PERMIT2_ADDRESS","CONTRACT_BALANCE","ROUTER_AS_RECIPIENT","REFUND_ETH_PRICE_IMPACT_THRESHOLD","Percent","trade","inputAmount","currency","planner","payerIsUser","options","recipient","SENDER_AS_RECIPIENT","swap","route","protocol","Protocol","addV2Swap","routerMustCustody","V3","addV3Swap","addMixedSwap","outputIsNative","inputIsNative","outputAmount","V2Trade","tradeType","TradeType","maximumAmountIn","slippageTolerance","quotient","pool","address","minimumAmountOut","V3Trade","createUncheckedTrade","encodeRouteToPath","tradeRecipient","pools","length","Pool","sections","partitionMixedRouteByProtocol","isLastSectionInRoute","outputToken","inputToken","input","i","getOutputOfPools","newRouteOriginal","MixedRouteSDK","newRoute","MixedRoute","mixedRouteIsAllV3","encodeMixedRouteToPath","SIGNATURE_LENGTH","EIP_2098_SIGNATURE_LENGTH","ethers","signature","utils","joinSignature","permit","SwapRouter","config","Array","trades","nftTrades","filter","transactionValue","BigNumber","from","nftTrade","tradePrice","currentNativeValueInRouter","swapOptions","uniswapTrade","inputTokenPermit","encodePermit","add","totalPrice","inputCurrency","nativeCurrencyValue","encodePlan","deadline","deadlineOrPreviousBlockhash","functionSignature","calldata","INTERFACE","value","toHexString","NFTTrade","orders","Market","TokenType","CryptopunkTrade","item","getBuyItems","buyItems","tokenAddress","tokenId","tokenType","total","FoundationTrade","LooksRareTrade","ERC721","makerOrder","NFT20Trade","order","NFTXTrade","SeaportTrade","advancedOrders","orderFulfillments","map","orderIndex","index","itemIndex","considerationFulFillments","advancedOrder","encodeFunctionData","getTotalPrice","offer","identifierOrCriteria","consideration","considerationRecipients","protocolDatas","j","protocolData","recipientIndex","x","considerationFulfillments","numerator","denominator","extraData","calculateValue","data","considerations","SudoswapTrade","swapInfo","maxCost","swaps","reduce","prevVal","nftIds","X2Y2Trade","functionSelector","signedInput","ERC1155","price","UnwrapWETH","routerAddress","amount","permit2","details","wethAddress","permit2Data"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","sourcesContent":["import { RoutePlanner } from '../utils/routerCommands'\n\nexport type TradeConfig = {\n  allowRevert: boolean\n}\n\nexport enum RouterTradeType {\n  UniswapTrade = 'UniswapTrade',\n  NFTTrade = 'NFTTrade',\n  UnwrapWETH = 'UnwrapWETH',\n}\n\n// interface for entities that can be encoded as a Universal Router command\nexport interface Command {\n  tradeType: RouterTradeType\n  encode(planner: RoutePlanner, config: TradeConfig): void\n}\n","import { defaultAbiCoder } from 'ethers/lib/utils'\n\n/**\n * CommandTypes\n * @description Flags that modify a command's execution\n * @enum {number}\n */\nexport enum CommandType {\n  V3_SWAP_EXACT_IN = 0x00,\n  V3_SWAP_EXACT_OUT = 0x01,\n  PERMIT2_TRANSFER_FROM = 0x02,\n  PERMIT2_PERMIT_BATCH = 0x03,\n  SWEEP = 0x04,\n  TRANSFER = 0x05,\n  PAY_PORTION = 0x06,\n\n  V2_SWAP_EXACT_IN = 0x08,\n  V2_SWAP_EXACT_OUT = 0x09,\n  PERMIT = 0x0a,\n  WRAP_ETH = 0x0b,\n  UNWRAP_WETH = 0x0c,\n  PERMIT2_TRANSFER_FROM_BATCH = 0x0d,\n\n  // NFT-related command types\n  SEAPORT = 0x10,\n  LOOKS_RARE_721 = 0x11,\n  NFTX = 0x12,\n  CRYPTOPUNKS = 0x13,\n  LOOKS_RARE_1155 = 0x14,\n  OWNER_CHECK_721 = 0x15,\n  OWNER_CHECK_1155 = 0x16,\n\n  X2Y2_721 = 0x18,\n  SUDOSWAP = 0x19,\n  NFT20 = 0x1a,\n  X2Y2_1155 = 0x1b,\n  FOUNDATION = 0x1c,\n}\n\nconst PERMIT_STRUCT =\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce) details, address spender, uint256 sigDeadline)'\n\nconst PERMIT_BATCH_STRUCT =\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce)[] details, address spender, uint256 sigDeadline)'\n\nconst ALLOW_REVERT_FLAG = 0x80\n\nconst REVERTABLE_COMMANDS = new Set<CommandType>([\n  CommandType.SEAPORT,\n  CommandType.NFTX,\n  CommandType.LOOKS_RARE_721,\n  CommandType.LOOKS_RARE_1155,\n  CommandType.X2Y2_721,\n  CommandType.X2Y2_1155,\n  CommandType.FOUNDATION,\n  CommandType.SUDOSWAP,\n  CommandType.NFT20,\n  CommandType.CRYPTOPUNKS,\n])\n\nconst ABI_DEFINITION: { [key in CommandType]: string[] } = {\n  [CommandType.PERMIT]: [PERMIT_STRUCT, 'bytes'],\n  [CommandType.PERMIT2_PERMIT_BATCH]: [PERMIT_BATCH_STRUCT, 'bytes'],\n  [CommandType.PERMIT2_TRANSFER_FROM]: ['address', 'address', 'uint160'],\n  [CommandType.PERMIT2_TRANSFER_FROM_BATCH]: ['bytes'],\n  [CommandType.TRANSFER]: ['address', 'address', 'uint256'],\n  [CommandType.V3_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\n  [CommandType.V3_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\n  [CommandType.V2_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\n  [CommandType.V2_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\n  [CommandType.SEAPORT]: ['uint256', 'bytes'],\n  [CommandType.WRAP_ETH]: ['address', 'uint256'],\n  [CommandType.UNWRAP_WETH]: ['address', 'uint256'],\n  [CommandType.SWEEP]: ['address', 'address', 'uint256'],\n  [CommandType.NFTX]: ['uint256', 'bytes'],\n  [CommandType.LOOKS_RARE_721]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.LOOKS_RARE_1155]: ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'],\n  [CommandType.X2Y2_721]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.X2Y2_1155]: ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'],\n  [CommandType.FOUNDATION]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.PAY_PORTION]: ['address', 'address', 'uint256'],\n  [CommandType.SUDOSWAP]: ['uint256', 'bytes'],\n  [CommandType.OWNER_CHECK_721]: ['address', 'address', 'uint256'],\n  [CommandType.OWNER_CHECK_1155]: ['address', 'address', 'uint256', 'uint256'],\n  [CommandType.NFT20]: ['uint256', 'bytes'],\n  [CommandType.CRYPTOPUNKS]: ['uint256', 'address', 'uint256'],\n}\n\nexport class RoutePlanner {\n  commands: string\n  inputs: string[]\n\n  constructor() {\n    this.commands = '0x'\n    this.inputs = []\n  }\n\n  addCommand(type: CommandType, parameters: any[], allowRevert = false): void {\n    let command = createCommand(type, parameters)\n    this.inputs.push(command.encodedInput)\n    if (allowRevert) {\n      if (!REVERTABLE_COMMANDS.has(command.type)) {\n        throw new Error(`command type: ${command.type} cannot be allowed to revert`)\n      }\n      command.type = command.type | ALLOW_REVERT_FLAG\n    }\n\n    this.commands = this.commands.concat(command.type.toString(16).padStart(2, '0'))\n  }\n}\n\nexport type RouterCommand = {\n  type: CommandType\n  encodedInput: string\n}\n\nexport function createCommand(type: CommandType, parameters: any[]): RouterCommand {\n  const encodedInput = defaultAbiCoder.encode(ABI_DEFINITION[type], parameters)\n  return { type, encodedInput }\n}\n","import { BigNumber } from 'ethers'\n\nexport const UNIVERSAL_ROUTER_ADDRESS = (chainId: number): string => {\n  switch (chainId) {\n    case 1: // mainnet\n      return '0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B'\n    case 5: // goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 137: // polygon\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5'\n    case 80001: // polygon mumbai\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 10: // optimism\n      return '0xb555edF5dcF85f42cEeF1f3630a52A108E55A654'\n    case 420: // optimism goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 42161: // arbitrum\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5'\n    case 421613: // arbitrum goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 42220: // celo\n      return '0xC73d61d192FB994157168Fb56730FdEc64C9Cb8F'\n    case 44787: // celo alfajores\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 56: // binance smart chain\n      return '0x5Dc88340E1c5c6366864Ee415d6034cadd1A9897'\n    default:\n      throw new Error(`Universal Router not deployed on chain ${chainId}`)\n  }\n}\n\nexport const WETH_ADDRESS = (chainId: number): string => {\n  switch (chainId) {\n    case 1: //mainnet\n      return '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'\n    case 5: // goerli\n      return '0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6'\n    case 137: // polygon\n      return '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270'\n    case 80001: // polygon mumbai\n      return '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889'\n    case 10: // optimism\n      return '0x4200000000000000000000000000000000000006'\n    case 420: // optimism goerli\n      return '0x4200000000000000000000000000000000000006'\n    case 42161: // arbitrum\n      return '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1'\n    case 421613: // arbitrum goerli\n      return '0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3'\n    case 56: // binance smart chain\n      return '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'\n    default:\n      throw new Error(`WETH9 or UniversalRouter not deployed on chain ${chainId}`)\n  }\n}\n\nexport const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3'\n\nexport const CONTRACT_BALANCE = BigNumber.from(2).pow(255)\nexport const ETH_ADDRESS = '0x0000000000000000000000000000000000000000'\n\nexport const SENDER_AS_RECIPIENT = '0x0000000000000000000000000000000000000001'\nexport const ROUTER_AS_RECIPIENT = '0x0000000000000000000000000000000000000002'\n","import JSBI from 'jsbi'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { Trade as V2Trade, Pair } from '@uniswap/v2-sdk'\nimport { Trade as V3Trade, Pool, encodeRouteToPath } from '@uniswap/v3-sdk'\nimport {\n  Trade as RouterTrade,\n  MixedRouteTrade,\n  Protocol,\n  IRoute,\n  RouteV2,\n  RouteV3,\n  MixedRouteSDK,\n  MixedRoute,\n  SwapOptions as RouterSwapOptions,\n  getOutputOfPools,\n  encodeMixedRouteToPath,\n  partitionMixedRouteByProtocol,\n} from '@uniswap/router-sdk'\nimport { Permit2Permit } from '../../utils/permit2'\nimport { Currency, TradeType, CurrencyAmount, Percent } from '@uniswap/sdk-core'\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\nimport { SENDER_AS_RECIPIENT, ROUTER_AS_RECIPIENT, CONTRACT_BALANCE } from '../../utils/constants'\n\n// the existing router permit object doesn't include enough data for permit2\n// so we extend swap options with the permit2 permit\nexport type SwapOptions = Omit<RouterSwapOptions, 'inputTokenPermit'> & {\n  inputTokenPermit?: Permit2Permit\n}\n\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(JSBI.BigInt(50), JSBI.BigInt(100))\n\ninterface Swap<TInput extends Currency, TOutput extends Currency> {\n  route: IRoute<TInput, TOutput, Pair | Pool>\n  inputAmount: CurrencyAmount<TInput>\n  outputAmount: CurrencyAmount<TOutput>\n}\n\n// Wrapper for uniswap router-sdk trade entity to encode swaps for Universal Router\n// also translates trade objects from previous (v2, v3) SDKs\nexport class UniswapTrade implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.UniswapTrade\n  constructor(public trade: RouterTrade<Currency, Currency, TradeType>, public options: SwapOptions) {}\n\n  encode(planner: RoutePlanner, _config: TradeConfig): void {\n    let payerIsUser = true\n    if (this.trade.inputAmount.currency.isNative) {\n      // TODO: optimize if only one v2 pool we can directly send this to the pool\n      planner.addCommand(CommandType.WRAP_ETH, [\n        ROUTER_AS_RECIPIENT,\n        this.trade.maximumAmountIn(this.options.slippageTolerance).quotient.toString(),\n      ])\n      // since WETH is now owned by the router, the router pays for inputs\n      payerIsUser = false\n    }\n    this.options.recipient = this.options.recipient ?? SENDER_AS_RECIPIENT\n\n    // flag for whether we want to perform slippage check on aggregate output of multiple routes\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck =\n      this.trade.tradeType === TradeType.EXACT_INPUT && this.trade.routes.length > 2\n    const outputIsNative = this.trade.outputAmount.currency.isNative\n    const inputIsNative = this.trade.inputAmount.currency.isNative\n    const routerMustCustody = performAggregatedSlippageCheck || outputIsNative\n\n    for (const swap of this.trade.swaps) {\n      switch (swap.route.protocol) {\n        case Protocol.V2:\n          addV2Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        case Protocol.V3:\n          addV3Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        case Protocol.MIXED:\n          addMixedSwap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        default:\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL')\n      }\n    }\n\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        planner.addCommand(CommandType.UNWRAP_WETH, [\n          this.options.recipient,\n          this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString(),\n        ])\n      } else {\n        planner.addCommand(CommandType.SWEEP, [\n          this.trade.outputAmount.currency.wrapped.address,\n          this.options.recipient,\n          this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString(),\n        ])\n      }\n    }\n\n    if (inputIsNative && (this.trade.tradeType === TradeType.EXACT_OUTPUT || riskOfPartialFill(this.trade))) {\n      // for exactOutput swaps that take native currency as input\n      // we need to send back the change to the user\n      planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, 0])\n    }\n  }\n}\n\n// encode a uniswap v2 swap\nfunction addV2Swap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const trade = new V2Trade(\n    route as RouteV2<TInput, TOutput>,\n    tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n    tradeType\n  )\n\n  if (tradeType == TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n      // if native, we have to unwrap so keep in the router for now\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      route.path.map((pool) => pool.address),\n      payerIsUser,\n    ])\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_OUT, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      route.path.map((pool) => pool.address),\n      payerIsUser,\n    ])\n  }\n}\n\n// encode a uniswap v3 swap\nfunction addV3Swap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const trade = V3Trade.createUncheckedTrade({\n    route: route as RouteV3<TInput, TOutput>,\n    inputAmount,\n    outputAmount,\n    tradeType,\n  })\n\n  const path = encodeRouteToPath(route as RouteV3<TInput, TOutput>, trade.tradeType === TradeType.EXACT_OUTPUT)\n  if (tradeType == TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      path,\n      payerIsUser,\n    ])\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_OUT, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      path,\n      payerIsUser,\n    ])\n  }\n}\n\n// encode a mixed route swap, i.e. including both v2 and v3 pools\nfunction addMixedSwap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  swap: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const { route, inputAmount, outputAmount } = swap\n  const tradeRecipient = routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient\n\n  // single hop, so it can be reduced to plain v2 or v3 swap logic\n  if (route.pools.length === 1) {\n    if (route.pools[0] instanceof Pool) {\n      return addV3Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\n    } else if (route.pools[0] instanceof Pair) {\n      return addV2Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\n    } else {\n      throw new Error('Invalid route type')\n    }\n  }\n\n  const trade = MixedRouteTrade.createUncheckedTrade({\n    route: route as MixedRoute<TInput, TOutput>,\n    inputAmount,\n    outputAmount,\n    tradeType,\n  })\n\n  const amountIn = trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient.toString()\n  const amountOut = trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient.toString()\n\n  // logic from\n  // https://github.com/Uniswap/router-sdk/blob/d8eed164e6c79519983844ca8b6a3fc24ebcb8f8/src/swapRouter.ts#L276\n  const sections = partitionMixedRouteByProtocol(route as MixedRoute<TInput, TOutput>)\n  const isLastSectionInRoute = (i: number) => {\n    return i === sections.length - 1\n  }\n\n  let outputToken\n  let inputToken = route.input.wrapped\n\n  for (let i = 0; i < sections.length; i++) {\n    const section = sections[i]\n    /// Now, we get output of this section\n    outputToken = getOutputOfPools(section, inputToken)\n\n    const newRouteOriginal = new MixedRouteSDK(\n      [...section],\n      section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1,\n      outputToken\n    )\n    const newRoute = new MixedRoute(newRouteOriginal)\n\n    /// Previous output is now input\n    inputToken = outputToken\n\n    const mixedRouteIsAllV3 = (route: MixedRouteSDK<Currency, Currency>) => {\n      return route.pools.every((pool) => pool instanceof Pool)\n    }\n\n    if (mixedRouteIsAllV3(newRoute)) {\n      const path: string = encodeMixedRouteToPath(newRoute)\n\n      planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n        // if not last section: send tokens directly to the first v2 pair of the next section\n        // note: because of the partitioning function we can be sure that the next section is v2\n        isLastSectionInRoute(i) ? tradeRecipient : (sections[i + 1][0] as Pair).liquidityToken.address,\n        i == 0 ? amountIn : CONTRACT_BALANCE, // amountIn\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOut\n        path, // path\n        payerIsUser && i === 0, // payerIsUser\n      ])\n    } else {\n      planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n        isLastSectionInRoute(i) ? tradeRecipient : ROUTER_AS_RECIPIENT, // recipient\n        i === 0 ? amountIn : CONTRACT_BALANCE, // amountIn\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOutMin\n        newRoute.path.map((pool) => pool.address), // path\n        payerIsUser && i === 0,\n      ])\n    }\n  }\n}\n\n// if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\nfunction riskOfPartialFill(trade: RouterTrade<Currency, Currency, TradeType>): boolean {\n  return trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n}\n","import { ethers } from 'ethers'\nimport { PermitSingle } from '@uniswap/permit2-sdk'\nimport { CommandType, RoutePlanner } from './routerCommands'\n\nexport interface Permit2Permit extends PermitSingle {\n  signature: string\n}\n\nconst SIGNATURE_LENGTH = 65\nconst EIP_2098_SIGNATURE_LENGTH = 64\n\nexport function encodePermit(planner: RoutePlanner, permit: Permit2Permit): void {\n  let signature = permit.signature\n\n  const length = ethers.utils.arrayify(permit.signature).length\n  // signature data provided for EIP-1271 may have length different from ECDSA signature\n  if (length === SIGNATURE_LENGTH || length === EIP_2098_SIGNATURE_LENGTH) {\n    // sanitizes signature to cover edge cases of malformed EIP-2098 sigs and v used as recovery id\n    signature = ethers.utils.joinSignature(ethers.utils.splitSignature(permit.signature))\n  }\n\n  planner.addCommand(CommandType.PERMIT, [permit, signature])\n}\n","import invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/universal-router/artifacts/contracts/UniversalRouter.sol/UniversalRouter.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { MethodParameters } from '@uniswap/v3-sdk'\nimport { Trade as RouterTrade } from '@uniswap/router-sdk'\nimport { Currency, TradeType } from '@uniswap/sdk-core'\nimport { Command, RouterTradeType } from './entities/Command'\nimport { NFTTrade, SupportedProtocolsData } from './entities/NFTTrade'\nimport { UniswapTrade, SwapOptions } from './entities/protocols/uniswap'\nimport { UnwrapWETH } from './entities/protocols/unwrapWETH'\nimport { CommandType, RoutePlanner } from './utils/routerCommands'\nimport { encodePermit } from './utils/permit2'\nimport { ROUTER_AS_RECIPIENT, SENDER_AS_RECIPIENT, ETH_ADDRESS } from './utils/constants'\n\nexport type SwapRouterConfig = {\n  sender?: string // address\n  deadline?: BigNumberish\n}\n\ntype SupportedNFTTrade = NFTTrade<SupportedProtocolsData>\n\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  public static swapCallParameters(trades: Command[] | Command, config: SwapRouterConfig = {}): MethodParameters {\n    if (!Array.isArray(trades)) trades = [trades]\n\n    const nftTrades = trades.filter((trade, _, []) => trade.hasOwnProperty('market')) as SupportedNFTTrade[]\n    const allowRevert = nftTrades.length == 1 && nftTrades[0].orders.length == 1 ? false : true\n    const planner = new RoutePlanner()\n\n    // track value flow to require the right amount of native value\n    let currentNativeValueInRouter = BigNumber.from(0)\n    let transactionValue = BigNumber.from(0)\n\n    for (const trade of trades) {\n      /**\n       * is NFTTrade\n       */\n      if (trade.tradeType == RouterTradeType.NFTTrade) {\n        const nftTrade = trade as SupportedNFTTrade\n        nftTrade.encode(planner, { allowRevert })\n        const tradePrice = nftTrade.getTotalPrice()\n\n        // send enough native value to contract for NFT purchase\n        if (currentNativeValueInRouter.lt(tradePrice)) {\n          transactionValue = transactionValue.add(tradePrice.sub(currentNativeValueInRouter))\n          currentNativeValueInRouter = BigNumber.from(0)\n        } else {\n          currentNativeValueInRouter = currentNativeValueInRouter.sub(tradePrice)\n        }\n        /**\n         * is Uniswap Trade\n         */\n      } else if (trade.tradeType == RouterTradeType.UniswapTrade) {\n        const uniswapTrade = trade as UniswapTrade\n        const inputIsNative = uniswapTrade.trade.inputAmount.currency.isNative\n        const outputIsNative = uniswapTrade.trade.outputAmount.currency.isNative\n        const swapOptions = uniswapTrade.options\n\n        invariant(!(inputIsNative && !!swapOptions.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\n\n        if (!!swapOptions.inputTokenPermit) {\n          encodePermit(planner, swapOptions.inputTokenPermit)\n        }\n\n        if (inputIsNative) {\n          transactionValue = transactionValue.add(\n            BigNumber.from(uniswapTrade.trade.maximumAmountIn(swapOptions.slippageTolerance).quotient.toString())\n          )\n        }\n        // track amount of native currency in the router\n        if (outputIsNative && swapOptions.recipient == ROUTER_AS_RECIPIENT) {\n          currentNativeValueInRouter = currentNativeValueInRouter.add(\n            BigNumber.from(uniswapTrade.trade.minimumAmountOut(swapOptions.slippageTolerance).quotient.toString())\n          )\n        }\n        uniswapTrade.encode(planner, { allowRevert: false })\n        /**\n         * is UnwrapWETH\n         */\n      } else if (trade.tradeType == RouterTradeType.UnwrapWETH) {\n        const UnwrapWETH = trade as UnwrapWETH\n        trade.encode(planner, { allowRevert: false })\n        currentNativeValueInRouter = currentNativeValueInRouter.add(UnwrapWETH.amount)\n        /**\n         * else\n         */\n      } else {\n        throw 'trade must be of instance: UniswapTrade or NFTTrade'\n      }\n    }\n\n    // TODO: matches current logic for now, but should eventually only sweep for multiple NFT trades\n    // or NFT trades with potential slippage (i.e. sudo)\n    if (nftTrades.length > 0) planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0])\n    return SwapRouter.encodePlan(planner, transactionValue, config)\n  }\n\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given swap.\n   * @param trades to produce call parameters for\n   */\n  public static swapNFTCallParameters(trades: SupportedNFTTrade[], config: SwapRouterConfig = {}): MethodParameters {\n    let planner = new RoutePlanner()\n    let totalPrice = BigNumber.from(0)\n\n    const allowRevert = trades.length == 1 && trades[0].orders.length == 1 ? false : true\n\n    for (const trade of trades) {\n      trade.encode(planner, { allowRevert })\n      totalPrice = totalPrice.add(trade.getTotalPrice())\n    }\n\n    planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0])\n    return SwapRouter.encodePlan(planner, totalPrice, config)\n  }\n\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapERC20CallParameters(\n    trades: RouterTrade<Currency, Currency, TradeType>,\n    options: SwapOptions\n  ): MethodParameters {\n    // TODO: use permit if signature included in swapOptions\n    const planner = new RoutePlanner()\n\n    const trade: UniswapTrade = new UniswapTrade(trades, options)\n\n    const inputCurrency = trade.trade.inputAmount.currency\n    invariant(!(inputCurrency.isNative && !!options.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\n\n    if (options.inputTokenPermit) {\n      encodePermit(planner, options.inputTokenPermit)\n    }\n\n    const nativeCurrencyValue = inputCurrency.isNative\n      ? BigNumber.from(trade.trade.maximumAmountIn(options.slippageTolerance).quotient.toString())\n      : BigNumber.from(0)\n\n    trade.encode(planner, { allowRevert: false })\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue, {\n      deadline: options.deadlineOrPreviousBlockhash ? BigNumber.from(options.deadlineOrPreviousBlockhash) : undefined,\n    })\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue)\n  }\n\n  /**\n   * Encodes a planned route into a method name and parameters for the Router contract.\n   * @param planner the planned route\n   * @param nativeCurrencyValue the native currency value of the planned route\n   * @param config the router config\n   */\n  private static encodePlan(\n    planner: RoutePlanner,\n    nativeCurrencyValue: BigNumber,\n    config: SwapRouterConfig = {}\n  ): MethodParameters {\n    const { commands, inputs } = planner\n    const functionSignature = !!config.deadline ? 'execute(bytes,bytes[],uint256)' : 'execute(bytes,bytes[])'\n    const parameters = !!config.deadline ? [commands, inputs, config.deadline] : [commands, inputs]\n    const calldata = SwapRouter.INTERFACE.encodeFunctionData(functionSignature, parameters)\n    return { calldata, value: nativeCurrencyValue.toHexString() }\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { SeaportData } from './protocols/seaport'\nimport { FoundationData } from './protocols/foundation'\nimport { NFTXData } from './protocols/nftx'\nimport { NFT20Data } from './protocols/nft20'\nimport { RoutePlanner } from '../utils/routerCommands'\nimport { Command, RouterTradeType, TradeConfig } from './Command'\nimport { LooksRareData } from './protocols/looksRare'\nimport { SudoswapData } from './protocols/sudoswap'\nimport { CryptopunkData } from './protocols/cryptopunk'\nimport { X2Y2Data } from './protocols/x2y2'\n\nexport type SupportedProtocolsData =\n  | SeaportData\n  | FoundationData\n  | NFTXData\n  | LooksRareData\n  | X2Y2Data\n  | CryptopunkData\n  | NFT20Data\n  | SudoswapData\n\nexport abstract class NFTTrade<T> implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.NFTTrade\n  readonly orders: T[]\n  readonly market: Market\n\n  constructor(market: Market, orders: T[]) {\n    invariant(orders.length > 0, 'no buy Items')\n    this.market = market\n    this.orders = orders\n  }\n\n  abstract encode(planner: RoutePlanner, config: TradeConfig): void\n\n  abstract getBuyItems(): BuyItem[]\n\n  abstract getTotalPrice(): BigNumber\n}\n\nexport type BuyItem = {\n  tokenAddress: string\n  tokenId: BigNumberish\n  tokenType: TokenType\n  amount?: BigNumberish // for 1155\n}\n\nexport enum Market {\n  Foundation = 'foundation',\n  LooksRare = 'looksrare',\n  NFT20 = 'nft20',\n  NFTX = 'nftx',\n  Seaport = 'seaport',\n  Sudoswap = 'Sudoswap',\n  Cryptopunks = 'cryptopunks',\n  X2Y2 = 'x2y2',\n}\n\nexport enum TokenType {\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155',\n  Cryptopunk = 'Cryptopunk',\n}\n","import { TradeConfig } from '../Command'\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type CryptopunkData = {\n  tokenId: BigNumberish\n  recipient: string\n  value: BigNumberish\n}\n\nexport class CryptopunkTrade extends NFTTrade<CryptopunkData> {\n  public static CRYPTOPUNK_ADDRESS: string = '0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb'\n\n  constructor(orders: CryptopunkData[]) {\n    super(Market.Cryptopunks, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      planner.addCommand(CommandType.CRYPTOPUNKS, [item.tokenId, item.recipient, item.value], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: CryptopunkTrade.CRYPTOPUNK_ADDRESS,\n        tokenId: item.tokenId,\n        tokenType: TokenType.Cryptopunk,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/Foundation.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type FoundationData = {\n  recipient: string\n  tokenAddress: string\n  tokenId: BigNumberish\n  price: BigNumberish\n  referrer: string // address\n}\n\nexport class FoundationTrade extends NFTTrade<FoundationData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: FoundationData[]) {\n    super(Market.Foundation, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const calldata = FoundationTrade.INTERFACE.encodeFunctionData('buyV2', [\n        item.tokenAddress,\n        item.tokenId,\n        item.price,\n        item.referrer,\n      ])\n      planner.addCommand(\n        CommandType.FOUNDATION,\n        [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\n        config.allowRevert\n      )\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: TokenType.ERC721,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.price)\n    }\n    return total\n  }\n}\n","import invariant from 'tiny-invariant'\nimport abi from '../../../abis/LooksRare.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type MakerOrder = {\n  collection: string\n  tokenId: BigNumberish\n  isOrderAsk: true\n  signer: string\n  strategy: string\n  currency: string\n  amount: BigNumberish\n  price: BigNumberish\n  minPercentageToAsk: BigNumberish\n  nonce: BigNumberish\n  startTime: BigNumberish\n  endTime: BigNumberish\n  v: BigNumberish\n  r: string\n  s: string\n  params: string\n}\n\nexport type TakerOrder = {\n  minPercentageToAsk: BigNumberish\n  price: BigNumberish\n  taker: string\n  tokenId: BigNumberish\n  isOrderAsk: boolean\n  params: string\n}\n\nexport type LooksRareData = {\n  makerOrder: MakerOrder\n  takerOrder: TakerOrder\n  recipient: string\n  tokenType: TokenType\n}\n\nexport class LooksRareTrade extends NFTTrade<LooksRareData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: LooksRareData[]) {\n    super(Market.LooksRare, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const calldata = LooksRareTrade.INTERFACE.encodeFunctionData('matchAskWithTakerBidUsingETHAndWETH', [\n        item.takerOrder,\n        item.makerOrder,\n      ])\n\n      if (item.tokenType == TokenType.ERC721) {\n        invariant(item.makerOrder.amount == 1, 'ERC721 token amount must be 1')\n        planner.addCommand(\n          CommandType.LOOKS_RARE_721,\n          [item.makerOrder.price, calldata, item.recipient, item.makerOrder.collection, item.makerOrder.tokenId],\n          config.allowRevert\n        )\n      } else if (item.tokenType == TokenType.ERC1155) {\n        planner.addCommand(\n          CommandType.LOOKS_RARE_1155,\n          [\n            item.makerOrder.price,\n            calldata,\n            item.recipient,\n            item.makerOrder.collection,\n            item.makerOrder.tokenId,\n            item.makerOrder.amount,\n          ],\n          config.allowRevert\n        )\n      }\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.makerOrder.collection,\n        tokenId: item.makerOrder.tokenId,\n        tokenType: item.tokenType,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.makerOrder.price)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/NFT20.json'\nimport { Interface } from '@ethersproject/abi'\nimport { TradeConfig } from '../Command'\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type NFT20Data = {\n  tokenAddress: string\n  tokenIds: BigNumberish[]\n  tokenAmounts: BigNumberish[]\n  recipient: string\n  fee: BigNumberish\n  isV3: boolean\n  value: BigNumberish\n}\n\nexport class NFT20Trade extends NFTTrade<NFT20Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: NFT20Data[]) {\n    super(Market.NFT20, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = NFT20Trade.INTERFACE.encodeFunctionData('ethForNft', [\n        order.tokenAddress,\n        order.tokenIds,\n        order.tokenAmounts,\n        order.recipient,\n        order.fee,\n        order.isV3,\n      ])\n      planner.addCommand(CommandType.NFT20, [order.value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const pool of this.orders) {\n      for (const tokenId of pool.tokenIds) {\n        buyItems.push({\n          tokenAddress: pool.tokenAddress,\n          tokenId: tokenId,\n          tokenType: TokenType.ERC721,\n        })\n      }\n    }\n\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/NFTXZap.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { Ether } from '@uniswap/sdk-core'\n\nexport type NFTXData = {\n  recipient: string\n  vaultAddress: string\n  vaultId: BigNumberish\n  tokenAddress: string\n  tokenIds: BigNumberish[]\n  value: BigNumber\n}\n\nexport class NFTXTrade extends NFTTrade<NFTXData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: NFTXData[]) {\n    super(Market.NFTX, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = NFTXTrade.INTERFACE.encodeFunctionData('buyAndRedeem', [\n        order.vaultId,\n        order.tokenIds.length,\n        order.tokenIds,\n        [Ether.onChain(1).wrapped.address, order.vaultAddress],\n        order.recipient,\n      ])\n      planner.addCommand(CommandType.NFTX, [order.value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const tokenId of order.tokenIds) {\n        buyItems.push({\n          tokenAddress: order.tokenAddress,\n          tokenId: tokenId,\n          tokenType: TokenType.ERC721,\n        })\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/Seaport.json'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\n\nexport type SeaportData = {\n  items: Order[]\n  recipient: string // address\n}\n\nexport type FulfillmentComponent = {\n  orderIndex: BigNumberish\n  itemIndex: BigNumberish\n}\n\nexport type OfferItem = {\n  itemType: BigNumberish // enum\n  token: string // address\n  identifierOrCriteria: BigNumberish\n  startAmount: BigNumberish\n  endAmount: BigNumberish\n}\n\nexport type ConsiderationItem = OfferItem & {\n  recipient: string\n}\n\nexport type Order = {\n  parameters: OrderParameters\n  signature: string\n}\n\ntype OrderParameters = {\n  offerer: string // address,\n  offer: OfferItem[]\n  consideration: ConsiderationItem[]\n  orderType: BigNumberish // enum\n  startTime: BigNumberish\n  endTime: BigNumberish\n  zoneHash: string // bytes32\n  zone: string // address\n  salt: BigNumberish\n  conduitKey: string // bytes32,\n  totalOriginalConsiderationItems: BigNumberish\n}\n\nexport type AdvancedOrder = Order & {\n  numerator: BigNumber // uint120\n  denominator: BigNumber // uint120\n  extraData: string // bytes\n}\n\nexport class SeaportTrade extends NFTTrade<SeaportData> {\n  public static INTERFACE: Interface = new Interface(abi)\n  public static OPENSEA_CONDUIT_KEY: string = '0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000'\n\n  constructor(orders: SeaportData[]) {\n    super(Market.Seaport, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      let advancedOrders: AdvancedOrder[] = []\n      let orderFulfillments: FulfillmentComponent[][] = order.items.map((_, index) => [\n        { orderIndex: index, itemIndex: 0 },\n      ])\n      let considerationFulFillments: FulfillmentComponent[][] = this.getConsiderationFulfillments(order.items)\n\n      for (const item of order.items) {\n        const { advancedOrder } = this.getAdvancedOrderParams(item)\n        advancedOrders.push(advancedOrder)\n      }\n\n      let calldata: string\n      if (advancedOrders.length == 1) {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAdvancedOrder', [\n          advancedOrders[0],\n          [],\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\n          order.recipient,\n        ])\n      } else {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAvailableAdvancedOrders', [\n          advancedOrders,\n          [],\n          orderFulfillments,\n          considerationFulFillments,\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\n          order.recipient,\n          100, // TODO: look into making this a better number\n        ])\n      }\n      planner.addCommand(CommandType.SEAPORT, [this.getTotalPrice().toString(), calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        for (const offer of item.parameters.offer) {\n          buyItems.push({\n            tokenAddress: offer.token,\n            tokenId: offer.identifierOrCriteria,\n            tokenType: TokenType.ERC721,\n          })\n        }\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let totalPrice = BigNumber.from(0)\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        totalPrice = totalPrice.add(this.calculateValue(item.parameters.consideration))\n      }\n    }\n    return totalPrice\n  }\n\n  private getConsiderationFulfillments(protocolDatas: Order[]): FulfillmentComponent[][] {\n    let considerationFulfillments: FulfillmentComponent[][] = []\n    const considerationRecipients: string[] = []\n\n    for (const i in protocolDatas) {\n      const protocolData = protocolDatas[i]\n\n      for (const j in protocolData.parameters.consideration) {\n        const item = protocolData.parameters.consideration[j]\n\n        if (considerationRecipients.findIndex((x) => x === item.recipient) === -1) {\n          considerationRecipients.push(item.recipient)\n        }\n\n        const recipientIndex = considerationRecipients.findIndex((x) => x === item.recipient)\n\n        if (!considerationFulfillments[recipientIndex]) {\n          considerationFulfillments.push([\n            {\n              orderIndex: i,\n              itemIndex: j,\n            },\n          ])\n        } else {\n          considerationFulfillments[recipientIndex].push({\n            orderIndex: i,\n            itemIndex: j,\n          })\n        }\n      }\n    }\n    return considerationFulfillments\n  }\n\n  private getAdvancedOrderParams(data: Order): { advancedOrder: AdvancedOrder; value: BigNumber } {\n    const advancedOrder = {\n      parameters: data.parameters,\n      numerator: BigNumber.from('1'),\n      denominator: BigNumber.from('1'),\n      signature: data.signature,\n      extraData: '0x00',\n    }\n    const value = this.calculateValue(data.parameters.consideration)\n    return { advancedOrder, value }\n  }\n\n  private calculateValue(considerations: ConsiderationItem[]): BigNumber {\n    return considerations.reduce(\n      (amt: BigNumber, consideration: ConsiderationItem) => amt.add(consideration.startAmount),\n      BigNumber.from(0)\n    )\n  }\n}\n","import abi from '../../../abis/Sudoswap.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\ntype PairSwap = {\n  swapInfo: {\n    pair: string // address\n    nftIds: BigNumberish[]\n  }\n  tokenAddress: string // address\n  maxCost: BigNumberish\n}\n\nexport type SudoswapData = {\n  swaps: PairSwap[]\n  nftRecipient: string\n  ethRecipient: string\n  deadline: BigNumberish\n}\n\nexport class SudoswapTrade extends NFTTrade<SudoswapData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: SudoswapData[]) {\n    super(Market.Sudoswap, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = SudoswapTrade.INTERFACE.encodeFunctionData('robustSwapETHForSpecificNFTs', [\n        order.swaps.map((swap) => {\n          return { swapInfo: swap.swapInfo, maxCost: swap.maxCost }\n        }),\n        order.ethRecipient,\n        order.nftRecipient,\n        order.deadline,\n      ])\n      const value = order.swaps.reduce((prevVal, swap) => {\n        return prevVal.add(swap.maxCost)\n      }, BigNumber.from(0))\n      planner.addCommand(CommandType.SUDOSWAP, [value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const swap of order.swaps) {\n        for (const tokenId of swap.swapInfo.nftIds) {\n          buyItems.push({\n            tokenAddress: swap.tokenAddress,\n            tokenId,\n            tokenType: TokenType.ERC721,\n          })\n        }\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const order of this.orders) {\n      for (const swap of order.swaps) {\n        total = total.add(swap.maxCost)\n      }\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/X2Y2.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\ntype X2Y2PartialData = {\n  signedInput: string\n  recipient: string\n  tokenAddress: string\n  tokenId: BigNumberish\n  price: BigNumberish\n}\n\nexport type X2Y2_721_Data = X2Y2PartialData & {\n  tokenType: TokenType.ERC721\n}\n\nexport type X2Y2_1155_Data = X2Y2PartialData & {\n  tokenType: TokenType.ERC1155\n  tokenAmount: BigNumberish\n}\n\nexport type X2Y2Data = X2Y2_721_Data | X2Y2_1155_Data\n\nexport class X2Y2Trade extends NFTTrade<X2Y2Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: X2Y2Data[]) {\n    super(Market.X2Y2, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const functionSelector = X2Y2Trade.INTERFACE.getSighash(X2Y2Trade.INTERFACE.getFunction('run'))\n      const calldata = functionSelector + item.signedInput.slice(2)\n\n      if (item.tokenType == TokenType.ERC721) {\n        planner.addCommand(\n          CommandType.X2Y2_721,\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\n          config.allowRevert\n        )\n      } else if (item.tokenType == TokenType.ERC1155) {\n        planner.addCommand(\n          CommandType.X2Y2_1155,\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId, item.tokenAmount],\n          config.allowRevert\n        )\n      }\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: item.tokenType,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.price)\n    }\n    return total\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { BigNumberish } from 'ethers'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { Permit2Permit } from '../../utils/permit2'\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\nimport { encodePermit } from '../../utils/permit2'\nimport { ROUTER_AS_RECIPIENT, UNIVERSAL_ROUTER_ADDRESS, WETH_ADDRESS } from '../../utils/constants'\n\nexport class UnwrapWETH implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.UnwrapWETH\n  readonly permit2Data: Permit2Permit\n  readonly wethAddress: string\n  readonly routerAddress: string\n  readonly amount: BigNumberish\n\n  constructor(amount: BigNumberish, chainId: number, permit2?: Permit2Permit) {\n    this.wethAddress = WETH_ADDRESS(chainId)\n    this.routerAddress = UNIVERSAL_ROUTER_ADDRESS(chainId)\n    this.amount = amount\n\n    if (!!permit2) {\n      invariant(permit2.details.token === this.wethAddress, `must be permitting WETH address: ${this.wethAddress}`)\n      invariant(permit2.details.amount >= amount, `Did not permit enough WETH for unwrapWETH transaction`)\n      this.permit2Data = permit2\n    }\n  }\n\n  encode(planner: RoutePlanner, _: TradeConfig): void {\n    if (!!this.permit2Data) encodePermit(planner, this.permit2Data)\n    planner.addCommand(CommandType.PERMIT2_TRANSFER_FROM, [this.wethAddress, this.routerAddress, this.amount])\n    planner.addCommand(CommandType.UNWRAP_WETH, [ROUTER_AS_RECIPIENT, this.amount])\n  }\n}\n"]},"metadata":{},"sourceType":"script"}