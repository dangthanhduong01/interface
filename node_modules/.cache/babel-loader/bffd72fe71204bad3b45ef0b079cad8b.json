{"ast":null,"code":"import { uuid4, dateTimestampInSeconds, resolvedSyncPromise, truncate, GLOBAL_OBJ, normalize } from '@sentry/utils';\nimport { DEFAULT_ENVIRONMENT } from '../constants.js';\nimport { Scope } from '../scope.js';\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * Note: This also triggers callbacks for `addGlobalEventProcessor`, but not `beforeSend`.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nfunction prepareEvent(options, event, hint, scope) {\n  const {\n    normalizeDepth = 3,\n    normalizeMaxBreadth = 1000\n  } = options;\n  const prepared = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds()\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n  applyDebugMetadata(prepared, options.stackParser);\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  let finalScope = scope;\n  if (hint.captureContext) {\n    finalScope = Scope.clone(finalScope).update(hint.captureContext);\n  }\n\n  // We prepare the result here with a resolved Event.\n  let result = resolvedSyncPromise(prepared);\n\n  // This should be the last thing called, since we want that\n  // {@link Hub.addEventProcessor} gets the finished prepared event.\n  //\n  // We need to check for the existence of `finalScope.getAttachments`\n  // because `getAttachments` can be undefined if users are using an older version\n  // of `@sentry/core` that does not have the `getAttachments` method.\n  // See: https://github.com/getsentry/sentry-javascript/issues/5229\n  if (finalScope) {\n    // Collect attachments from the hint and scope\n    if (finalScope.getAttachments) {\n      const attachments = [...(hint.attachments || []), ...finalScope.getAttachments()];\n      if (attachments.length) {\n        hint.attachments = attachments;\n      }\n    }\n\n    // In case we have a hub we reassign it.\n    result = finalScope.applyToEvent(prepared, hint);\n  }\n  return result.then(evt => {\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n *  Enhances event using the client configuration.\n *  It takes care of all \"static\" values like environment, release and `dist`,\n *  as well as truncating overly long values.\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event, options) {\n  const {\n    environment,\n    release,\n    dist,\n    maxValueLength = 250\n  } = options;\n  if (!('environment' in event)) {\n    event.environment = 'environment' in options ? environment : DEFAULT_ENVIRONMENT;\n  }\n  if (event.release === undefined && release !== undefined) {\n    event.release = release;\n  }\n  if (event.dist === undefined && dist !== undefined) {\n    event.dist = dist;\n  }\n  if (event.message) {\n    event.message = truncate(event.message, maxValueLength);\n  }\n  const exception = event.exception && event.exception.values && event.exception.values[0];\n  if (exception && exception.value) {\n    exception.value = truncate(exception.value, maxValueLength);\n  }\n  const request = event.request;\n  if (request && request.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\n\n/**\n * Applies debug metadata images to the event in order to apply source maps by looking up their debug ID.\n */\nfunction applyDebugMetadata(event, stackParser) {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n  if (!debugIdMap) {\n    return;\n  }\n\n  // Build a map of abs_path -> debug_id\n  const absPathDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {\n    const parsedStack = stackParser(debugIdStackTrace);\n    for (const stackFrame of parsedStack) {\n      if (stackFrame.abs_path) {\n        acc[stackFrame.abs_path] = debugIdMap[debugIdStackTrace];\n        break;\n      }\n    }\n    return acc;\n  }, {});\n\n  // Get a Set of abs_paths in the stack trace\n  const errorAbsPaths = new Set();\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event.exception.values.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace.frames.forEach(frame => {\n        if (frame.abs_path) {\n          errorAbsPaths.add(frame.abs_path);\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  errorAbsPaths.forEach(absPath => {\n    if (absPathDebugIdMap[absPath]) {\n      images.push({\n        type: 'sourcemap',\n        code_file: absPath,\n        debug_id: absPathDebugIdMap[absPath]\n      });\n    }\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event, integrationNames) {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event, depth, maxBreadth) {\n  if (!event) {\n    return null;\n  }\n  const normalized = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth)\n        })\n      }))\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth)\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth)\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth)\n    })\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts && event.contexts.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable\n      if (span.data) {\n        span.data = normalize(span.data, depth, maxBreadth);\n      }\n      return span;\n    });\n  }\n  return normalized;\n}\nexport { applyDebugMetadata, prepareEvent };","map":{"version":3,"sources":["../../../src/utils/prepareEvent.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ClientOptions, Event, EventHint, StackParser } from '@sentry/types';\nimport { dateTimestampInSeconds, GLOBAL_OBJ, normalize, resolvedSyncPromise, truncate, uuid4 } from '@sentry/utils';\n\nimport { DEFAULT_ENVIRONMENT } from '../constants';\nimport { Scope } from '../scope';\n\n/**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * Note: This also triggers callbacks for `addGlobalEventProcessor`, but not `beforeSend`.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */\nexport function prepareEvent(\n  options: ClientOptions,\n  event: Event,\n  hint: EventHint,\n  scope?: Scope,\n): PromiseLike<Event | null> {\n  const { normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = options;\n  const prepared: Event = {\n    ...event,\n    event_id: event.event_id || hint.event_id || uuid4(),\n    timestamp: event.timestamp || dateTimestampInSeconds(),\n  };\n  const integrations = hint.integrations || options.integrations.map(i => i.name);\n\n  applyClientOptions(prepared, options);\n  applyIntegrationsMetadata(prepared, integrations);\n  applyDebugMetadata(prepared, options.stackParser);\n\n  // If we have scope given to us, use it as the base for further modifications.\n  // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n  let finalScope = scope;\n  if (hint.captureContext) {\n    finalScope = Scope.clone(finalScope).update(hint.captureContext);\n  }\n\n  // We prepare the result here with a resolved Event.\n  let result = resolvedSyncPromise<Event | null>(prepared);\n\n  // This should be the last thing called, since we want that\n  // {@link Hub.addEventProcessor} gets the finished prepared event.\n  //\n  // We need to check for the existence of `finalScope.getAttachments`\n  // because `getAttachments` can be undefined if users are using an older version\n  // of `@sentry/core` that does not have the `getAttachments` method.\n  // See: https://github.com/getsentry/sentry-javascript/issues/5229\n  if (finalScope) {\n    // Collect attachments from the hint and scope\n    if (finalScope.getAttachments) {\n      const attachments = [...(hint.attachments || []), ...finalScope.getAttachments()];\n\n      if (attachments.length) {\n        hint.attachments = attachments;\n      }\n    }\n\n    // In case we have a hub we reassign it.\n    result = finalScope.applyToEvent(prepared, hint);\n  }\n\n  return result.then(evt => {\n    if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n    }\n    return evt;\n  });\n}\n\n/**\n *  Enhances event using the client configuration.\n *  It takes care of all \"static\" values like environment, release and `dist`,\n *  as well as truncating overly long values.\n * @param event event instance to be enhanced\n */\nfunction applyClientOptions(event: Event, options: ClientOptions): void {\n  const { environment, release, dist, maxValueLength = 250 } = options;\n\n  if (!('environment' in event)) {\n    event.environment = 'environment' in options ? environment : DEFAULT_ENVIRONMENT;\n  }\n\n  if (event.release === undefined && release !== undefined) {\n    event.release = release;\n  }\n\n  if (event.dist === undefined && dist !== undefined) {\n    event.dist = dist;\n  }\n\n  if (event.message) {\n    event.message = truncate(event.message, maxValueLength);\n  }\n\n  const exception = event.exception && event.exception.values && event.exception.values[0];\n  if (exception && exception.value) {\n    exception.value = truncate(exception.value, maxValueLength);\n  }\n\n  const request = event.request;\n  if (request && request.url) {\n    request.url = truncate(request.url, maxValueLength);\n  }\n}\n\n/**\n * Applies debug metadata images to the event in order to apply source maps by looking up their debug ID.\n */\nexport function applyDebugMetadata(event: Event, stackParser: StackParser): void {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n\n  if (!debugIdMap) {\n    return;\n  }\n\n  // Build a map of abs_path -> debug_id\n  const absPathDebugIdMap = Object.keys(debugIdMap).reduce<Record<string, string>>((acc, debugIdStackTrace) => {\n    const parsedStack = stackParser(debugIdStackTrace);\n    for (const stackFrame of parsedStack) {\n      if (stackFrame.abs_path) {\n        acc[stackFrame.abs_path] = debugIdMap[debugIdStackTrace];\n        break;\n      }\n    }\n    return acc;\n  }, {});\n\n  // Get a Set of abs_paths in the stack trace\n  const errorAbsPaths = new Set<string>();\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    event!.exception!.values!.forEach(exception => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      exception.stacktrace!.frames!.forEach(frame => {\n        if (frame.abs_path) {\n          errorAbsPaths.add(frame.abs_path);\n        }\n      });\n    });\n  } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n  }\n\n  // Fill debug_meta information\n  event.debug_meta = event.debug_meta || {};\n  event.debug_meta.images = event.debug_meta.images || [];\n  const images = event.debug_meta.images;\n  errorAbsPaths.forEach(absPath => {\n    if (absPathDebugIdMap[absPath]) {\n      images.push({\n        type: 'sourcemap',\n        code_file: absPath,\n        debug_id: absPathDebugIdMap[absPath],\n      });\n    }\n  });\n}\n\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */\nfunction applyIntegrationsMetadata(event: Event, integrationNames: string[]): void {\n  if (integrationNames.length > 0) {\n    event.sdk = event.sdk || {};\n    event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationNames];\n  }\n}\n\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */\nfunction normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null {\n  if (!event) {\n    return null;\n  }\n\n  const normalized: Event = {\n    ...event,\n    ...(event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(b => ({\n        ...b,\n        ...(b.data && {\n          data: normalize(b.data, depth, maxBreadth),\n        }),\n      })),\n    }),\n    ...(event.user && {\n      user: normalize(event.user, depth, maxBreadth),\n    }),\n    ...(event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth),\n    }),\n    ...(event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth),\n    }),\n  };\n\n  // event.contexts.trace stores information about a Transaction. Similarly,\n  // event.spans[] stores information about child Spans. Given that a\n  // Transaction is conceptually a Span, normalization should apply to both\n  // Transactions and Spans consistently.\n  // For now the decision is to skip normalization of Transactions and Spans,\n  // so this block overwrites the normalized event to add back the original\n  // Transaction information prior to normalization.\n  if (event.contexts && event.contexts.trace && normalized.contexts) {\n    normalized.contexts.trace = event.contexts.trace;\n\n    // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n    if (event.contexts.trace.data) {\n      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n    }\n  }\n\n  // event.spans[].data may contain circular/dangerous data so we need to normalize it\n  if (event.spans) {\n    normalized.spans = event.spans.map(span => {\n      // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable\n      if (span.data) {\n        span.data = normalize(span.data, depth, maxBreadth);\n      }\n      return span;\n    });\n  }\n\n  return normalized;\n}\n"]},"metadata":{},"sourceType":"module"}