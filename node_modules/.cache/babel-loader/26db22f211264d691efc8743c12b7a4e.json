{"ast":null,"code":"import { hasTracingEnabled, getCurrentHub } from '@sentry/core';\nimport { addInstrumentationHandler, dynamicSamplingContextToSentryBaggageHeader, isInstanceOf, BAGGAGE_HEADER_NAME, stringMatchesSomePattern } from '@sentry/utils';\n\n/* eslint-disable max-lines */\n\nconst DEFAULT_TRACE_PROPAGATION_TARGETS = ['localhost', /^\\//];\n\n/** Options for Request Instrumentation */\n\nconst defaultRequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  // TODO (v8): Remove this property\n  tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,\n  tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS\n};\n\n/** Registers span creators for xhr and fetch requests  */\nfunction instrumentOutgoingRequests(_options) {\n  // eslint-disable-next-line deprecation/deprecation\n  const {\n    traceFetch,\n    traceXHR,\n    tracePropagationTargets,\n    tracingOrigins,\n    shouldCreateSpanForRequest\n  } = {\n    traceFetch: defaultRequestInstrumentationOptions.traceFetch,\n    traceXHR: defaultRequestInstrumentationOptions.traceXHR,\n    ..._options\n  };\n  const shouldCreateSpan = typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : _ => true;\n\n  // TODO(v8) Remove tracingOrigins here\n  // The only reason we're passing it in here is because this instrumentOutgoingRequests function is publicly exported\n  // and we don't want to break the API. We can remove it in v8.\n  const shouldAttachHeadersWithTargets = url => shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);\n  const spans = {};\n  if (traceFetch) {\n    addInstrumentationHandler('fetch', handlerData => {\n      fetchCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n    });\n  }\n  if (traceXHR) {\n    addInstrumentationHandler('xhr', handlerData => {\n      xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n    });\n  }\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * This was extracted from `instrumentOutgoingRequests` to make it easier to test shouldAttachHeaders.\n * We only export this fuction for testing purposes.\n */\nfunction shouldAttachHeaders(url, tracePropagationTargets) {\n  return stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);\n}\n\n/**\n * Create and track fetch request spans\n */\nfunction fetchCallback(handlerData, shouldCreateSpan, shouldAttachHeaders, spans) {\n  if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {\n    return;\n  }\n  if (handlerData.endTimestamp) {\n    const spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n    const span = spans[spanId];\n    if (span) {\n      if (handlerData.response) {\n        // TODO (kmclb) remove this once types PR goes through\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        span.setHttpStatus(handlerData.response.status);\n      } else if (handlerData.error) {\n        span.setStatus('internal_error');\n      }\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n  const currentScope = getCurrentHub().getScope();\n  const currentSpan = currentScope && currentScope.getSpan();\n  const activeTransaction = currentSpan && currentSpan.transaction;\n  if (currentSpan && activeTransaction) {\n    const span = currentSpan.startChild({\n      data: {\n        ...handlerData.fetchData,\n        type: 'fetch'\n      },\n      description: `${handlerData.fetchData.method} ${handlerData.fetchData.url}`,\n      op: 'http.client'\n    });\n    handlerData.fetchData.__span = span.spanId;\n    spans[span.spanId] = span;\n    const request = handlerData.args[0];\n\n    // In case the user hasn't set the second argument of a fetch call we default it to `{}`.\n    handlerData.args[1] = handlerData.args[1] || {};\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const options = handlerData.args[1];\n    if (shouldAttachHeaders(handlerData.fetchData.url)) {\n      options.headers = addTracingHeadersToFetchRequest(request, activeTransaction.getDynamicSamplingContext(), span, options);\n    }\n  }\n}\nfunction addTracingHeadersToFetchRequest(request, dynamicSamplingContext, span, options) {\n  const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n  const sentryTraceHeader = span.toTraceparent();\n  const headers = typeof Request !== 'undefined' && isInstanceOf(request, Request) ? request.headers : options.headers;\n  if (!headers) {\n    return {\n      'sentry-trace': sentryTraceHeader,\n      baggage: sentryBaggageHeader\n    };\n  } else if (typeof Headers !== 'undefined' && isInstanceOf(headers, Headers)) {\n    const newHeaders = new Headers(headers);\n    newHeaders.append('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // If the same header is appended miultiple times the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.append(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n    return newHeaders;\n  } else if (Array.isArray(headers)) {\n    const newHeaders = [...headers, ['sentry-trace', sentryTraceHeader]];\n    if (sentryBaggageHeader) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push([BAGGAGE_HEADER_NAME, sentryBaggageHeader]);\n    }\n    return newHeaders;\n  } else {\n    const existingBaggageHeader = 'baggage' in headers ? headers.baggage : undefined;\n    const newBaggageHeaders = [];\n    if (Array.isArray(existingBaggageHeader)) {\n      newBaggageHeaders.push(...existingBaggageHeader);\n    } else if (existingBaggageHeader) {\n      newBaggageHeaders.push(existingBaggageHeader);\n    }\n    if (sentryBaggageHeader) {\n      newBaggageHeaders.push(sentryBaggageHeader);\n    }\n    return {\n      ...headers,\n      'sentry-trace': sentryTraceHeader,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined\n    };\n  }\n}\n\n/**\n * Create and track xhr request spans\n */\nfunction xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeaders, spans) {\n  if (!hasTracingEnabled() || handlerData.xhr && handlerData.xhr.__sentry_own_request__ || !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))) {\n    return;\n  }\n  const xhr = handlerData.xhr.__sentry_xhr__;\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp) {\n    const spanId = handlerData.xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n    const span = spans[spanId];\n    if (span) {\n      span.setHttpStatus(xhr.status_code);\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n  const currentScope = getCurrentHub().getScope();\n  const currentSpan = currentScope && currentScope.getSpan();\n  const activeTransaction = currentSpan && currentSpan.transaction;\n  if (currentSpan && activeTransaction) {\n    const span = currentSpan.startChild({\n      data: {\n        ...xhr.data,\n        type: 'xhr',\n        method: xhr.method,\n        url: xhr.url\n      },\n      description: `${xhr.method} ${xhr.url}`,\n      op: 'http.client'\n    });\n    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;\n    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;\n    if (handlerData.xhr.setRequestHeader && shouldAttachHeaders(handlerData.xhr.__sentry_xhr__.url)) {\n      try {\n        handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());\n        const dynamicSamplingContext = activeTransaction.getDynamicSamplingContext();\n        const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n        if (sentryBaggageHeader) {\n          // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n          // We can therefore simply set a baggage header without checking what was there before\n          // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n          handlerData.xhr.setRequestHeader(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n        }\n      } catch (_) {\n        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n      }\n    }\n  }\n}\nexport { DEFAULT_TRACE_PROPAGATION_TARGETS, defaultRequestInstrumentationOptions, fetchCallback, instrumentOutgoingRequests, shouldAttachHeaders, xhrCallback };","map":{"version":3,"sources":["../../../src/browser/request.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport { getCurrentHub, hasTracingEnabled } from '@sentry/core';\nimport type { DynamicSamplingContext, Span } from '@sentry/types';\nimport {\n  addInstrumentationHandler,\n  BAGGAGE_HEADER_NAME,\n  dynamicSamplingContextToSentryBaggageHeader,\n  isInstanceOf,\n  stringMatchesSomePattern,\n} from '@sentry/utils';\n\nexport const DEFAULT_TRACE_PROPAGATION_TARGETS = ['localhost', /^\\//];\n\n/** Options for Request Instrumentation */\nexport interface RequestInstrumentationOptions {\n  /**\n   * @deprecated Will be removed in v8.\n   * Use `shouldCreateSpanForRequest` to control span creation and `tracePropagationTargets` to control\n   * trace header attachment.\n   */\n  tracingOrigins: Array<string | RegExp>;\n\n  /**\n   * List of strings and/or regexes used to determine which outgoing requests will have `sentry-trace` and `baggage`\n   * headers attached.\n   *\n   * Default: ['localhost', /^\\//] {@see DEFAULT_TRACE_PROPAGATION_TARGETS}\n   */\n  tracePropagationTargets: Array<string | RegExp>;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n}\n\n/** Data returned from fetch callback */\nexport interface FetchData {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: any[]; // the arguments passed to the fetch call itself\n  fetchData?: {\n    method: string;\n    url: string;\n    // span_id\n    __span?: string;\n  };\n\n  // TODO Should this be unknown instead? If we vendor types, make it a Response\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  response?: any;\n  error?: unknown;\n\n  startTimestamp: number;\n  endTimestamp?: number;\n}\n\n/** Data returned from XHR request */\nexport interface XHRData {\n  xhr?: {\n    __sentry_xhr__?: {\n      method: string;\n      url: string;\n      status_code: number;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      data: Record<string, any>;\n    };\n    __sentry_xhr_span_id__?: string;\n    setRequestHeader?: (key: string, val: string) => void;\n    getRequestHeader?: (key: string) => string;\n    __sentry_own_request__?: boolean;\n  };\n  startTimestamp: number;\n  endTimestamp?: number;\n}\n\ntype PolymorphicRequestHeaders =\n  | Record<string, string | undefined>\n  | Array<[string, string]>\n  // the below is not preicsely the Header type used in Request, but it'll pass duck-typing\n  | {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      [key: string]: any;\n      append: (key: string, value: string) => void;\n      get: (key: string) => string;\n    };\n\nexport const defaultRequestInstrumentationOptions: RequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  // TODO (v8): Remove this property\n  tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,\n  tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nexport function instrumentOutgoingRequests(_options?: Partial<RequestInstrumentationOptions>): void {\n  // eslint-disable-next-line deprecation/deprecation\n  const { traceFetch, traceXHR, tracePropagationTargets, tracingOrigins, shouldCreateSpanForRequest } = {\n    traceFetch: defaultRequestInstrumentationOptions.traceFetch,\n    traceXHR: defaultRequestInstrumentationOptions.traceXHR,\n    ..._options,\n  };\n\n  const shouldCreateSpan =\n    typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : (_: string) => true;\n\n  // TODO(v8) Remove tracingOrigins here\n  // The only reason we're passing it in here is because this instrumentOutgoingRequests function is publicly exported\n  // and we don't want to break the API. We can remove it in v8.\n  const shouldAttachHeadersWithTargets = (url: string): boolean =>\n    shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);\n\n  const spans: Record<string, Span> = {};\n\n  if (traceFetch) {\n    addInstrumentationHandler('fetch', (handlerData: FetchData) => {\n      fetchCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n    });\n  }\n\n  if (traceXHR) {\n    addInstrumentationHandler('xhr', (handlerData: XHRData) => {\n      xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n    });\n  }\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * This was extracted from `instrumentOutgoingRequests` to make it easier to test shouldAttachHeaders.\n * We only export this fuction for testing purposes.\n */\nexport function shouldAttachHeaders(url: string, tracePropagationTargets: (string | RegExp)[] | undefined): boolean {\n  return stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);\n}\n\n/**\n * Create and track fetch request spans\n */\nexport function fetchCallback(\n  handlerData: FetchData,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): void {\n  if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {\n    return;\n  }\n\n  if (handlerData.endTimestamp) {\n    const spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      if (handlerData.response) {\n        // TODO (kmclb) remove this once types PR goes through\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        span.setHttpStatus(handlerData.response.status);\n      } else if (handlerData.error) {\n        span.setStatus('internal_error');\n      }\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n\n  const currentScope = getCurrentHub().getScope();\n  const currentSpan = currentScope && currentScope.getSpan();\n  const activeTransaction = currentSpan && currentSpan.transaction;\n\n  if (currentSpan && activeTransaction) {\n    const span = currentSpan.startChild({\n      data: {\n        ...handlerData.fetchData,\n        type: 'fetch',\n      },\n      description: `${handlerData.fetchData.method} ${handlerData.fetchData.url}`,\n      op: 'http.client',\n    });\n\n    handlerData.fetchData.__span = span.spanId;\n    spans[span.spanId] = span;\n\n    const request: string | Request = handlerData.args[0];\n\n    // In case the user hasn't set the second argument of a fetch call we default it to `{}`.\n    handlerData.args[1] = handlerData.args[1] || {};\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const options: { [key: string]: any } = handlerData.args[1];\n\n    if (shouldAttachHeaders(handlerData.fetchData.url)) {\n      options.headers = addTracingHeadersToFetchRequest(\n        request,\n        activeTransaction.getDynamicSamplingContext(),\n        span,\n        options,\n      );\n    }\n  }\n}\n\nfunction addTracingHeadersToFetchRequest(\n  request: string | Request,\n  dynamicSamplingContext: Partial<DynamicSamplingContext>,\n  span: Span,\n  options: {\n    headers?:\n      | {\n          [key: string]: string[] | string | undefined;\n        }\n      | Request['headers'];\n  },\n): PolymorphicRequestHeaders {\n  const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n  const sentryTraceHeader = span.toTraceparent();\n\n  const headers =\n    typeof Request !== 'undefined' && isInstanceOf(request, Request) ? (request as Request).headers : options.headers;\n\n  if (!headers) {\n    return { 'sentry-trace': sentryTraceHeader, baggage: sentryBaggageHeader };\n  } else if (typeof Headers !== 'undefined' && isInstanceOf(headers, Headers)) {\n    const newHeaders = new Headers(headers as Headers);\n\n    newHeaders.append('sentry-trace', sentryTraceHeader);\n\n    if (sentryBaggageHeader) {\n      // If the same header is appended miultiple times the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.append(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n\n    return newHeaders as PolymorphicRequestHeaders;\n  } else if (Array.isArray(headers)) {\n    const newHeaders = [...headers, ['sentry-trace', sentryTraceHeader]];\n\n    if (sentryBaggageHeader) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push([BAGGAGE_HEADER_NAME, sentryBaggageHeader]);\n    }\n\n    return newHeaders;\n  } else {\n    const existingBaggageHeader = 'baggage' in headers ? headers.baggage : undefined;\n    const newBaggageHeaders: string[] = [];\n\n    if (Array.isArray(existingBaggageHeader)) {\n      newBaggageHeaders.push(...existingBaggageHeader);\n    } else if (existingBaggageHeader) {\n      newBaggageHeaders.push(existingBaggageHeader);\n    }\n\n    if (sentryBaggageHeader) {\n      newBaggageHeaders.push(sentryBaggageHeader);\n    }\n\n    return {\n      ...(headers as Exclude<typeof headers, Headers>),\n      'sentry-trace': sentryTraceHeader,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined,\n    };\n  }\n}\n\n/**\n * Create and track xhr request spans\n */\nexport function xhrCallback(\n  handlerData: XHRData,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): void {\n  if (\n    !hasTracingEnabled() ||\n    (handlerData.xhr && handlerData.xhr.__sentry_own_request__) ||\n    !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))\n  ) {\n    return;\n  }\n\n  const xhr = handlerData.xhr.__sentry_xhr__;\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp) {\n    const spanId = handlerData.xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      span.setHttpStatus(xhr.status_code);\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n\n  const currentScope = getCurrentHub().getScope();\n  const currentSpan = currentScope && currentScope.getSpan();\n  const activeTransaction = currentSpan && currentSpan.transaction;\n\n  if (currentSpan && activeTransaction) {\n    const span = currentSpan.startChild({\n      data: {\n        ...xhr.data,\n        type: 'xhr',\n        method: xhr.method,\n        url: xhr.url,\n      },\n      description: `${xhr.method} ${xhr.url}`,\n      op: 'http.client',\n    });\n\n    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;\n    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;\n\n    if (handlerData.xhr.setRequestHeader && shouldAttachHeaders(handlerData.xhr.__sentry_xhr__.url)) {\n      try {\n        handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());\n\n        const dynamicSamplingContext = activeTransaction.getDynamicSamplingContext();\n        const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n\n        if (sentryBaggageHeader) {\n          // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n          // We can therefore simply set a baggage header without checking what was there before\n          // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n          handlerData.xhr.setRequestHeader(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n        }\n      } catch (_) {\n        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}