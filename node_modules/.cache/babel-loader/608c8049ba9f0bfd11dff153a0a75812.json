{"ast":null,"code":"var _s = $RefreshSig$();\nimport { Token } from '@uniswap/sdk-core';\nimport { SupportedChainId } from 'constants/chains';\nimport { NATIVE_CHAIN_ID, nativeOnChain, WRAPPED_NATIVE_CURRENCY } from 'constants/tokens';\nimport { useEffect } from 'react';\nimport { getNativeTokenDBAddress } from 'utils/nativeTokens';\nimport { Chain, HistoryDuration, TokenStandard } from './__generated__/types-and-hooks';\nexport let PollingInterval; // 3 seconds, approx block times for polygon\n\n// Polls a query only when the current component is mounted, as useQuery's pollInterval prop will continue to poll after unmount\n(function (PollingInterval) {\n  PollingInterval[PollingInterval[\"Slow\"] = 300000] = \"Slow\";\n  PollingInterval[PollingInterval[\"Normal\"] = 60000] = \"Normal\";\n  PollingInterval[PollingInterval[\"Fast\"] = 12000] = \"Fast\";\n  PollingInterval[PollingInterval[\"LightningMcQueen\"] = 3000] = \"LightningMcQueen\";\n})(PollingInterval || (PollingInterval = {}));\nexport function usePollQueryWhileMounted(queryResult, interval) {\n  _s();\n  const {\n    startPolling,\n    stopPolling\n  } = queryResult;\n  useEffect(() => {\n    startPolling(interval);\n    return stopPolling;\n  }, [interval, startPolling, stopPolling]);\n  return queryResult;\n}\n_s(usePollQueryWhileMounted, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nexport let TimePeriod;\n(function (TimePeriod) {\n  TimePeriod[TimePeriod[\"HOUR\"] = 0] = \"HOUR\";\n  TimePeriod[TimePeriod[\"DAY\"] = 1] = \"DAY\";\n  TimePeriod[TimePeriod[\"WEEK\"] = 2] = \"WEEK\";\n  TimePeriod[TimePeriod[\"MONTH\"] = 3] = \"MONTH\";\n  TimePeriod[TimePeriod[\"YEAR\"] = 4] = \"YEAR\";\n})(TimePeriod || (TimePeriod = {}));\nexport function toHistoryDuration(timePeriod) {\n  switch (timePeriod) {\n    case TimePeriod.HOUR:\n      return HistoryDuration.Hour;\n    case TimePeriod.DAY:\n      return HistoryDuration.Day;\n    case TimePeriod.WEEK:\n      return HistoryDuration.Week;\n    case TimePeriod.MONTH:\n      return HistoryDuration.Month;\n    case TimePeriod.YEAR:\n      return HistoryDuration.Year;\n  }\n}\nexport function isPricePoint(p) {\n  return p !== null;\n}\nexport const CHAIN_ID_TO_BACKEND_NAME = {\n  [SupportedChainId.MAINNET]: Chain.Ethereum,\n  [SupportedChainId.GOERLI]: Chain.EthereumGoerli,\n  [SupportedChainId.POLYGON]: Chain.Polygon,\n  [SupportedChainId.POLYGON_MUMBAI]: Chain.Polygon,\n  [SupportedChainId.CELO]: Chain.Celo,\n  [SupportedChainId.CELO_ALFAJORES]: Chain.Celo,\n  [SupportedChainId.ARBITRUM_ONE]: Chain.Arbitrum,\n  [SupportedChainId.ARBITRUM_GOERLI]: Chain.Arbitrum,\n  [SupportedChainId.OPTIMISM]: Chain.Optimism,\n  [SupportedChainId.OPTIMISM_GOERLI]: Chain.Optimism,\n  [SupportedChainId.BNB]: Chain.Bnb\n};\nexport function chainIdToBackendName(chainId) {\n  return chainId && CHAIN_ID_TO_BACKEND_NAME[chainId] ? CHAIN_ID_TO_BACKEND_NAME[chainId] : CHAIN_ID_TO_BACKEND_NAME[SupportedChainId.MAINNET];\n}\nconst GQL_CHAINS = [SupportedChainId.MAINNET, SupportedChainId.OPTIMISM, SupportedChainId.POLYGON, SupportedChainId.ARBITRUM_ONE, SupportedChainId.CELO];\nexport function isGqlSupportedChain(chainId) {\n  return !!chainId && GQL_CHAINS.includes(chainId);\n}\nexport function toContractInput(currency) {\n  const chain = chainIdToBackendName(currency.chainId);\n  return {\n    chain,\n    address: currency.isToken ? currency.address : getNativeTokenDBAddress(chain)\n  };\n}\nexport function gqlToCurrency(token) {\n  var _token$decimals;\n  const chainId = fromGraphQLChain(token.chain);\n  if (token.standard === TokenStandard.Native || !token.address) return nativeOnChain(chainId);else return new Token(chainId, token.address, (_token$decimals = token.decimals) !== null && _token$decimals !== void 0 ? _token$decimals : 18, token.name, token.symbol);\n}\nconst URL_CHAIN_PARAM_TO_BACKEND = {\n  ethereum: Chain.Ethereum,\n  polygon: Chain.Polygon,\n  celo: Chain.Celo,\n  arbitrum: Chain.Arbitrum,\n  optimism: Chain.Optimism,\n  bnb: Chain.Bnb\n};\nexport function validateUrlChainParam(chainName) {\n  return chainName && URL_CHAIN_PARAM_TO_BACKEND[chainName] ? URL_CHAIN_PARAM_TO_BACKEND[chainName] : Chain.Ethereum;\n}\n\n// TODO(cartcrom): refactor into safer lookup & replace usage\nexport const CHAIN_NAME_TO_CHAIN_ID = {\n  [Chain.Ethereum]: SupportedChainId.MAINNET,\n  [Chain.EthereumGoerli]: SupportedChainId.GOERLI,\n  [Chain.Polygon]: SupportedChainId.POLYGON,\n  [Chain.Celo]: SupportedChainId.CELO,\n  [Chain.Optimism]: SupportedChainId.OPTIMISM,\n  [Chain.Arbitrum]: SupportedChainId.ARBITRUM_ONE,\n  [Chain.UnknownChain]: SupportedChainId.MAINNET,\n  [Chain.Bnb]: SupportedChainId.BNB\n};\nexport function fromGraphQLChain(chain) {\n  return CHAIN_NAME_TO_CHAIN_ID[chain];\n}\nexport const BACKEND_CHAIN_NAMES = [Chain.Ethereum, Chain.Polygon, Chain.Optimism, Chain.Arbitrum, Chain.Celo];\nexport function getTokenDetailsURL(_ref) {\n  let {\n    address,\n    chain,\n    inputAddress\n  } = _ref;\n  const chainName = chain.toLowerCase();\n  const tokenAddress = address !== null && address !== void 0 ? address : NATIVE_CHAIN_ID;\n  const inputAddressSuffix = inputAddress ? `?inputCurrency=${inputAddress}` : '';\n  return `/tokens/${chainName}/${tokenAddress}${inputAddressSuffix}`;\n}\nexport function unwrapToken(chainId, token) {\n  var _WRAPPED_NATIVE_CURRE;\n  if (!(token === null || token === void 0 ? void 0 : token.address)) return token;\n  const address = token.address.toLowerCase();\n  const nativeAddress = (_WRAPPED_NATIVE_CURRE = WRAPPED_NATIVE_CURRENCY[chainId]) === null || _WRAPPED_NATIVE_CURRE === void 0 ? void 0 : _WRAPPED_NATIVE_CURRE.address.toLowerCase();\n  if (address !== nativeAddress) return token;\n  const nativeToken = nativeOnChain(chainId);\n  return {\n    ...token,\n    ...nativeToken,\n    address: NATIVE_CHAIN_ID,\n    extensions: undefined // prevents marking cross-chain wrapped tokens as native\n  };\n}","map":{"version":3,"names":["Token","SupportedChainId","NATIVE_CHAIN_ID","nativeOnChain","WRAPPED_NATIVE_CURRENCY","useEffect","getNativeTokenDBAddress","Chain","HistoryDuration","TokenStandard","PollingInterval","usePollQueryWhileMounted","queryResult","interval","startPolling","stopPolling","TimePeriod","toHistoryDuration","timePeriod","HOUR","Hour","DAY","Day","WEEK","Week","MONTH","Month","YEAR","Year","isPricePoint","p","CHAIN_ID_TO_BACKEND_NAME","MAINNET","Ethereum","GOERLI","EthereumGoerli","POLYGON","Polygon","POLYGON_MUMBAI","CELO","Celo","CELO_ALFAJORES","ARBITRUM_ONE","Arbitrum","ARBITRUM_GOERLI","OPTIMISM","Optimism","OPTIMISM_GOERLI","BNB","Bnb","chainIdToBackendName","chainId","GQL_CHAINS","isGqlSupportedChain","includes","toContractInput","currency","chain","address","isToken","gqlToCurrency","token","fromGraphQLChain","standard","Native","decimals","name","symbol","URL_CHAIN_PARAM_TO_BACKEND","ethereum","polygon","celo","arbitrum","optimism","bnb","validateUrlChainParam","chainName","CHAIN_NAME_TO_CHAIN_ID","UnknownChain","BACKEND_CHAIN_NAMES","getTokenDetailsURL","inputAddress","toLowerCase","tokenAddress","inputAddressSuffix","unwrapToken","nativeAddress","nativeToken","extensions","undefined"],"sources":["/home/diep/freelance/interface/src/graphql/data/util.tsx"],"sourcesContent":["import { QueryResult } from '@apollo/client'\nimport { Currency, Token } from '@uniswap/sdk-core'\nimport { SupportedChainId } from 'constants/chains'\nimport { NATIVE_CHAIN_ID, nativeOnChain, WRAPPED_NATIVE_CURRENCY } from 'constants/tokens'\nimport ms from 'ms.macro'\nimport { useEffect } from 'react'\nimport { getNativeTokenDBAddress } from 'utils/nativeTokens'\n\nimport { Chain, ContractInput, HistoryDuration, TokenStandard } from './__generated__/types-and-hooks'\n\nexport enum PollingInterval {\n  Slow = ms`5m`,\n  Normal = ms`1m`,\n  Fast = ms`12s`, // 12 seconds, block times for mainnet\n  LightningMcQueen = ms`3s`, // 3 seconds, approx block times for polygon\n}\n\n// Polls a query only when the current component is mounted, as useQuery's pollInterval prop will continue to poll after unmount\nexport function usePollQueryWhileMounted<T, K>(queryResult: QueryResult<T, K>, interval: PollingInterval) {\n  const { startPolling, stopPolling } = queryResult\n\n  useEffect(() => {\n    startPolling(interval)\n    return stopPolling\n  }, [interval, startPolling, stopPolling])\n\n  return queryResult\n}\n\nexport enum TimePeriod {\n  HOUR,\n  DAY,\n  WEEK,\n  MONTH,\n  YEAR,\n}\n\nexport function toHistoryDuration(timePeriod: TimePeriod): HistoryDuration {\n  switch (timePeriod) {\n    case TimePeriod.HOUR:\n      return HistoryDuration.Hour\n    case TimePeriod.DAY:\n      return HistoryDuration.Day\n    case TimePeriod.WEEK:\n      return HistoryDuration.Week\n    case TimePeriod.MONTH:\n      return HistoryDuration.Month\n    case TimePeriod.YEAR:\n      return HistoryDuration.Year\n  }\n}\n\nexport type PricePoint = { timestamp: number; value: number }\n\nexport function isPricePoint(p: PricePoint | null): p is PricePoint {\n  return p !== null\n}\n\nexport const CHAIN_ID_TO_BACKEND_NAME: { [key: number]: Chain } = {\n  [SupportedChainId.MAINNET]: Chain.Ethereum,\n  [SupportedChainId.GOERLI]: Chain.EthereumGoerli,\n  [SupportedChainId.POLYGON]: Chain.Polygon,\n  [SupportedChainId.POLYGON_MUMBAI]: Chain.Polygon,\n  [SupportedChainId.CELO]: Chain.Celo,\n  [SupportedChainId.CELO_ALFAJORES]: Chain.Celo,\n  [SupportedChainId.ARBITRUM_ONE]: Chain.Arbitrum,\n  [SupportedChainId.ARBITRUM_GOERLI]: Chain.Arbitrum,\n  [SupportedChainId.OPTIMISM]: Chain.Optimism,\n  [SupportedChainId.OPTIMISM_GOERLI]: Chain.Optimism,\n  [SupportedChainId.BNB]: Chain.Bnb,\n}\n\nexport function chainIdToBackendName(chainId: number | undefined) {\n  return chainId && CHAIN_ID_TO_BACKEND_NAME[chainId]\n    ? CHAIN_ID_TO_BACKEND_NAME[chainId]\n    : CHAIN_ID_TO_BACKEND_NAME[SupportedChainId.MAINNET]\n}\n\nconst GQL_CHAINS: number[] = [\n  SupportedChainId.MAINNET,\n  SupportedChainId.OPTIMISM,\n  SupportedChainId.POLYGON,\n  SupportedChainId.ARBITRUM_ONE,\n  SupportedChainId.CELO,\n]\n\nexport function isGqlSupportedChain(chainId: number | undefined): chainId is SupportedChainId {\n  return !!chainId && GQL_CHAINS.includes(chainId)\n}\nexport function toContractInput(currency: Currency): ContractInput {\n  const chain = chainIdToBackendName(currency.chainId)\n  return { chain, address: currency.isToken ? currency.address : getNativeTokenDBAddress(chain) }\n}\n\nexport function gqlToCurrency(token: {\n  address?: string\n  chain: Chain\n  standard?: TokenStandard\n  decimals?: number\n  name?: string\n  symbol?: string\n}): Currency {\n  const chainId = fromGraphQLChain(token.chain)\n  if (token.standard === TokenStandard.Native || !token.address) return nativeOnChain(chainId)\n  else return new Token(chainId, token.address, token.decimals ?? 18, token.name, token.symbol)\n}\n\nconst URL_CHAIN_PARAM_TO_BACKEND: { [key: string]: Chain } = {\n  ethereum: Chain.Ethereum,\n  polygon: Chain.Polygon,\n  celo: Chain.Celo,\n  arbitrum: Chain.Arbitrum,\n  optimism: Chain.Optimism,\n  bnb: Chain.Bnb,\n}\n\nexport function validateUrlChainParam(chainName: string | undefined) {\n  return chainName && URL_CHAIN_PARAM_TO_BACKEND[chainName] ? URL_CHAIN_PARAM_TO_BACKEND[chainName] : Chain.Ethereum\n}\n\n// TODO(cartcrom): refactor into safer lookup & replace usage\nexport const CHAIN_NAME_TO_CHAIN_ID: { [key in Chain]: SupportedChainId } = {\n  [Chain.Ethereum]: SupportedChainId.MAINNET,\n  [Chain.EthereumGoerli]: SupportedChainId.GOERLI,\n  [Chain.Polygon]: SupportedChainId.POLYGON,\n  [Chain.Celo]: SupportedChainId.CELO,\n  [Chain.Optimism]: SupportedChainId.OPTIMISM,\n  [Chain.Arbitrum]: SupportedChainId.ARBITRUM_ONE,\n  [Chain.UnknownChain]: SupportedChainId.MAINNET,\n  [Chain.Bnb]: SupportedChainId.BNB,\n}\n\nexport function fromGraphQLChain(chain: Chain): SupportedChainId {\n  return CHAIN_NAME_TO_CHAIN_ID[chain]\n}\n\nexport const BACKEND_CHAIN_NAMES: Chain[] = [Chain.Ethereum, Chain.Polygon, Chain.Optimism, Chain.Arbitrum, Chain.Celo]\n\nexport function getTokenDetailsURL({\n  address,\n  chain,\n  inputAddress,\n}: {\n  address?: string | null\n  chain: Chain\n  inputAddress?: string | null\n}) {\n  const chainName = chain.toLowerCase()\n  const tokenAddress = address ?? NATIVE_CHAIN_ID\n  const inputAddressSuffix = inputAddress ? `?inputCurrency=${inputAddress}` : ''\n  return `/tokens/${chainName}/${tokenAddress}${inputAddressSuffix}`\n}\n\nexport function unwrapToken<\n  T extends {\n    address?: string | null | undefined\n  } | null\n>(chainId: number, token: T): T {\n  if (!token?.address) return token\n\n  const address = token.address.toLowerCase()\n  const nativeAddress = WRAPPED_NATIVE_CURRENCY[chainId]?.address.toLowerCase()\n  if (address !== nativeAddress) return token\n\n  const nativeToken = nativeOnChain(chainId)\n  return {\n    ...token,\n    ...nativeToken,\n    address: NATIVE_CHAIN_ID,\n    extensions: undefined, // prevents marking cross-chain wrapped tokens as native\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}