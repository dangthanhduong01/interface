{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$(),\n  _s5 = $RefreshSig$(),\n  _s6 = $RefreshSig$();\nimport { abi as MulticallABI } from '@uniswap/v3-periphery/artifacts/contracts/lens/UniswapInterfaceMulticall.sol/UniswapInterfaceMulticall.json';\nimport { abi as NFTPositionManagerABI } from '@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json';\nimport { useWeb3React } from '@web3-react/core';\nimport { MULTICALL_ADDRESS, NONFUNGIBLE_POSITION_MANAGER_ADDRESSES as V3NFT_ADDRESSES } from 'constants/addresses';\nimport { isSupportedChain } from 'constants/chains';\nimport { RPC_PROVIDERS } from 'constants/providers';\nimport { useUniswapPricesQuery } from 'graphql/data/__generated__/types-and-hooks';\nimport { toContractInput } from 'graphql/data/util';\nimport useStablecoinPrice from 'hooks/useStablecoinPrice';\nimport { useMemo } from 'react';\nimport { getContract } from 'utils';\nimport { currencyKey, currencyKeyFromGraphQL } from 'utils/currencyKey';\n// Constructs a chain-to-contract map, using the wallet's provider when available\nfunction useContractMultichain(addressMap, ABI, chainIds) {\n  _s();\n  const {\n    chainId: walletChainId,\n    provider: walletProvider\n  } = useWeb3React();\n  return useMemo(() => {\n    const relevantChains = chainIds !== null && chainIds !== void 0 ? chainIds : Object.keys(addressMap).map(chainId => parseInt(chainId)).filter(isSupportedChain);\n    return relevantChains.reduce((acc, chainId) => {\n      const provider = walletProvider && walletChainId === chainId ? walletProvider : RPC_PROVIDERS[chainId];\n      acc[chainId] = getContract(addressMap[chainId], ABI, provider);\n      return acc;\n    }, {});\n  }, [ABI, addressMap, chainIds, walletChainId, walletProvider]);\n}\n_s(useContractMultichain, \"pnc6Ub8mLDu32b1f68wZv0LSFE0=\", false, function () {\n  return [useWeb3React];\n});\nexport function useV3ManagerContracts(chainIds) {\n  _s2();\n  return useContractMultichain(V3NFT_ADDRESSES, NFTPositionManagerABI, chainIds);\n}\n_s2(useV3ManagerContracts, \"CB4tc+fGLORetTmQr98kwKUiJdM=\", false, function () {\n  return [useContractMultichain];\n});\nexport function useInterfaceMulticallContracts(chainIds) {\n  _s3();\n  return useContractMultichain(MULTICALL_ADDRESS, MulticallABI, chainIds);\n}\n_s3(useInterfaceMulticallContracts, \"CB4tc+fGLORetTmQr98kwKUiJdM=\", false, function () {\n  return [useContractMultichain];\n});\nexport function usePoolPriceMap(positions) {\n  _s4();\n  const contracts = useMemo(() => {\n    if (!positions || !positions.length) return [];\n    // Avoids fetching duplicate tokens by placing in map\n    const contractMap = positions.reduce((acc, _ref) => {\n      let {\n        pool: {\n          token0,\n          token1\n        }\n      } = _ref;\n      acc[currencyKey(token0)] = toContractInput(token0);\n      acc[currencyKey(token1)] = toContractInput(token1);\n      return acc;\n    }, {});\n    return Object.values(contractMap);\n  }, [positions]);\n  const {\n    data,\n    loading\n  } = useUniswapPricesQuery({\n    variables: {\n      contracts\n    },\n    skip: !contracts.length\n  });\n  const priceMap = useMemo(() => {\n    var _data$tokens$reduce, _data$tokens;\n    return (_data$tokens$reduce = data === null || data === void 0 ? void 0 : (_data$tokens = data.tokens) === null || _data$tokens === void 0 ? void 0 : _data$tokens.reduce((acc, current) => {\n      var _current$project, _current$project$mark, _current$project$mark2, _current$project$mark3;\n      if (current) acc[currencyKeyFromGraphQL(current)] = (_current$project = current.project) === null || _current$project === void 0 ? void 0 : (_current$project$mark = _current$project.markets) === null || _current$project$mark === void 0 ? void 0 : (_current$project$mark2 = _current$project$mark[0]) === null || _current$project$mark2 === void 0 ? void 0 : (_current$project$mark3 = _current$project$mark2.price) === null || _current$project$mark3 === void 0 ? void 0 : _current$project$mark3.value;\n      return acc;\n    }, {})) !== null && _data$tokens$reduce !== void 0 ? _data$tokens$reduce : {};\n  }, [data === null || data === void 0 ? void 0 : data.tokens]);\n  return {\n    priceMap,\n    pricesLoading: loading && !data\n  };\n}\n_s4(usePoolPriceMap, \"kntTl+o9KhoNtahFRXKgdmq3Dhk=\", false, function () {\n  return [useUniswapPricesQuery];\n});\nfunction useFeeValue(token, fee, queriedPrice) {\n  _s5();\n  const stablecoinPrice = useStablecoinPrice(!queriedPrice ? token : undefined);\n  return useMemo(() => {\n    // Prefers gql price, as fetching stablecoinPrice will trigger multiple infura calls for each pool position\n    const price = queriedPrice !== null && queriedPrice !== void 0 ? queriedPrice : stablecoinPrice ? parseFloat(stablecoinPrice.toSignificant()) : undefined;\n    const feeValue = fee && price ? fee * price : undefined;\n    return [price, feeValue];\n  }, [fee, queriedPrice, stablecoinPrice]);\n}\n_s5(useFeeValue, \"4Ze2hdfdwHIZ+XWrkmGSZro4U7Y=\", false, function () {\n  return [useStablecoinPrice];\n});\nexport function useFeeValues(position) {\n  _s6();\n  var _position$fees, _position$prices, _position$fees2, _position$prices2;\n  const [priceA, feeValueA] = useFeeValue(position.pool.token0, (_position$fees = position.fees) === null || _position$fees === void 0 ? void 0 : _position$fees[0], (_position$prices = position.prices) === null || _position$prices === void 0 ? void 0 : _position$prices[0]);\n  const [priceB, feeValueB] = useFeeValue(position.pool.token1, (_position$fees2 = position.fees) === null || _position$fees2 === void 0 ? void 0 : _position$fees2[1], (_position$prices2 = position.prices) === null || _position$prices2 === void 0 ? void 0 : _position$prices2[1]);\n  return {\n    priceA,\n    priceB,\n    fees: (feeValueA || 0) + (feeValueB || 0)\n  };\n}\n_s6(useFeeValues, \"HaDtuJXSU4TgWPcJlwfgzPIMqNo=\", false, function () {\n  return [useFeeValue, useFeeValue];\n});","map":{"version":3,"names":["abi","MulticallABI","NFTPositionManagerABI","useWeb3React","MULTICALL_ADDRESS","NONFUNGIBLE_POSITION_MANAGER_ADDRESSES","V3NFT_ADDRESSES","isSupportedChain","RPC_PROVIDERS","useUniswapPricesQuery","toContractInput","useStablecoinPrice","useMemo","getContract","currencyKey","currencyKeyFromGraphQL","useContractMultichain","addressMap","ABI","chainIds","chainId","walletChainId","provider","walletProvider","relevantChains","Object","keys","map","parseInt","filter","reduce","acc","useV3ManagerContracts","useInterfaceMulticallContracts","usePoolPriceMap","positions","contracts","length","contractMap","pool","token0","token1","values","data","loading","variables","skip","priceMap","tokens","current","project","markets","price","value","pricesLoading","useFeeValue","token","fee","queriedPrice","stablecoinPrice","undefined","parseFloat","toSignificant","feeValue","useFeeValues","position","priceA","feeValueA","fees","prices","priceB","feeValueB"],"sources":["/home/diep/freelance/interface/src/components/AccountDrawer/MiniPortfolio/Pools/hooks.ts"],"sourcesContent":["import { Token } from '@uniswap/sdk-core'\nimport { AddressMap } from '@uniswap/smart-order-router'\nimport { abi as MulticallABI } from '@uniswap/v3-periphery/artifacts/contracts/lens/UniswapInterfaceMulticall.sol/UniswapInterfaceMulticall.json'\nimport { abi as NFTPositionManagerABI } from '@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json'\nimport { useWeb3React } from '@web3-react/core'\nimport { MULTICALL_ADDRESS, NONFUNGIBLE_POSITION_MANAGER_ADDRESSES as V3NFT_ADDRESSES } from 'constants/addresses'\nimport { isSupportedChain, SupportedChainId } from 'constants/chains'\nimport { RPC_PROVIDERS } from 'constants/providers'\nimport { BaseContract } from 'ethers/lib/ethers'\nimport { ContractInput, useUniswapPricesQuery } from 'graphql/data/__generated__/types-and-hooks'\nimport { toContractInput } from 'graphql/data/util'\nimport useStablecoinPrice from 'hooks/useStablecoinPrice'\nimport { useMemo } from 'react'\nimport { NonfungiblePositionManager, UniswapInterfaceMulticall } from 'types/v3'\nimport { getContract } from 'utils'\nimport { CurrencyKey, currencyKey, currencyKeyFromGraphQL } from 'utils/currencyKey'\n\nimport { PositionInfo } from './cache'\n\ntype ContractMap<T extends BaseContract> = { [key: number]: T }\n\n// Constructs a chain-to-contract map, using the wallet's provider when available\nfunction useContractMultichain<T extends BaseContract>(\n  addressMap: AddressMap,\n  ABI: any,\n  chainIds?: SupportedChainId[]\n): ContractMap<T> {\n  const { chainId: walletChainId, provider: walletProvider } = useWeb3React()\n\n  return useMemo(() => {\n    const relevantChains =\n      chainIds ??\n      Object.keys(addressMap)\n        .map((chainId) => parseInt(chainId))\n        .filter(isSupportedChain)\n\n    return relevantChains.reduce((acc: ContractMap<T>, chainId) => {\n      const provider = walletProvider && walletChainId === chainId ? walletProvider : RPC_PROVIDERS[chainId]\n      acc[chainId] = getContract(addressMap[chainId], ABI, provider) as T\n      return acc\n    }, {})\n  }, [ABI, addressMap, chainIds, walletChainId, walletProvider])\n}\n\nexport function useV3ManagerContracts(chainIds: SupportedChainId[]): ContractMap<NonfungiblePositionManager> {\n  return useContractMultichain<NonfungiblePositionManager>(V3NFT_ADDRESSES, NFTPositionManagerABI, chainIds)\n}\n\nexport function useInterfaceMulticallContracts(chainIds: SupportedChainId[]): ContractMap<UniswapInterfaceMulticall> {\n  return useContractMultichain<UniswapInterfaceMulticall>(MULTICALL_ADDRESS, MulticallABI, chainIds)\n}\n\ntype PriceMap = { [key: CurrencyKey]: number | undefined }\nexport function usePoolPriceMap(positions: PositionInfo[] | undefined) {\n  const contracts = useMemo(() => {\n    if (!positions || !positions.length) return []\n    // Avoids fetching duplicate tokens by placing in map\n    const contractMap = positions.reduce((acc: { [key: string]: ContractInput }, { pool: { token0, token1 } }) => {\n      acc[currencyKey(token0)] = toContractInput(token0)\n      acc[currencyKey(token1)] = toContractInput(token1)\n      return acc\n    }, {})\n    return Object.values(contractMap)\n  }, [positions])\n\n  const { data, loading } = useUniswapPricesQuery({ variables: { contracts }, skip: !contracts.length })\n\n  const priceMap = useMemo(\n    () =>\n      data?.tokens?.reduce((acc: PriceMap, current) => {\n        if (current) acc[currencyKeyFromGraphQL(current)] = current.project?.markets?.[0]?.price?.value\n        return acc\n      }, {}) ?? {},\n    [data?.tokens]\n  )\n\n  return { priceMap, pricesLoading: loading && !data }\n}\n\nfunction useFeeValue(token: Token, fee: number | undefined, queriedPrice: number | undefined) {\n  const stablecoinPrice = useStablecoinPrice(!queriedPrice ? token : undefined)\n  return useMemo(() => {\n    // Prefers gql price, as fetching stablecoinPrice will trigger multiple infura calls for each pool position\n    const price = queriedPrice ?? (stablecoinPrice ? parseFloat(stablecoinPrice.toSignificant()) : undefined)\n    const feeValue = fee && price ? fee * price : undefined\n\n    return [price, feeValue]\n  }, [fee, queriedPrice, stablecoinPrice])\n}\n\nexport function useFeeValues(position: PositionInfo) {\n  const [priceA, feeValueA] = useFeeValue(position.pool.token0, position.fees?.[0], position.prices?.[0])\n  const [priceB, feeValueB] = useFeeValue(position.pool.token1, position.fees?.[1], position.prices?.[1])\n\n  return { priceA, priceB, fees: (feeValueA || 0) + (feeValueB || 0) }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}