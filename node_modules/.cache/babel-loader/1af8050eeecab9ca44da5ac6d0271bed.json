{"ast":null,"code":"import { logger, addInstrumentationHandler } from '@sentry/utils';\nimport { WINDOW } from './types.js';\n\n/**\n * Default function implementing pageload and navigation transactions\n */\nfunction instrumentRoutingWithDefaults(customStartTransaction) {\n  let startTransactionOnPageLoad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let startTransactionOnLocationChange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!WINDOW || !WINDOW.location) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n  let startingUrl = WINDOW.location.href;\n  let activeTransaction;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = customStartTransaction({\n      name: WINDOW.location.pathname,\n      op: 'pageload',\n      metadata: {\n        source: 'url'\n      }\n    });\n  }\n  if (startTransactionOnLocationChange) {\n    addInstrumentationHandler('history', _ref => {\n      let {\n        to,\n        from\n      } = _ref;\n      /**\n       * This early return is there to account for some cases where a navigation transaction starts right after\n       * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n       * create an uneccessary navigation transaction.\n       *\n       * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n       * only be caused in certain development environments where the usage of a hot module reloader is causing\n       * errors.\n       */\n      if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n        startingUrl = undefined;\n        return;\n      }\n      if (from !== to) {\n        startingUrl = undefined;\n        if (activeTransaction) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);\n          // If there's an open transaction on the scope, we need to finish it before creating an new one.\n          activeTransaction.finish();\n        }\n        activeTransaction = customStartTransaction({\n          name: WINDOW.location.pathname,\n          op: 'navigation',\n          metadata: {\n            source: 'url'\n          }\n        });\n      }\n    });\n  }\n}\nexport { instrumentRoutingWithDefaults };","map":{"version":3,"sources":["../../../src/browser/router.ts"],"names":[],"mappings":";;;AAKA;AACA;AACA;AACA,SAAA,6BAAA,CACA,sBAAA,EAGA;EAAA,IAFA,0BAAA,uEAAA,IAAA;EAAA,IACA,gCAAA,uEAAA,IAAA;EAEA,IAAA,CAAA,MAAA,IAAA,CAAA,MAAA,CAAA,QAAA,EAAA;IACA,CAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,KAAA,MAAA,CAAA,IAAA,CAAA,sEAAA,CAAA;IACA;EACA;EAEA,IAAA,WAAA,GAAA,MAAA,CAAA,QAAA,CAAA,IAAA;EAEA,IAAA,iBAAA;EACA,IAAA,0BAAA,EAAA;IACA,iBAAA,GAAA,sBAAA,CAAA;MACA,IAAA,EAAA,MAAA,CAAA,QAAA,CAAA,QAAA;MACA,EAAA,EAAA,UAAA;MACA,QAAA,EAAA;QAAA,MAAA,EAAA;MAAA;IACA,CAAA,CAAA;EACA;EAEA,IAAA,gCAAA,EAAA;IACA,yBAAA,CAAA,SAAA,EAAA,QAAA;MAAA,IAAA;QAAA,EAAA;QAAA;MAAA,CAAA;MACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACA,IAAA,IAAA,KAAA,SAAA,IAAA,WAAA,IAAA,WAAA,CAAA,OAAA,CAAA,EAAA,CAAA,KAAA,CAAA,CAAA,EAAA;QACA,WAAA,GAAA,SAAA;QACA;MACA;MAEA,IAAA,IAAA,KAAA,EAAA,EAAA;QACA,WAAA,GAAA,SAAA;QACA,IAAA,iBAAA,EAAA;UACA,CAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,KAAA,MAAA,CAAA,GAAA,CAAA,oDAAA,iBAAA,CAAA,EAAA,EAAA,CAAA;UACA;UACA,iBAAA,CAAA,MAAA,EAAA;QACA;QACA,iBAAA,GAAA,sBAAA,CAAA;UACA,IAAA,EAAA,MAAA,CAAA,QAAA,CAAA,QAAA;UACA,EAAA,EAAA,YAAA;UACA,QAAA,EAAA;YAAA,MAAA,EAAA;UAAA;QACA,CAAA,CAAA;MACA;IACA,CAAA,CAAA;EACA;AACA","sourcesContent":["import type { Transaction, TransactionContext } from '@sentry/types';\nimport { addInstrumentationHandler, logger } from '@sentry/utils';\n\nimport { WINDOW } from './types';\n\n/**\n * Default function implementing pageload and navigation transactions\n */\nexport function instrumentRoutingWithDefaults<T extends Transaction>(\n  customStartTransaction: (context: TransactionContext) => T | undefined,\n  startTransactionOnPageLoad: boolean = true,\n  startTransactionOnLocationChange: boolean = true,\n): void {\n  if (!WINDOW || !WINDOW.location) {\n    __DEBUG_BUILD__ && logger.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n\n  let startingUrl: string | undefined = WINDOW.location.href;\n\n  let activeTransaction: T | undefined;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = customStartTransaction({\n      name: WINDOW.location.pathname,\n      op: 'pageload',\n      metadata: { source: 'url' },\n    });\n  }\n\n  if (startTransactionOnLocationChange) {\n    addInstrumentationHandler('history', ({ to, from }: { to: string; from?: string }) => {\n      /**\n       * This early return is there to account for some cases where a navigation transaction starts right after\n       * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n       * create an uneccessary navigation transaction.\n       *\n       * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n       * only be caused in certain development environments where the usage of a hot module reloader is causing\n       * errors.\n       */\n      if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n        startingUrl = undefined;\n        return;\n      }\n\n      if (from !== to) {\n        startingUrl = undefined;\n        if (activeTransaction) {\n          __DEBUG_BUILD__ && logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);\n          // If there's an open transaction on the scope, we need to finish it before creating an new one.\n          activeTransaction.finish();\n        }\n        activeTransaction = customStartTransaction({\n          name: WINDOW.location.pathname,\n          op: 'navigation',\n          metadata: { source: 'url' },\n        });\n      }\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}