{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { Trans } from \"@lingui/react\";\nimport { TradeType } from '@uniswap/sdk-core';\nimport { useWeb3React } from '@web3-react/core';\nimport useAutoSlippageTolerance from 'hooks/useAutoSlippageTolerance';\nimport { useBestTrade } from 'hooks/useBestTrade';\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount';\nimport { useCallback, useEffect, useMemo } from 'react';\nimport { useAppDispatch } from 'state/hooks';\nimport { useUserSlippageToleranceWithDefault } from 'state/user/hooks';\nimport { TOKEN_SHORTHANDS } from '../../constants/tokens';\nimport { useCurrency } from '../../hooks/Tokens';\nimport useENS from '../../hooks/useENS';\nimport useParsedQueryString from '../../hooks/useParsedQueryString';\nimport { isAddress } from '../../utils';\nimport { useCurrencyBalances } from '../connection/hooks';\nimport { Field, replaceSwapState, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function useSwapActionHandlers(dispatch) {\n  _s();\n  const onCurrencySelection = useCallback((field, currency) => {\n    dispatch(selectCurrency({\n      field,\n      currencyId: currency.isToken ? currency.address : currency.isNative ? 'ETH' : ''\n    }));\n  }, [dispatch]);\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies());\n  }, [dispatch]);\n  const onUserInput = useCallback((field, typedValue) => {\n    dispatch(typeInput({\n      field,\n      typedValue\n    }));\n  }, [dispatch]);\n  const onChangeRecipient = useCallback(recipient => {\n    dispatch(setRecipient({\n      recipient\n    }));\n  }, [dispatch]);\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient\n  };\n}\n_s(useSwapActionHandlers, \"y5vWYZ3b/a1SX5zG/w+44qTCRTw=\");\nconst BAD_RECIPIENT_ADDRESSES = {\n  '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f': true,\n  // v2 factory\n  '0xf164fC0Ec4E93095b804a4795bBe1e041497b92a': true,\n  // v2 router 01\n  '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D': true // v2 router 02\n};\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(state) {\n  _s2();\n  var _ref, _ref3;\n  const {\n    account\n  } = useWeb3React();\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: {\n      currencyId: inputCurrencyId\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrencyId\n    },\n    recipient\n  } = state;\n  const inputCurrency = useCurrency(inputCurrencyId);\n  const outputCurrency = useCurrency(outputCurrencyId);\n  const recipientLookup = useENS(recipient !== null && recipient !== void 0 ? recipient : undefined);\n  const to = (_ref = recipient === null ? account : recipientLookup.address) !== null && _ref !== void 0 ? _ref : null;\n  const relevantTokenBalances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, useMemo(() => [inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined], [inputCurrency, outputCurrency]));\n  const isExactIn = independentField === Field.INPUT;\n  const parsedAmount = useMemo(() => {\n    var _ref2;\n    return tryParseCurrencyAmount(typedValue, (_ref2 = isExactIn ? inputCurrency : outputCurrency) !== null && _ref2 !== void 0 ? _ref2 : undefined);\n  }, [inputCurrency, isExactIn, outputCurrency, typedValue]);\n  const trade = useBestTrade(isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT, parsedAmount, (_ref3 = isExactIn ? outputCurrency : inputCurrency) !== null && _ref3 !== void 0 ? _ref3 : undefined);\n  const currencyBalances = useMemo(() => ({\n    [Field.INPUT]: relevantTokenBalances[0],\n    [Field.OUTPUT]: relevantTokenBalances[1]\n  }), [relevantTokenBalances]);\n  const currencies = useMemo(() => ({\n    [Field.INPUT]: inputCurrency,\n    [Field.OUTPUT]: outputCurrency\n  }), [inputCurrency, outputCurrency]);\n\n  // allowed slippage is either auto slippage, or custom user defined slippage if auto slippage disabled\n  const autoSlippageTolerance = useAutoSlippageTolerance(trade.trade);\n  const allowedSlippage = useUserSlippageToleranceWithDefault(autoSlippageTolerance);\n  const inputError = useMemo(() => {\n    var _trade$trade;\n    let inputError;\n    if (!account) {\n      inputError = /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Connect Wallet\"\n      }, void 0, false, void 0, this);\n    }\n    if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n      var _inputError;\n      inputError = (_inputError = inputError) !== null && _inputError !== void 0 ? _inputError : /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Select a token\"\n      }, void 0, false, void 0, this);\n    }\n    if (!parsedAmount) {\n      var _inputError2;\n      inputError = (_inputError2 = inputError) !== null && _inputError2 !== void 0 ? _inputError2 : /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Enter an amount\"\n      }, void 0, false, void 0, this);\n    }\n    const formattedTo = isAddress(to);\n    if (!to || !formattedTo) {\n      var _inputError3;\n      inputError = (_inputError3 = inputError) !== null && _inputError3 !== void 0 ? _inputError3 : /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Enter a recipient\"\n      }, void 0, false, void 0, this);\n    } else {\n      if (BAD_RECIPIENT_ADDRESSES[formattedTo]) {\n        var _inputError4;\n        inputError = (_inputError4 = inputError) !== null && _inputError4 !== void 0 ? _inputError4 : /*#__PURE__*/_jsxDEV(Trans, {\n          id: \"Invalid recipient\"\n        }, void 0, false, void 0, this);\n      }\n    }\n\n    // compare input balance to max input based on version\n    const [balanceIn, amountIn] = [currencyBalances[Field.INPUT], (_trade$trade = trade.trade) === null || _trade$trade === void 0 ? void 0 : _trade$trade.maximumAmountIn(allowedSlippage)];\n    if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n      inputError = /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Insufficient {0} balance\",\n        values: {\n          0: amountIn.currency.symbol\n        }\n      }, void 0, false, void 0, this);\n    }\n    return inputError;\n  }, [account, allowedSlippage, currencies, currencyBalances, parsedAmount, to, trade.trade]);\n  return useMemo(() => ({\n    currencies,\n    currencyBalances,\n    parsedAmount,\n    inputError,\n    trade,\n    allowedSlippage\n  }), [allowedSlippage, currencies, currencyBalances, inputError, parsedAmount, trade]);\n}\n_s2(useDerivedSwapInfo, \"3Sm/ae12QaPryXN68CwfOLqG+T0=\", false, function () {\n  return [useWeb3React, useCurrency, useCurrency, useENS, useCurrencyBalances, useBestTrade, useAutoSlippageTolerance, useUserSlippageToleranceWithDefault];\n});\nfunction parseCurrencyFromURLParameter(urlParam) {\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam);\n    if (valid) return valid;\n    const upper = urlParam.toUpperCase();\n    if (upper === 'ETH') return 'ETH';\n    if (upper in TOKEN_SHORTHANDS) return upper;\n  }\n  return '';\n}\nfunction parseTokenAmountURLParameter(urlParam) {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : '';\n}\nfunction parseIndependentFieldURLParameter(urlParam) {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT;\n}\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\nfunction validatedRecipient(recipient) {\n  if (typeof recipient !== 'string') return null;\n  const address = isAddress(recipient);\n  if (address) return address;\n  if (ENS_NAME_REGEX.test(recipient)) return recipient;\n  if (ADDRESS_REGEX.test(recipient)) return recipient;\n  return null;\n}\nexport function queryParametersToSwapState(parsedQs) {\n  var _inputCurrency, _outputCurrency;\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency);\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency);\n  const typedValue = parseTokenAmountURLParameter(parsedQs.exactAmount);\n  const independentField = parseIndependentFieldURLParameter(parsedQs.exactField);\n  if (inputCurrency === '' && outputCurrency === '' && typedValue === '' && independentField === Field.INPUT) {\n    // Defaults to having the native currency selected\n    inputCurrency = 'ETH';\n  } else if (inputCurrency === outputCurrency) {\n    // clear output if identical\n    outputCurrency = '';\n  }\n  const recipient = validatedRecipient(parsedQs.recipient);\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency === '' ? null : (_inputCurrency = inputCurrency) !== null && _inputCurrency !== void 0 ? _inputCurrency : null\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency === '' ? null : (_outputCurrency = outputCurrency) !== null && _outputCurrency !== void 0 ? _outputCurrency : null\n    },\n    typedValue,\n    independentField,\n    recipient\n  };\n}\n\n// updates the swap state to use the defaults for a given network\nexport function useDefaultsFromURLSearch() {\n  _s3();\n  const {\n    chainId\n  } = useWeb3React();\n  const dispatch = useAppDispatch();\n  const parsedQs = useParsedQueryString();\n  const parsedSwapState = useMemo(() => {\n    return queryParametersToSwapState(parsedQs);\n  }, [parsedQs]);\n  useEffect(() => {\n    var _parsedSwapState$Fiel, _parsedSwapState$Fiel2;\n    if (!chainId) return;\n    const inputCurrencyId = (_parsedSwapState$Fiel = parsedSwapState[Field.INPUT].currencyId) !== null && _parsedSwapState$Fiel !== void 0 ? _parsedSwapState$Fiel : undefined;\n    const outputCurrencyId = (_parsedSwapState$Fiel2 = parsedSwapState[Field.OUTPUT].currencyId) !== null && _parsedSwapState$Fiel2 !== void 0 ? _parsedSwapState$Fiel2 : undefined;\n    dispatch(replaceSwapState({\n      typedValue: parsedSwapState.typedValue,\n      field: parsedSwapState.independentField,\n      inputCurrencyId,\n      outputCurrencyId,\n      recipient: parsedSwapState.recipient\n    }));\n  }, [dispatch, chainId, parsedSwapState]);\n  return parsedSwapState;\n}\n_s3(useDefaultsFromURLSearch, \"BYEOb9CgwVQuPZp3u4tO7pbtrNI=\", false, function () {\n  return [useWeb3React, useAppDispatch, useParsedQueryString];\n});","map":{"version":3,"names":["TradeType","useWeb3React","useAutoSlippageTolerance","useBestTrade","tryParseCurrencyAmount","useCallback","useEffect","useMemo","useAppDispatch","useUserSlippageToleranceWithDefault","TOKEN_SHORTHANDS","useCurrency","useENS","useParsedQueryString","isAddress","useCurrencyBalances","Field","replaceSwapState","selectCurrency","setRecipient","switchCurrencies","typeInput","useSwapActionHandlers","dispatch","onCurrencySelection","field","currency","currencyId","isToken","address","isNative","onSwitchTokens","onUserInput","typedValue","onChangeRecipient","recipient","BAD_RECIPIENT_ADDRESSES","useDerivedSwapInfo","state","account","independentField","INPUT","inputCurrencyId","OUTPUT","outputCurrencyId","inputCurrency","outputCurrency","recipientLookup","undefined","to","relevantTokenBalances","isExactIn","parsedAmount","trade","EXACT_INPUT","EXACT_OUTPUT","currencyBalances","currencies","autoSlippageTolerance","allowedSlippage","inputError","formattedTo","balanceIn","amountIn","maximumAmountIn","lessThan","symbol","parseCurrencyFromURLParameter","urlParam","valid","upper","toUpperCase","parseTokenAmountURLParameter","isNaN","parseFloat","parseIndependentFieldURLParameter","toLowerCase","ENS_NAME_REGEX","ADDRESS_REGEX","validatedRecipient","test","queryParametersToSwapState","parsedQs","exactAmount","exactField","useDefaultsFromURLSearch","chainId","parsedSwapState"],"sources":["/home/diep/freelance/interface/src/state/swap/hooks.tsx"],"sourcesContent":["import { Trans } from '@lingui/macro'\nimport { Currency, CurrencyAmount, Percent, TradeType } from '@uniswap/sdk-core'\nimport { useWeb3React } from '@web3-react/core'\nimport useAutoSlippageTolerance from 'hooks/useAutoSlippageTolerance'\nimport { useBestTrade } from 'hooks/useBestTrade'\nimport tryParseCurrencyAmount from 'lib/utils/tryParseCurrencyAmount'\nimport { ParsedQs } from 'qs'\nimport { ReactNode, useCallback, useEffect, useMemo } from 'react'\nimport { AnyAction } from 'redux'\nimport { useAppDispatch } from 'state/hooks'\nimport { InterfaceTrade, TradeState } from 'state/routing/types'\nimport { useUserSlippageToleranceWithDefault } from 'state/user/hooks'\n\nimport { TOKEN_SHORTHANDS } from '../../constants/tokens'\nimport { useCurrency } from '../../hooks/Tokens'\nimport useENS from '../../hooks/useENS'\nimport useParsedQueryString from '../../hooks/useParsedQueryString'\nimport { isAddress } from '../../utils'\nimport { useCurrencyBalances } from '../connection/hooks'\nimport { Field, replaceSwapState, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions'\nimport { SwapState } from './reducer'\n\nexport function useSwapActionHandlers(dispatch: React.Dispatch<AnyAction>): {\n  onCurrencySelection: (field: Field, currency: Currency) => void\n  onSwitchTokens: () => void\n  onUserInput: (field: Field, typedValue: string) => void\n  onChangeRecipient: (recipient: string | null) => void\n} {\n  const onCurrencySelection = useCallback(\n    (field: Field, currency: Currency) => {\n      dispatch(\n        selectCurrency({\n          field,\n          currencyId: currency.isToken ? currency.address : currency.isNative ? 'ETH' : '',\n        })\n      )\n    },\n    [dispatch]\n  )\n\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies())\n  }, [dispatch])\n\n  const onUserInput = useCallback(\n    (field: Field, typedValue: string) => {\n      dispatch(typeInput({ field, typedValue }))\n    },\n    [dispatch]\n  )\n\n  const onChangeRecipient = useCallback(\n    (recipient: string | null) => {\n      dispatch(setRecipient({ recipient }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient,\n  }\n}\n\nconst BAD_RECIPIENT_ADDRESSES: { [address: string]: true } = {\n  '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f': true, // v2 factory\n  '0xf164fC0Ec4E93095b804a4795bBe1e041497b92a': true, // v2 router 01\n  '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D': true, // v2 router 02\n}\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(state: SwapState): {\n  currencies: { [field in Field]?: Currency | null }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  parsedAmount: CurrencyAmount<Currency> | undefined\n  inputError?: ReactNode\n  trade: {\n    trade: InterfaceTrade<Currency, Currency, TradeType> | undefined\n    state: TradeState\n  }\n  allowedSlippage: Percent\n} {\n  const { account } = useWeb3React()\n\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: { currencyId: inputCurrencyId },\n    [Field.OUTPUT]: { currencyId: outputCurrencyId },\n    recipient,\n  } = state\n\n  const inputCurrency = useCurrency(inputCurrencyId)\n  const outputCurrency = useCurrency(outputCurrencyId)\n  const recipientLookup = useENS(recipient ?? undefined)\n  const to: string | null = (recipient === null ? account : recipientLookup.address) ?? null\n\n  const relevantTokenBalances = useCurrencyBalances(\n    account ?? undefined,\n    useMemo(() => [inputCurrency ?? undefined, outputCurrency ?? undefined], [inputCurrency, outputCurrency])\n  )\n\n  const isExactIn: boolean = independentField === Field.INPUT\n  const parsedAmount = useMemo(\n    () => tryParseCurrencyAmount(typedValue, (isExactIn ? inputCurrency : outputCurrency) ?? undefined),\n    [inputCurrency, isExactIn, outputCurrency, typedValue]\n  )\n\n  const trade = useBestTrade(\n    isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT,\n    parsedAmount,\n    (isExactIn ? outputCurrency : inputCurrency) ?? undefined\n  )\n\n  const currencyBalances = useMemo(\n    () => ({\n      [Field.INPUT]: relevantTokenBalances[0],\n      [Field.OUTPUT]: relevantTokenBalances[1],\n    }),\n    [relevantTokenBalances]\n  )\n\n  const currencies: { [field in Field]?: Currency | null } = useMemo(\n    () => ({\n      [Field.INPUT]: inputCurrency,\n      [Field.OUTPUT]: outputCurrency,\n    }),\n    [inputCurrency, outputCurrency]\n  )\n\n  // allowed slippage is either auto slippage, or custom user defined slippage if auto slippage disabled\n  const autoSlippageTolerance = useAutoSlippageTolerance(trade.trade)\n  const allowedSlippage = useUserSlippageToleranceWithDefault(autoSlippageTolerance)\n\n  const inputError = useMemo(() => {\n    let inputError: ReactNode | undefined\n\n    if (!account) {\n      inputError = <Trans>Connect Wallet</Trans>\n    }\n\n    if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n      inputError = inputError ?? <Trans>Select a token</Trans>\n    }\n\n    if (!parsedAmount) {\n      inputError = inputError ?? <Trans>Enter an amount</Trans>\n    }\n\n    const formattedTo = isAddress(to)\n    if (!to || !formattedTo) {\n      inputError = inputError ?? <Trans>Enter a recipient</Trans>\n    } else {\n      if (BAD_RECIPIENT_ADDRESSES[formattedTo]) {\n        inputError = inputError ?? <Trans>Invalid recipient</Trans>\n      }\n    }\n\n    // compare input balance to max input based on version\n    const [balanceIn, amountIn] = [currencyBalances[Field.INPUT], trade.trade?.maximumAmountIn(allowedSlippage)]\n\n    if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n      inputError = <Trans>Insufficient {amountIn.currency.symbol} balance</Trans>\n    }\n\n    return inputError\n  }, [account, allowedSlippage, currencies, currencyBalances, parsedAmount, to, trade.trade])\n\n  return useMemo(\n    () => ({\n      currencies,\n      currencyBalances,\n      parsedAmount,\n      inputError,\n      trade,\n      allowedSlippage,\n    }),\n    [allowedSlippage, currencies, currencyBalances, inputError, parsedAmount, trade]\n  )\n}\n\nfunction parseCurrencyFromURLParameter(urlParam: ParsedQs[string]): string {\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam)\n    if (valid) return valid\n    const upper = urlParam.toUpperCase()\n    if (upper === 'ETH') return 'ETH'\n    if (upper in TOKEN_SHORTHANDS) return upper\n  }\n  return ''\n}\n\nfunction parseTokenAmountURLParameter(urlParam: any): string {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : ''\n}\n\nfunction parseIndependentFieldURLParameter(urlParam: any): Field {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT\n}\n\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/\nfunction validatedRecipient(recipient: any): string | null {\n  if (typeof recipient !== 'string') return null\n  const address = isAddress(recipient)\n  if (address) return address\n  if (ENS_NAME_REGEX.test(recipient)) return recipient\n  if (ADDRESS_REGEX.test(recipient)) return recipient\n  return null\n}\n\nexport function queryParametersToSwapState(parsedQs: ParsedQs): SwapState {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency)\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency)\n  const typedValue = parseTokenAmountURLParameter(parsedQs.exactAmount)\n  const independentField = parseIndependentFieldURLParameter(parsedQs.exactField)\n\n  if (inputCurrency === '' && outputCurrency === '' && typedValue === '' && independentField === Field.INPUT) {\n    // Defaults to having the native currency selected\n    inputCurrency = 'ETH'\n  } else if (inputCurrency === outputCurrency) {\n    // clear output if identical\n    outputCurrency = ''\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient)\n\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency === '' ? null : inputCurrency ?? null,\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency === '' ? null : outputCurrency ?? null,\n    },\n    typedValue,\n    independentField,\n    recipient,\n  }\n}\n\n// updates the swap state to use the defaults for a given network\nexport function useDefaultsFromURLSearch(): SwapState {\n  const { chainId } = useWeb3React()\n  const dispatch = useAppDispatch()\n  const parsedQs = useParsedQueryString()\n\n  const parsedSwapState = useMemo(() => {\n    return queryParametersToSwapState(parsedQs)\n  }, [parsedQs])\n\n  useEffect(() => {\n    if (!chainId) return\n    const inputCurrencyId = parsedSwapState[Field.INPUT].currencyId ?? undefined\n    const outputCurrencyId = parsedSwapState[Field.OUTPUT].currencyId ?? undefined\n\n    dispatch(\n      replaceSwapState({\n        typedValue: parsedSwapState.typedValue,\n        field: parsedSwapState.independentField,\n        inputCurrencyId,\n        outputCurrencyId,\n        recipient: parsedSwapState.recipient,\n      })\n    )\n  }, [dispatch, chainId, parsedSwapState])\n\n  return parsedSwapState\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}