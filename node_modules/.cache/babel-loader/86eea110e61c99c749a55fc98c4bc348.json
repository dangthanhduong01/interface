{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decrypt = exports.encrypt = void 0;\nconst util_1 = require(\"../util\");\n/**\n *\n * @param plainText string to be encrypted\n * @param secret hex representation of 32-byte secret\n * returns hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the\n * encrypted plainText.\n */\nasync function encrypt(plainText, secret) {\n  if (secret.length !== 64) throw Error(`secret must be 256 bits`);\n  const ivBytes = crypto.getRandomValues(new Uint8Array(12));\n  const secretKey = await crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), {\n    name: \"aes-gcm\"\n  }, false, [\"encrypt\", \"decrypt\"]);\n  const enc = new TextEncoder();\n  // Will return encrypted plainText with auth tag (ie MAC or checksum) appended at the end\n  const encryptedResult = await window.crypto.subtle.encrypt({\n    name: \"AES-GCM\",\n    iv: ivBytes\n  }, secretKey, enc.encode(plainText));\n  const tagLength = 16;\n  const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);\n  const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);\n  const authTagBytes = new Uint8Array(authTag);\n  const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);\n  const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);\n  return (0, util_1.uint8ArrayToHex)(concatted);\n}\nexports.encrypt = encrypt;\n/**\n *\n * @param cipherText hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.\n * @param secret hex string representation of 32-byte secret\n */\nfunction decrypt(cipherText, secret) {\n  if (secret.length !== 64) throw Error(`secret must be 256 bits`);\n  return new Promise((resolve, reject) => {\n    void async function () {\n      const secretKey = await crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), {\n        name: \"aes-gcm\"\n      }, false, [\"encrypt\", \"decrypt\"]);\n      const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);\n      const ivBytes = encrypted.slice(0, 12);\n      const authTagBytes = encrypted.slice(12, 28);\n      const encryptedPlaintextBytes = encrypted.slice(28);\n      const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);\n      const algo = {\n        name: \"AES-GCM\",\n        iv: new Uint8Array(ivBytes)\n      };\n      try {\n        const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);\n        const decoder = new TextDecoder();\n        resolve(decoder.decode(decrypted));\n      } catch (err) {\n        reject(err);\n      }\n    }();\n  });\n}\nexports.decrypt = decrypt;","map":{"version":3,"names":["Object","defineProperty","exports","value","decrypt","encrypt","util_1","require","plainText","secret","length","Error","ivBytes","crypto","getRandomValues","Uint8Array","secretKey","subtle","importKey","hexStringToUint8Array","name","enc","TextEncoder","encryptedResult","window","iv","encode","tagLength","authTag","slice","byteLength","encryptedPlaintext","authTagBytes","encryptedPlaintextBytes","concatted","uint8ArrayToHex","cipherText","Promise","resolve","reject","encrypted","concattedBytes","algo","decrypted","decoder","TextDecoder","decode","err"],"sources":["/home/diep/freelance/interface/node_modules/@coinbase/wallet-sdk/dist/relay/aes256gcm.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decrypt = exports.encrypt = void 0;\nconst util_1 = require(\"../util\");\n/**\n *\n * @param plainText string to be encrypted\n * @param secret hex representation of 32-byte secret\n * returns hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the\n * encrypted plainText.\n */\nasync function encrypt(plainText, secret) {\n    if (secret.length !== 64)\n        throw Error(`secret must be 256 bits`);\n    const ivBytes = crypto.getRandomValues(new Uint8Array(12));\n    const secretKey = await crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), { name: \"aes-gcm\" }, false, [\"encrypt\", \"decrypt\"]);\n    const enc = new TextEncoder();\n    // Will return encrypted plainText with auth tag (ie MAC or checksum) appended at the end\n    const encryptedResult = await window.crypto.subtle.encrypt({\n        name: \"AES-GCM\",\n        iv: ivBytes,\n    }, secretKey, enc.encode(plainText));\n    const tagLength = 16;\n    const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);\n    const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);\n    const authTagBytes = new Uint8Array(authTag);\n    const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);\n    const concatted = new Uint8Array([\n        ...ivBytes,\n        ...authTagBytes,\n        ...encryptedPlaintextBytes,\n    ]);\n    return (0, util_1.uint8ArrayToHex)(concatted);\n}\nexports.encrypt = encrypt;\n/**\n *\n * @param cipherText hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.\n * @param secret hex string representation of 32-byte secret\n */\nfunction decrypt(cipherText, secret) {\n    if (secret.length !== 64)\n        throw Error(`secret must be 256 bits`);\n    return new Promise((resolve, reject) => {\n        void (async function () {\n            const secretKey = await crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), { name: \"aes-gcm\" }, false, [\"encrypt\", \"decrypt\"]);\n            const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);\n            const ivBytes = encrypted.slice(0, 12);\n            const authTagBytes = encrypted.slice(12, 28);\n            const encryptedPlaintextBytes = encrypted.slice(28);\n            const concattedBytes = new Uint8Array([\n                ...encryptedPlaintextBytes,\n                ...authTagBytes,\n            ]);\n            const algo = {\n                name: \"AES-GCM\",\n                iv: new Uint8Array(ivBytes),\n            };\n            try {\n                const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);\n                const decoder = new TextDecoder();\n                resolve(decoder.decode(decrypted));\n            }\n            catch (err) {\n                reject(err);\n            }\n        })();\n    });\n}\nexports.decrypt = decrypt;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}