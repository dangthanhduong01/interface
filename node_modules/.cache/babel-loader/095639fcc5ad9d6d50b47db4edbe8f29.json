{"ast":null,"code":"var _s = $RefreshSig$();\nimport { i18n } from \"@lingui/core\";\nimport { formatCurrencyAmount } from '@uniswap/conedison/format';\nimport { CurrencyAmount, TradeType } from '@uniswap/sdk-core';\nimport { nativeOnChain } from '@uniswap/smart-order-router';\nimport { TransactionStatus } from 'graphql/data/__generated__/types-and-hooks';\nimport { useMemo } from 'react';\nimport { useCombinedActiveList } from 'state/lists/hooks';\nimport { useMultichainTransactions } from 'state/transactions/hooks';\nimport { TransactionType } from 'state/transactions/types';\nimport { getActivityTitle } from '../constants';\nfunction getCurrency(currencyId, chainId, tokens) {\n  var _tokens$chainId, _tokens$chainId$curre;\n  return currencyId === 'ETH' ? nativeOnChain(chainId) : (_tokens$chainId = tokens[chainId]) === null || _tokens$chainId === void 0 ? void 0 : (_tokens$chainId$curre = _tokens$chainId[currencyId]) === null || _tokens$chainId$curre === void 0 ? void 0 : _tokens$chainId$curre.token;\n}\nfunction buildCurrencyDescriptor(currencyA, amtA, currencyB, amtB) {\n  var _currencyA$symbol, _currencyB$symbol;\n  let delimiter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : /*i18n*/i18n._(\"for\");\n  const formattedA = currencyA ? formatCurrencyAmount(CurrencyAmount.fromRawAmount(currencyA, amtA)) : /*i18n*/i18n._(\"Unknown\");\n  const symbolA = (_currencyA$symbol = currencyA === null || currencyA === void 0 ? void 0 : currencyA.symbol) !== null && _currencyA$symbol !== void 0 ? _currencyA$symbol : '';\n  const formattedB = currencyB ? formatCurrencyAmount(CurrencyAmount.fromRawAmount(currencyB, amtB)) : /*i18n*/i18n._(\"Unknown\");\n  const symbolB = (_currencyB$symbol = currencyB === null || currencyB === void 0 ? void 0 : currencyB.symbol) !== null && _currencyB$symbol !== void 0 ? _currencyB$symbol : '';\n  return [formattedA, symbolA, delimiter, formattedB, symbolB].filter(Boolean).join(' ');\n}\nfunction parseSwap(swap, chainId, tokens) {\n  const tokenIn = getCurrency(swap.inputCurrencyId, chainId, tokens);\n  const tokenOut = getCurrency(swap.outputCurrencyId, chainId, tokens);\n  const [inputRaw, outputRaw] = swap.tradeType === TradeType.EXACT_INPUT ? [swap.inputCurrencyAmountRaw, swap.expectedOutputCurrencyAmountRaw] : [swap.expectedInputCurrencyAmountRaw, swap.outputCurrencyAmountRaw];\n  return {\n    descriptor: buildCurrencyDescriptor(tokenIn, inputRaw, tokenOut, outputRaw),\n    currencies: [tokenIn, tokenOut]\n  };\n}\nfunction parseWrap(wrap, chainId, status) {\n  const native = nativeOnChain(chainId);\n  const wrapped = native.wrapped;\n  const [input, output] = wrap.unwrapped ? [wrapped, native] : [native, wrapped];\n  const descriptor = buildCurrencyDescriptor(input, wrap.currencyAmountRaw, output, wrap.currencyAmountRaw);\n  const title = getActivityTitle(TransactionType.WRAP, status, wrap.unwrapped);\n  const currencies = wrap.unwrapped ? [wrapped, native] : [native, wrapped];\n  return {\n    title,\n    descriptor,\n    currencies\n  };\n}\nfunction parseApproval(approval, chainId, tokens) {\n  var _ref, _currency$symbol;\n  // TODO: Add 'amount' approved to ApproveTransactionInfo so we can distinguish between revoke and approve\n  const currency = getCurrency(approval.tokenAddress, chainId, tokens);\n  const descriptor = (_ref = (_currency$symbol = currency === null || currency === void 0 ? void 0 : currency.symbol) !== null && _currency$symbol !== void 0 ? _currency$symbol : currency === null || currency === void 0 ? void 0 : currency.name) !== null && _ref !== void 0 ? _ref : /*i18n*/i18n._(\"Unknown\");\n  return {\n    descriptor,\n    currencies: [currency]\n  };\n}\nfunction parseLP(lp, chainId, tokens) {\n  const baseCurrency = getCurrency(lp.baseCurrencyId, chainId, tokens);\n  const quoteCurrency = getCurrency(lp.quoteCurrencyId, chainId, tokens);\n  const [baseRaw, quoteRaw] = [lp.expectedAmountBaseRaw, lp.expectedAmountQuoteRaw];\n  const descriptor = buildCurrencyDescriptor(baseCurrency, baseRaw, quoteCurrency, quoteRaw, /*i18n*/i18n._(\"and\"));\n  return {\n    descriptor,\n    currencies: [baseCurrency, quoteCurrency]\n  };\n}\nfunction parseCollectFees(collect, chainId, tokens) {\n  // Adapts CollectFeesTransactionInfo to generic LP type\n  const {\n    currencyId0: baseCurrencyId,\n    currencyId1: quoteCurrencyId,\n    expectedCurrencyOwed0: expectedAmountBaseRaw,\n    expectedCurrencyOwed1: expectedAmountQuoteRaw\n  } = collect;\n  return parseLP({\n    baseCurrencyId,\n    quoteCurrencyId,\n    expectedAmountBaseRaw,\n    expectedAmountQuoteRaw\n  }, chainId, tokens);\n}\nfunction parseMigrateCreateV3(lp, chainId, tokens) {\n  var _baseCurrency$symbol, _quoteCurrency$symbol;\n  const baseCurrency = getCurrency(lp.baseCurrencyId, chainId, tokens);\n  const baseSymbol = (_baseCurrency$symbol = baseCurrency === null || baseCurrency === void 0 ? void 0 : baseCurrency.symbol) !== null && _baseCurrency$symbol !== void 0 ? _baseCurrency$symbol : /*i18n*/i18n._(\"Unknown\");\n  const quoteCurrency = getCurrency(lp.quoteCurrencyId, chainId, tokens);\n  const quoteSymbol = (_quoteCurrency$symbol = quoteCurrency === null || quoteCurrency === void 0 ? void 0 : quoteCurrency.symbol) !== null && _quoteCurrency$symbol !== void 0 ? _quoteCurrency$symbol : /*i18n*/i18n._(\"Unknown\");\n  const descriptor = /*i18n*/i18n._(\"{baseSymbol} and {quoteSymbol}\", {\n    baseSymbol: baseSymbol,\n    quoteSymbol: quoteSymbol\n  });\n  return {\n    descriptor,\n    currencies: [baseCurrency, quoteCurrency]\n  };\n}\nexport function parseLocalActivity(details, chainId, tokens) {\n  try {\n    var _details$receipt, _details$confirmedTim;\n    const status = !details.receipt ? TransactionStatus.Pending : details.receipt.status === 1 || ((_details$receipt = details.receipt) === null || _details$receipt === void 0 ? void 0 : _details$receipt.status) === undefined ? TransactionStatus.Confirmed : TransactionStatus.Failed;\n    const receipt = details.receipt ? {\n      id: details.receipt.transactionHash,\n      ...details.receipt,\n      ...details,\n      status\n    } : undefined;\n    const defaultFields = {\n      hash: details.hash,\n      chainId,\n      title: getActivityTitle(details.info.type, status),\n      status,\n      timestamp: ((_details$confirmedTim = details.confirmedTime) !== null && _details$confirmedTim !== void 0 ? _details$confirmedTim : details.addedTime) / 1000,\n      receipt\n    };\n    let additionalFields = {};\n    const info = details.info;\n    if (info.type === TransactionType.SWAP) {\n      additionalFields = parseSwap(info, chainId, tokens);\n    } else if (info.type === TransactionType.APPROVAL) {\n      additionalFields = parseApproval(info, chainId, tokens);\n    } else if (info.type === TransactionType.WRAP) {\n      additionalFields = parseWrap(info, chainId, status);\n    } else if (info.type === TransactionType.ADD_LIQUIDITY_V3_POOL || info.type === TransactionType.REMOVE_LIQUIDITY_V3 || info.type === TransactionType.ADD_LIQUIDITY_V2_POOL) {\n      additionalFields = parseLP(info, chainId, tokens);\n    } else if (info.type === TransactionType.COLLECT_FEES) {\n      additionalFields = parseCollectFees(info, chainId, tokens);\n    } else if (info.type === TransactionType.MIGRATE_LIQUIDITY_V3 || info.type === TransactionType.CREATE_V3_POOL) {\n      additionalFields = parseMigrateCreateV3(info, chainId, tokens);\n    }\n    return {\n      ...defaultFields,\n      ...additionalFields\n    };\n  } catch (error) {\n    console.debug(`Failed to parse transaction ${details.hash}`, error);\n    return undefined;\n  }\n}\nexport function useLocalActivities(account) {\n  _s();\n  const allTransactions = useMultichainTransactions();\n  const tokens = useCombinedActiveList();\n  return useMemo(() => {\n    const activityByHash = {};\n    for (const [transaction, chainId] of allTransactions) {\n      if (transaction.from !== account) continue;\n      activityByHash[transaction.hash] = parseLocalActivity(transaction, chainId, tokens);\n    }\n    return activityByHash;\n  }, [account, allTransactions, tokens]);\n}\n_s(useLocalActivities, \"MNiKDj6n59O5MbyGY6xcewzUVTw=\", false, function () {\n  return [useMultichainTransactions, useCombinedActiveList];\n});","map":{"version":3,"names":["formatCurrencyAmount","CurrencyAmount","TradeType","nativeOnChain","TransactionStatus","useMemo","useCombinedActiveList","useMultichainTransactions","TransactionType","getActivityTitle","getCurrency","currencyId","chainId","tokens","token","buildCurrencyDescriptor","currencyA","amtA","currencyB","amtB","delimiter","formattedA","fromRawAmount","symbolA","symbol","formattedB","symbolB","filter","Boolean","join","parseSwap","swap","tokenIn","inputCurrencyId","tokenOut","outputCurrencyId","inputRaw","outputRaw","tradeType","EXACT_INPUT","inputCurrencyAmountRaw","expectedOutputCurrencyAmountRaw","expectedInputCurrencyAmountRaw","outputCurrencyAmountRaw","descriptor","currencies","parseWrap","wrap","status","native","wrapped","input","output","unwrapped","currencyAmountRaw","title","WRAP","parseApproval","approval","currency","tokenAddress","name","parseLP","lp","baseCurrency","baseCurrencyId","quoteCurrency","quoteCurrencyId","baseRaw","quoteRaw","expectedAmountBaseRaw","expectedAmountQuoteRaw","parseCollectFees","collect","currencyId0","currencyId1","expectedCurrencyOwed0","expectedCurrencyOwed1","parseMigrateCreateV3","baseSymbol","quoteSymbol","parseLocalActivity","details","receipt","Pending","undefined","Confirmed","Failed","id","transactionHash","defaultFields","hash","info","type","timestamp","confirmedTime","addedTime","additionalFields","SWAP","APPROVAL","ADD_LIQUIDITY_V3_POOL","REMOVE_LIQUIDITY_V3","ADD_LIQUIDITY_V2_POOL","COLLECT_FEES","MIGRATE_LIQUIDITY_V3","CREATE_V3_POOL","error","console","debug","useLocalActivities","account","allTransactions","activityByHash","transaction","from"],"sources":["/home/diep/freelance/interface/src/components/AccountDrawer/MiniPortfolio/Activity/parseLocal.ts"],"sourcesContent":["import { t } from '@lingui/macro'\nimport { formatCurrencyAmount } from '@uniswap/conedison/format'\nimport { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { nativeOnChain } from '@uniswap/smart-order-router'\nimport { SupportedChainId } from 'constants/chains'\nimport { TransactionPartsFragment, TransactionStatus } from 'graphql/data/__generated__/types-and-hooks'\nimport { useMemo } from 'react'\nimport { TokenAddressMap, useCombinedActiveList } from 'state/lists/hooks'\nimport { useMultichainTransactions } from 'state/transactions/hooks'\nimport {\n  AddLiquidityV2PoolTransactionInfo,\n  AddLiquidityV3PoolTransactionInfo,\n  ApproveTransactionInfo,\n  CollectFeesTransactionInfo,\n  CreateV3PoolTransactionInfo,\n  ExactInputSwapTransactionInfo,\n  ExactOutputSwapTransactionInfo,\n  MigrateV2LiquidityToV3TransactionInfo,\n  RemoveLiquidityV3TransactionInfo,\n  TransactionDetails,\n  TransactionType,\n  WrapTransactionInfo,\n} from 'state/transactions/types'\n\nimport { getActivityTitle } from '../constants'\nimport { Activity, ActivityMap } from './types'\n\nfunction getCurrency(currencyId: string, chainId: SupportedChainId, tokens: TokenAddressMap): Currency | undefined {\n  return currencyId === 'ETH' ? nativeOnChain(chainId) : tokens[chainId]?.[currencyId]?.token\n}\n\nfunction buildCurrencyDescriptor(\n  currencyA: Currency | undefined,\n  amtA: string,\n  currencyB: Currency | undefined,\n  amtB: string,\n  delimiter = t`for`\n) {\n  const formattedA = currencyA ? formatCurrencyAmount(CurrencyAmount.fromRawAmount(currencyA, amtA)) : t`Unknown`\n  const symbolA = currencyA?.symbol ?? ''\n  const formattedB = currencyB ? formatCurrencyAmount(CurrencyAmount.fromRawAmount(currencyB, amtB)) : t`Unknown`\n  const symbolB = currencyB?.symbol ?? ''\n  return [formattedA, symbolA, delimiter, formattedB, symbolB].filter(Boolean).join(' ')\n}\n\nfunction parseSwap(\n  swap: ExactInputSwapTransactionInfo | ExactOutputSwapTransactionInfo,\n  chainId: SupportedChainId,\n  tokens: TokenAddressMap\n): Partial<Activity> {\n  const tokenIn = getCurrency(swap.inputCurrencyId, chainId, tokens)\n  const tokenOut = getCurrency(swap.outputCurrencyId, chainId, tokens)\n  const [inputRaw, outputRaw] =\n    swap.tradeType === TradeType.EXACT_INPUT\n      ? [swap.inputCurrencyAmountRaw, swap.expectedOutputCurrencyAmountRaw]\n      : [swap.expectedInputCurrencyAmountRaw, swap.outputCurrencyAmountRaw]\n\n  return {\n    descriptor: buildCurrencyDescriptor(tokenIn, inputRaw, tokenOut, outputRaw),\n    currencies: [tokenIn, tokenOut],\n  }\n}\n\nfunction parseWrap(wrap: WrapTransactionInfo, chainId: SupportedChainId, status: TransactionStatus): Partial<Activity> {\n  const native = nativeOnChain(chainId)\n  const wrapped = native.wrapped\n  const [input, output] = wrap.unwrapped ? [wrapped, native] : [native, wrapped]\n\n  const descriptor = buildCurrencyDescriptor(input, wrap.currencyAmountRaw, output, wrap.currencyAmountRaw)\n  const title = getActivityTitle(TransactionType.WRAP, status, wrap.unwrapped)\n  const currencies = wrap.unwrapped ? [wrapped, native] : [native, wrapped]\n\n  return { title, descriptor, currencies }\n}\n\nfunction parseApproval(\n  approval: ApproveTransactionInfo,\n  chainId: SupportedChainId,\n  tokens: TokenAddressMap\n): Partial<Activity> {\n  // TODO: Add 'amount' approved to ApproveTransactionInfo so we can distinguish between revoke and approve\n  const currency = getCurrency(approval.tokenAddress, chainId, tokens)\n  const descriptor = currency?.symbol ?? currency?.name ?? t`Unknown`\n  return {\n    descriptor,\n    currencies: [currency],\n  }\n}\n\ntype GenericLPInfo = Omit<\n  AddLiquidityV3PoolTransactionInfo | RemoveLiquidityV3TransactionInfo | AddLiquidityV2PoolTransactionInfo,\n  'type'\n>\nfunction parseLP(lp: GenericLPInfo, chainId: SupportedChainId, tokens: TokenAddressMap): Partial<Activity> {\n  const baseCurrency = getCurrency(lp.baseCurrencyId, chainId, tokens)\n  const quoteCurrency = getCurrency(lp.quoteCurrencyId, chainId, tokens)\n  const [baseRaw, quoteRaw] = [lp.expectedAmountBaseRaw, lp.expectedAmountQuoteRaw]\n  const descriptor = buildCurrencyDescriptor(baseCurrency, baseRaw, quoteCurrency, quoteRaw, t`and`)\n\n  return { descriptor, currencies: [baseCurrency, quoteCurrency] }\n}\n\nfunction parseCollectFees(\n  collect: CollectFeesTransactionInfo,\n  chainId: SupportedChainId,\n  tokens: TokenAddressMap\n): Partial<Activity> {\n  // Adapts CollectFeesTransactionInfo to generic LP type\n  const {\n    currencyId0: baseCurrencyId,\n    currencyId1: quoteCurrencyId,\n    expectedCurrencyOwed0: expectedAmountBaseRaw,\n    expectedCurrencyOwed1: expectedAmountQuoteRaw,\n  } = collect\n  return parseLP({ baseCurrencyId, quoteCurrencyId, expectedAmountBaseRaw, expectedAmountQuoteRaw }, chainId, tokens)\n}\n\nfunction parseMigrateCreateV3(\n  lp: MigrateV2LiquidityToV3TransactionInfo | CreateV3PoolTransactionInfo,\n  chainId: SupportedChainId,\n  tokens: TokenAddressMap\n): Partial<Activity> {\n  const baseCurrency = getCurrency(lp.baseCurrencyId, chainId, tokens)\n  const baseSymbol = baseCurrency?.symbol ?? t`Unknown`\n  const quoteCurrency = getCurrency(lp.quoteCurrencyId, chainId, tokens)\n  const quoteSymbol = quoteCurrency?.symbol ?? t`Unknown`\n  const descriptor = t`${baseSymbol} and ${quoteSymbol}`\n\n  return { descriptor, currencies: [baseCurrency, quoteCurrency] }\n}\n\nexport function parseLocalActivity(\n  details: TransactionDetails,\n  chainId: SupportedChainId,\n  tokens: TokenAddressMap\n): Activity | undefined {\n  try {\n    const status = !details.receipt\n      ? TransactionStatus.Pending\n      : details.receipt.status === 1 || details.receipt?.status === undefined\n      ? TransactionStatus.Confirmed\n      : TransactionStatus.Failed\n\n    const receipt: TransactionPartsFragment | undefined = details.receipt\n      ? {\n          id: details.receipt.transactionHash,\n          ...details.receipt,\n          ...details,\n          status,\n        }\n      : undefined\n\n    const defaultFields = {\n      hash: details.hash,\n      chainId,\n      title: getActivityTitle(details.info.type, status),\n      status,\n      timestamp: (details.confirmedTime ?? details.addedTime) / 1000,\n      receipt,\n    }\n\n    let additionalFields: Partial<Activity> = {}\n    const info = details.info\n    if (info.type === TransactionType.SWAP) {\n      additionalFields = parseSwap(info, chainId, tokens)\n    } else if (info.type === TransactionType.APPROVAL) {\n      additionalFields = parseApproval(info, chainId, tokens)\n    } else if (info.type === TransactionType.WRAP) {\n      additionalFields = parseWrap(info, chainId, status)\n    } else if (\n      info.type === TransactionType.ADD_LIQUIDITY_V3_POOL ||\n      info.type === TransactionType.REMOVE_LIQUIDITY_V3 ||\n      info.type === TransactionType.ADD_LIQUIDITY_V2_POOL\n    ) {\n      additionalFields = parseLP(info, chainId, tokens)\n    } else if (info.type === TransactionType.COLLECT_FEES) {\n      additionalFields = parseCollectFees(info, chainId, tokens)\n    } else if (info.type === TransactionType.MIGRATE_LIQUIDITY_V3 || info.type === TransactionType.CREATE_V3_POOL) {\n      additionalFields = parseMigrateCreateV3(info, chainId, tokens)\n    }\n\n    return { ...defaultFields, ...additionalFields }\n  } catch (error) {\n    console.debug(`Failed to parse transaction ${details.hash}`, error)\n    return undefined\n  }\n}\n\nexport function useLocalActivities(account: string): ActivityMap {\n  const allTransactions = useMultichainTransactions()\n  const tokens = useCombinedActiveList()\n\n  return useMemo(() => {\n    const activityByHash: ActivityMap = {}\n    for (const [transaction, chainId] of allTransactions) {\n      if (transaction.from !== account) continue\n\n      activityByHash[transaction.hash] = parseLocalActivity(transaction, chainId, tokens)\n    }\n    return activityByHash\n  }, [account, allTransactions, tokens])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}