{"ast":null,"code":"import { Token } from '@uniswap/sdk-core';\nimport ERC20_ABI from 'abis/erc20.json';\nimport { DEFAULT_ERC20_DECIMALS } from 'constants/tokens';\nimport { Interface } from 'ethers/lib/utils';\nimport { isAddress } from 'utils';\nimport { arrayToSlices } from 'utils/arrays';\nimport { buildCurrencyKey, currencyKey } from 'utils/currencyKey';\nexport const DEFAULT_GAS_LIMIT = 1000000;\nconst Erc20 = new Interface(ERC20_ABI);\nconst Erc20Bytes32 = new Interface(ERC20_ABI); // Used for tokens that return bytes32 for name/symbol rather than string\n\n// TODO(WEB-3060): cartcrom - adapt support for multi-function multi-interface multicalls into redux-multicall to remove than this custom cache/chunking logic\n// Infura rejects calls with gas costs > 10x the current block gas limit; in such case we split the call into 2 chunks\nasync function fetchChunk(multicall, chunk) {\n  try {\n    return (await multicall.callStatic.multicall(chunk)).returnData;\n  } catch (error) {\n    var _error$message;\n    if (error.code === -32603 || ((_error$message = error.message) === null || _error$message === void 0 ? void 0 : _error$message.indexOf('execution ran out of gas')) !== -1) {\n      if (chunk.length > 1) {\n        const half = Math.floor(chunk.length / 2);\n        return Promise.all([fetchChunk(multicall, chunk.slice(0, half)), fetchChunk(multicall, chunk.slice(half, chunk.length))]).then(_ref => {\n          let [c0, c1] = _ref;\n          return [...c0, ...c1];\n        });\n      }\n    }\n    console.error('Failed to fetch chunk', error);\n    throw error;\n  }\n}\nfunction tryParseToken(address, chainId, data) {\n  try {\n    const [nameData, symbolData, decimalsData, nameDataBytes32, symbolDataBytes32] = data;\n    const name = nameData.success ? Erc20.decodeFunctionResult('name', nameData.returnData)[0] : nameDataBytes32.success ? Erc20Bytes32.decodeFunctionResult('name', nameDataBytes32.returnData)[0] : undefined;\n    const symbol = symbolData.success ? Erc20.decodeFunctionResult('symbol', symbolData.returnData)[0] : symbolDataBytes32.success ? Erc20Bytes32.decodeFunctionResult('symbol', symbolDataBytes32.returnData)[0] : undefined;\n    const decimals = decimalsData.success ? parseInt(decimalsData.returnData) : DEFAULT_ERC20_DECIMALS;\n    return new Token(chainId, address, decimals, symbol, name);\n  } catch (error) {\n    console.error(`Failed to fetch token at address ${address} on chain ${chainId}`);\n    return undefined;\n  }\n}\nfunction parseTokens(addresses, chainId, returnData) {\n  const tokenDataSlices = arrayToSlices(returnData, 5);\n  return tokenDataSlices.reduce((acc, slice, index) => {\n    const parsedToken = tryParseToken(addresses[index], chainId, slice);\n    if (parsedToken) acc[parsedToken.address] = parsedToken;\n    return acc;\n  }, {});\n}\nconst createCalls = (target, callData) => callData.map(callData => ({\n  target,\n  callData,\n  gasLimit: DEFAULT_GAS_LIMIT\n}));\nfunction createCallsForToken(address) {\n  return createCalls(address, [Erc20.encodeFunctionData('name'), Erc20.encodeFunctionData('symbol'), Erc20.encodeFunctionData('decimals'), Erc20Bytes32.encodeFunctionData('name'), Erc20Bytes32.encodeFunctionData('symbol')]);\n}\n\n// Prevents tokens from being fetched multiple times\nconst TokenPromiseCache = {};\n\n// Returns tokens using a single RPC call to the multicall contract\nexport async function getTokensAsync(addresses, chainId, multicall) {\n  if (addresses.length === 0) return {};\n  const formattedAddresses = [];\n  const calls = [];\n  const previouslyCalledTokens = [];\n  addresses.forEach(tokenAddress => {\n    const key = buildCurrencyKey(chainId, tokenAddress);\n    const previousCall = TokenPromiseCache[key];\n    if (previousCall !== undefined) {\n      previouslyCalledTokens.push(previousCall);\n    } else {\n      const formattedAddress = isAddress(tokenAddress);\n      if (!formattedAddress) return;\n      formattedAddresses.push(formattedAddress);\n      calls.push(...createCallsForToken(formattedAddress));\n    }\n  });\n  const calledTokens = fetchChunk(multicall, calls).then(returnData => parseTokens(addresses, chainId, returnData));\n\n  // Caches tokens currently being fetched for further calls to use\n  formattedAddresses.forEach(address => TokenPromiseCache[buildCurrencyKey(chainId, address)] = calledTokens.then(tokenMap => tokenMap[address]));\n  const tokenMap = await calledTokens;\n  // Add tokens from previous calls to the map of tokens fetched in this call\n  const resolvedPreviousTokens = await Promise.all(previouslyCalledTokens);\n  resolvedPreviousTokens.forEach(token => token && (tokenMap[currencyKey(token)] = token));\n  return tokenMap;\n}","map":{"version":3,"names":["Token","ERC20_ABI","DEFAULT_ERC20_DECIMALS","Interface","isAddress","arrayToSlices","buildCurrencyKey","currencyKey","DEFAULT_GAS_LIMIT","Erc20","Erc20Bytes32","fetchChunk","multicall","chunk","callStatic","returnData","error","code","message","indexOf","length","half","Math","floor","Promise","all","slice","then","c0","c1","console","tryParseToken","address","chainId","data","nameData","symbolData","decimalsData","nameDataBytes32","symbolDataBytes32","name","success","decodeFunctionResult","undefined","symbol","decimals","parseInt","parseTokens","addresses","tokenDataSlices","reduce","acc","index","parsedToken","createCalls","target","callData","map","gasLimit","createCallsForToken","encodeFunctionData","TokenPromiseCache","getTokensAsync","formattedAddresses","calls","previouslyCalledTokens","forEach","tokenAddress","key","previousCall","push","formattedAddress","calledTokens","tokenMap","resolvedPreviousTokens","token"],"sources":["/home/diep/freelance/interface/src/components/AccountDrawer/MiniPortfolio/Pools/getTokensAsync.ts"],"sourcesContent":["import { Token } from '@uniswap/sdk-core'\nimport ERC20_ABI from 'abis/erc20.json'\nimport { Erc20Interface } from 'abis/types/Erc20'\nimport { Erc20Bytes32Interface } from 'abis/types/Erc20Bytes32'\nimport { SupportedChainId } from 'constants/chains'\nimport { DEFAULT_ERC20_DECIMALS } from 'constants/tokens'\nimport { Interface } from 'ethers/lib/utils'\nimport { UniswapInterfaceMulticall } from 'types/v3'\nimport { isAddress } from 'utils'\nimport { arrayToSlices } from 'utils/arrays'\nimport { buildCurrencyKey, CurrencyKey, currencyKey } from 'utils/currencyKey'\n\ntype TokenMap = { [address: string]: Token | undefined }\nexport type Call = { target: string; callData: string; gasLimit: number }\ntype CallResult = { success: boolean; returnData: string }\nexport const DEFAULT_GAS_LIMIT = 1_000_000\n\nconst Erc20 = new Interface(ERC20_ABI) as Erc20Interface\nconst Erc20Bytes32 = new Interface(ERC20_ABI) as Erc20Bytes32Interface // Used for tokens that return bytes32 for name/symbol rather than string\n\n// TODO(WEB-3060): cartcrom - adapt support for multi-function multi-interface multicalls into redux-multicall to remove than this custom cache/chunking logic\n// Infura rejects calls with gas costs > 10x the current block gas limit; in such case we split the call into 2 chunks\nasync function fetchChunk(multicall: UniswapInterfaceMulticall, chunk: Call[]): Promise<CallResult[]> {\n  try {\n    return (await multicall.callStatic.multicall(chunk)).returnData\n  } catch (error) {\n    if (error.code === -32603 || error.message?.indexOf('execution ran out of gas') !== -1) {\n      if (chunk.length > 1) {\n        const half = Math.floor(chunk.length / 2)\n        return Promise.all([\n          fetchChunk(multicall, chunk.slice(0, half)),\n          fetchChunk(multicall, chunk.slice(half, chunk.length)),\n        ]).then(([c0, c1]) => [...c0, ...c1])\n      }\n    }\n    console.error('Failed to fetch chunk', error)\n    throw error\n  }\n}\n\nfunction tryParseToken(address: string, chainId: SupportedChainId, data: CallResult[]) {\n  try {\n    const [nameData, symbolData, decimalsData, nameDataBytes32, symbolDataBytes32] = data\n\n    const name = nameData.success\n      ? (Erc20.decodeFunctionResult('name', nameData.returnData)[0] as string)\n      : nameDataBytes32.success\n      ? (Erc20Bytes32.decodeFunctionResult('name', nameDataBytes32.returnData)[0] as string)\n      : undefined\n    const symbol = symbolData.success\n      ? (Erc20.decodeFunctionResult('symbol', symbolData.returnData)[0] as string)\n      : symbolDataBytes32.success\n      ? (Erc20Bytes32.decodeFunctionResult('symbol', symbolDataBytes32.returnData)[0] as string)\n      : undefined\n    const decimals = decimalsData.success ? parseInt(decimalsData.returnData) : DEFAULT_ERC20_DECIMALS\n\n    return new Token(chainId, address, decimals, symbol, name)\n  } catch (error) {\n    console.error(`Failed to fetch token at address ${address} on chain ${chainId}`)\n    return undefined\n  }\n}\n\nfunction parseTokens(addresses: string[], chainId: SupportedChainId, returnData: CallResult[]) {\n  const tokenDataSlices = arrayToSlices(returnData, 5)\n\n  return tokenDataSlices.reduce((acc: TokenMap, slice, index) => {\n    const parsedToken = tryParseToken(addresses[index], chainId, slice)\n    if (parsedToken) acc[parsedToken.address] = parsedToken\n    return acc\n  }, {})\n}\n\nconst createCalls = (target: string, callData: string[]): Call[] =>\n  callData.map((callData) => ({ target, callData, gasLimit: DEFAULT_GAS_LIMIT }))\n\nfunction createCallsForToken(address: string) {\n  return createCalls(address, [\n    Erc20.encodeFunctionData('name'),\n    Erc20.encodeFunctionData('symbol'),\n    Erc20.encodeFunctionData('decimals'),\n    Erc20Bytes32.encodeFunctionData('name'),\n    Erc20Bytes32.encodeFunctionData('symbol'),\n  ])\n}\n\n// Prevents tokens from being fetched multiple times\nconst TokenPromiseCache: { [key: CurrencyKey]: Promise<Token | undefined> | undefined } = {}\n\n// Returns tokens using a single RPC call to the multicall contract\nexport async function getTokensAsync(\n  addresses: string[],\n  chainId: SupportedChainId,\n  multicall: UniswapInterfaceMulticall\n): Promise<TokenMap> {\n  if (addresses.length === 0) return {}\n  const formattedAddresses: string[] = []\n  const calls: Call[] = []\n  const previouslyCalledTokens: Promise<Token | undefined>[] = []\n\n  addresses.forEach((tokenAddress) => {\n    const key = buildCurrencyKey(chainId, tokenAddress)\n    const previousCall = TokenPromiseCache[key]\n    if (previousCall !== undefined) {\n      previouslyCalledTokens.push(previousCall)\n    } else {\n      const formattedAddress = isAddress(tokenAddress)\n      if (!formattedAddress) return\n      formattedAddresses.push(formattedAddress)\n      calls.push(...createCallsForToken(formattedAddress))\n    }\n  })\n\n  const calledTokens = fetchChunk(multicall, calls).then((returnData) => parseTokens(addresses, chainId, returnData))\n\n  // Caches tokens currently being fetched for further calls to use\n  formattedAddresses.forEach(\n    (address) =>\n      (TokenPromiseCache[buildCurrencyKey(chainId, address)] = calledTokens.then((tokenMap) => tokenMap[address]))\n  )\n\n  const tokenMap = await calledTokens\n  // Add tokens from previous calls to the map of tokens fetched in this call\n  const resolvedPreviousTokens = await Promise.all(previouslyCalledTokens)\n  resolvedPreviousTokens.forEach((token) => token && (tokenMap[currencyKey(token)] = token))\n\n  return tokenMap\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}