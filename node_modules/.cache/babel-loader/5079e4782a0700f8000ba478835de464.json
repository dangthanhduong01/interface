{"ast":null,"code":"var _s = $RefreshSig$();\nimport { skipToken } from '@reduxjs/toolkit/query/react';\nimport { CurrencyAmount, TradeType } from '@uniswap/sdk-core';\nimport { IMetric, setGlobalMetric } from '@uniswap/smart-order-router';\nimport { sendTiming } from 'components/analytics';\nimport { AVERAGE_L1_BLOCK_TIME } from 'constants/chainInfo';\nimport { useStablecoinAmountFromFiatValue } from 'hooks/useStablecoinPrice';\nimport { useRoutingAPIArguments } from 'lib/hooks/routing/useRoutingAPIArguments';\nimport { useMemo } from 'react';\nimport { RouterPreference, useGetQuoteQuery } from 'state/routing/slice';\nimport { TradeState } from './types';\nimport { computeRoutes, transformRoutesToTrade } from './utils';\n\n/**\n * Returns the best trade by invoking the routing api or the smart order router on the client\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */\nexport function useRoutingAPITrade(tradeType, amountSpecified, otherCurrency, routerPreference) {\n  _s();\n  var _useStablecoinAmountF;\n  const [currencyIn, currencyOut] = useMemo(() => tradeType === TradeType.EXACT_INPUT ? [amountSpecified === null || amountSpecified === void 0 ? void 0 : amountSpecified.currency, otherCurrency] : [otherCurrency, amountSpecified === null || amountSpecified === void 0 ? void 0 : amountSpecified.currency], [amountSpecified, otherCurrency, tradeType]);\n  const queryArgs = useRoutingAPIArguments({\n    tokenIn: currencyIn,\n    tokenOut: currencyOut,\n    amount: amountSpecified,\n    tradeType,\n    routerPreference\n  });\n  const {\n    isLoading,\n    isError,\n    data: quoteResult,\n    currentData\n  } = useGetQuoteQuery(queryArgs !== null && queryArgs !== void 0 ? queryArgs : skipToken, {\n    // Price-fetching is informational and costly, so it's done less frequently.\n    pollingInterval: routerPreference === RouterPreference.PRICE ? 60000 : AVERAGE_L1_BLOCK_TIME,\n    // If latest quote from cache was fetched > 2m ago, instantly repoll for another instead of waiting for next poll period\n    refetchOnMountOrArgChange: 2 * 60\n  });\n  const route = useMemo(() => computeRoutes(currencyIn, currencyOut, tradeType, quoteResult), [currencyIn, currencyOut, quoteResult, tradeType]);\n\n  // get USD gas cost of trade in active chains stablecoin amount\n  const gasUseEstimateUSD = (_useStablecoinAmountF = useStablecoinAmountFromFiatValue(quoteResult === null || quoteResult === void 0 ? void 0 : quoteResult.gasUseEstimateUSD)) !== null && _useStablecoinAmountF !== void 0 ? _useStablecoinAmountF : null;\n  const isSyncing = currentData !== quoteResult;\n  return useMemo(() => {\n    if (!currencyIn || !currencyOut || currencyIn.equals(currencyOut)) {\n      return {\n        state: TradeState.INVALID,\n        trade: undefined\n      };\n    }\n    if (isLoading && !quoteResult) {\n      // only on first hook render\n      return {\n        state: TradeState.LOADING,\n        trade: undefined\n      };\n    }\n    let otherAmount = undefined;\n    if (quoteResult) {\n      if (tradeType === TradeType.EXACT_INPUT && currencyOut) {\n        otherAmount = CurrencyAmount.fromRawAmount(currencyOut, quoteResult.quote);\n      }\n      if (tradeType === TradeType.EXACT_OUTPUT && currencyIn) {\n        otherAmount = CurrencyAmount.fromRawAmount(currencyIn, quoteResult.quote);\n      }\n    }\n    if (isError || !otherAmount || !route || route.length === 0 || !queryArgs) {\n      return {\n        state: TradeState.NO_ROUTE_FOUND,\n        trade: undefined\n      };\n    }\n    try {\n      const trade = transformRoutesToTrade(route, tradeType, quoteResult === null || quoteResult === void 0 ? void 0 : quoteResult.blockNumber, gasUseEstimateUSD);\n      return {\n        // always return VALID regardless of isFetching status\n        state: isSyncing ? TradeState.SYNCING : TradeState.VALID,\n        trade\n      };\n    } catch (e) {\n      return {\n        state: TradeState.INVALID,\n        trade: undefined\n      };\n    }\n  }, [currencyIn, currencyOut, quoteResult, isLoading, tradeType, isError, route, queryArgs, gasUseEstimateUSD, isSyncing]);\n}\n\n// only want to enable this when app hook called\n_s(useRoutingAPITrade, \"aDCY55hlISlcH4JFgjtaa4yQvzg=\", false, function () {\n  return [useRoutingAPIArguments, useGetQuoteQuery, useStablecoinAmountFromFiatValue];\n});\nclass GAMetric extends IMetric {\n  putDimensions() {\n    return;\n  }\n  putMetric(key, value, unit) {\n    sendTiming('Routing API', `${key} | ${unit}`, value, 'client');\n  }\n}\nsetGlobalMetric(new GAMetric());","map":{"version":3,"names":["skipToken","CurrencyAmount","TradeType","IMetric","setGlobalMetric","sendTiming","AVERAGE_L1_BLOCK_TIME","useStablecoinAmountFromFiatValue","useRoutingAPIArguments","useMemo","RouterPreference","useGetQuoteQuery","TradeState","computeRoutes","transformRoutesToTrade","useRoutingAPITrade","tradeType","amountSpecified","otherCurrency","routerPreference","currencyIn","currencyOut","EXACT_INPUT","currency","queryArgs","tokenIn","tokenOut","amount","isLoading","isError","data","quoteResult","currentData","pollingInterval","PRICE","refetchOnMountOrArgChange","route","gasUseEstimateUSD","isSyncing","equals","state","INVALID","trade","undefined","LOADING","otherAmount","fromRawAmount","quote","EXACT_OUTPUT","length","NO_ROUTE_FOUND","blockNumber","SYNCING","VALID","e","GAMetric","putDimensions","putMetric","key","value","unit"],"sources":["/home/diep/freelance/interface/src/state/routing/useRoutingAPITrade.ts"],"sourcesContent":["import { skipToken } from '@reduxjs/toolkit/query/react'\nimport { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { IMetric, MetricLoggerUnit, setGlobalMetric } from '@uniswap/smart-order-router'\nimport { sendTiming } from 'components/analytics'\nimport { AVERAGE_L1_BLOCK_TIME } from 'constants/chainInfo'\nimport { useStablecoinAmountFromFiatValue } from 'hooks/useStablecoinPrice'\nimport { useRoutingAPIArguments } from 'lib/hooks/routing/useRoutingAPIArguments'\nimport ms from 'ms.macro'\nimport { useMemo } from 'react'\nimport { RouterPreference, useGetQuoteQuery } from 'state/routing/slice'\n\nimport { InterfaceTrade, TradeState } from './types'\nimport { computeRoutes, transformRoutesToTrade } from './utils'\n\n/**\n * Returns the best trade by invoking the routing api or the smart order router on the client\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */\nexport function useRoutingAPITrade<TTradeType extends TradeType>(\n  tradeType: TTradeType,\n  amountSpecified: CurrencyAmount<Currency> | undefined,\n  otherCurrency: Currency | undefined,\n  routerPreference: RouterPreference\n): {\n  state: TradeState\n  trade: InterfaceTrade<Currency, Currency, TTradeType> | undefined\n} {\n  const [currencyIn, currencyOut]: [Currency | undefined, Currency | undefined] = useMemo(\n    () =>\n      tradeType === TradeType.EXACT_INPUT\n        ? [amountSpecified?.currency, otherCurrency]\n        : [otherCurrency, amountSpecified?.currency],\n    [amountSpecified, otherCurrency, tradeType]\n  )\n\n  const queryArgs = useRoutingAPIArguments({\n    tokenIn: currencyIn,\n    tokenOut: currencyOut,\n    amount: amountSpecified,\n    tradeType,\n    routerPreference,\n  })\n\n  const {\n    isLoading,\n    isError,\n    data: quoteResult,\n    currentData,\n  } = useGetQuoteQuery(queryArgs ?? skipToken, {\n    // Price-fetching is informational and costly, so it's done less frequently.\n    pollingInterval: routerPreference === RouterPreference.PRICE ? ms`1m` : AVERAGE_L1_BLOCK_TIME,\n    // If latest quote from cache was fetched > 2m ago, instantly repoll for another instead of waiting for next poll period\n    refetchOnMountOrArgChange: 2 * 60,\n  })\n\n  const route = useMemo(\n    () => computeRoutes(currencyIn, currencyOut, tradeType, quoteResult),\n    [currencyIn, currencyOut, quoteResult, tradeType]\n  )\n\n  // get USD gas cost of trade in active chains stablecoin amount\n  const gasUseEstimateUSD = useStablecoinAmountFromFiatValue(quoteResult?.gasUseEstimateUSD) ?? null\n\n  const isSyncing = currentData !== quoteResult\n\n  return useMemo(() => {\n    if (!currencyIn || !currencyOut || currencyIn.equals(currencyOut)) {\n      return {\n        state: TradeState.INVALID,\n        trade: undefined,\n      }\n    }\n\n    if (isLoading && !quoteResult) {\n      // only on first hook render\n      return {\n        state: TradeState.LOADING,\n        trade: undefined,\n      }\n    }\n\n    let otherAmount = undefined\n    if (quoteResult) {\n      if (tradeType === TradeType.EXACT_INPUT && currencyOut) {\n        otherAmount = CurrencyAmount.fromRawAmount(currencyOut, quoteResult.quote)\n      }\n\n      if (tradeType === TradeType.EXACT_OUTPUT && currencyIn) {\n        otherAmount = CurrencyAmount.fromRawAmount(currencyIn, quoteResult.quote)\n      }\n    }\n\n    if (isError || !otherAmount || !route || route.length === 0 || !queryArgs) {\n      return {\n        state: TradeState.NO_ROUTE_FOUND,\n        trade: undefined,\n      }\n    }\n\n    try {\n      const trade = transformRoutesToTrade(route, tradeType, quoteResult?.blockNumber, gasUseEstimateUSD)\n      return {\n        // always return VALID regardless of isFetching status\n        state: isSyncing ? TradeState.SYNCING : TradeState.VALID,\n        trade,\n      }\n    } catch (e) {\n      return { state: TradeState.INVALID, trade: undefined }\n    }\n  }, [\n    currencyIn,\n    currencyOut,\n    quoteResult,\n    isLoading,\n    tradeType,\n    isError,\n    route,\n    queryArgs,\n    gasUseEstimateUSD,\n    isSyncing,\n  ])\n}\n\n// only want to enable this when app hook called\nclass GAMetric extends IMetric {\n  putDimensions() {\n    return\n  }\n\n  putMetric(key: string, value: number, unit?: MetricLoggerUnit) {\n    sendTiming('Routing API', `${key} | ${unit}`, value, 'client')\n  }\n}\n\nsetGlobalMetric(new GAMetric())\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}